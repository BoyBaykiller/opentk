// This file is auto generated, do not edit.
using System;
using System.Runtime.InteropServices;
using OpenTK.Graphics;

namespace OpenTK.Graphics.OpenGL
{
    public static unsafe partial class GL
    {
        /// <summary> <b>[requires: v1.0]</b> Specify whether front- or back-facing facets can be culled. </summary>
        /// <param name="mode"> Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCullFace.xhtml" /></remarks>
        public static void CullFace(CullFaceMode mode) => GLPointers._CullFace_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0]</b> Define front- and back-facing polygons. </summary>
        /// <param name="mode"> Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFrontFace.xhtml" /></remarks>
        public static void FrontFace(FrontFaceDirection mode) => GLPointers._FrontFace_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.0]</b> Specify implementation-specific hints. </summary>
        /// <param name="target"> Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted. </param>
        /// <param name="mode"> Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glHint.xhtml" /></remarks>
        public static void Hint(HintTarget target, HintMode mode) => GLPointers._Hint_fnptr((uint)target, (uint)mode);
        
        /// <summary> <b>[requires: v1.0]</b> Specify the width of rasterized lines. </summary>
        /// <param name="width"> Specifies the width of rasterized lines. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLineWidth.xhtml" /></remarks>
        public static void LineWidth(float width) => GLPointers._LineWidth_fnptr(width);
        
        /// <summary> <b>[requires: v1.0]</b> Specify the diameter of rasterized points. </summary>
        /// <param name="size"> Specifies the diameter of rasterized points. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointSize.xhtml" /></remarks>
        public static void PointSize(float size) => GLPointers._PointSize_fnptr(size);
        
        /// <summary> <b>[requires: v1.0]</b> Select a polygon rasterization mode. </summary>
        /// <param name="face"> Specifies the polygons that mode applies to. Must be GL_FRONT_AND_BACK for front- and back-facing polygons. </param>
        /// <param name="mode"> Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The initial value is GL_FILL for both front- and back-facing polygons. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonMode.xhtml" /></remarks>
        public static void PolygonMode(MaterialFace face, PolygonMode mode) => GLPointers._PolygonMode_fnptr((uint)face, (uint)mode);
        
        /// <summary> <b>[requires: v1.0]</b> Define the scissor box. </summary>
        /// <param name="x"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="y"> Specify the lower left corner of the scissor box. Initially (0, 0). </param>
        /// <param name="width"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissor.xhtml" /></remarks>
        public static void Scissor(int x, int y, int width, int height) => GLPointers._Scissor_fnptr(x, y, width, height);
        
        /// <summary> <b>[requires: v1.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterf(TextureTarget target, TextureParameterName pname, float param) => GLPointers._TexParameterf_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterfv(TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers._TexParameterfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameteri(TextureTarget target, TextureParameterName pname, int param) => GLPointers._TexParameteri_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameteriv(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._TexParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> Specify a one-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage1D.xhtml" /></remarks>
        public static void TexImage1D(TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexImage1D_fnptr((uint)target, level, internalformat, width, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0]</b> Specify a two-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml" /></remarks>
        public static void TexImage2D(TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexImage2D_fnptr((uint)target, level, internalformat, width, height, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0]</b> Specify which color buffers are to be drawn into. </summary>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
        public static void DrawBuffer(DrawBufferMode buf) => GLPointers._DrawBuffer_fnptr((uint)buf);
        
        /// <summary> <b>[requires: v1.0]</b> Clear buffers to preset values. </summary>
        /// <param name="mask"> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml" /></remarks>
        public static void Clear(ClearBufferMask mask) => GLPointers._Clear_fnptr((uint)mask);
        
        /// <summary> <b>[requires: v1.0]</b> Specify clear values for the color buffers. </summary>
        /// <param name="red"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="green"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="blue"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <param name="alpha"> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml" /></remarks>
        public static void ClearColor(float red, float green, float blue, float alpha) => GLPointers._ClearColor_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.0]</b> Specify the clear value for the stencil buffer. </summary>
        /// <param name="s"> Specifies the index used when the stencil buffer is cleared. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearStencil.xhtml" /></remarks>
        public static void ClearStencil(int s) => GLPointers._ClearStencil_fnptr(s);
        
        /// <summary> <b>[requires: v1.0]</b> Specify the clear value for the depth buffer. </summary>
        /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
        public static void ClearDepth(double depth) => GLPointers._ClearDepth_fnptr(depth);
        
        /// <summary> <b>[requires: v1.0]</b> Control the front and back writing of individual bits in the stencil planes. </summary>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMask.xhtml" /></remarks>
        public static void StencilMask(uint mask) => GLPointers._StencilMask_fnptr(mask);
        
        /// <summary> <b>[requires: v1.0]</b> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="red"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="green"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="blue"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="alpha"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml" /></remarks>
        public static void ColorMask(bool red, bool green, bool blue, bool alpha) => GLPointers._ColorMask_fnptr((byte)(red ? 1 : 0), (byte)(green ? 1 : 0), (byte)(blue ? 1 : 0), (byte)(alpha ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0]</b> Enable or disable writing into the depth buffer. </summary>
        /// <param name="flag"> Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthMask.xhtml" /></remarks>
        public static void DepthMask(bool flag) => GLPointers._DepthMask_fnptr((byte)(flag ? 1 : 0));
        
        /// <summary> <b>[requires: v1.0]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Disable(EnableCap cap) => GLPointers._Disable_fnptr((uint)cap);
        
        /// <summary> <b>[requires: v1.0]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Enable(EnableCap cap) => GLPointers._Enable_fnptr((uint)cap);
        
        /// <summary> <b>[requires: v1.0]</b> Block until all GL execution is complete. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFinish.xhtml" /></remarks>
        public static void Finish() => GLPointers._Finish_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> Force execution of GL commands in finite time. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlush.xhtml" /></remarks>
        public static void Flush() => GLPointers._Flush_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> Specify pixel arithmetic. </summary>
        /// <param name="sfactor"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactor"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" /></remarks>
        public static void BlendFunc(BlendingFactor sfactor, BlendingFactor dfactor) => GLPointers._BlendFunc_fnptr((uint)sfactor, (uint)dfactor);
        
        /// <summary> <b>[requires: v1.0]</b> Specify a logical pixel operation for rendering. </summary>
        /// <param name="opcode"> Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLogicOp.xhtml" /></remarks>
        public static void LogicOp(LogicOp opcode) => GLPointers._LogicOp_fnptr((uint)opcode);
        
        /// <summary> <b>[requires: v1.0]</b> Set front and back function and reference value for stencil testing. </summary>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml" /></remarks>
        public static void StencilFunc(StencilFunction func, int reference, uint mask) => GLPointers._StencilFunc_fnptr((uint)func, reference, mask);
        
        /// <summary> <b>[requires: v1.0]</b> Set front and back stencil test actions. </summary>
        /// <param name="sfail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="dpfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="dppass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOp.xhtml" /></remarks>
        public static void StencilOp(StencilOp fail, StencilOp zfail, StencilOp zpass) => GLPointers._StencilOp_fnptr((uint)fail, (uint)zfail, (uint)zpass);
        
        /// <summary> <b>[requires: v1.0]</b> Specify the value used for depth buffer comparisons. </summary>
        /// <param name="func"> Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml" /></remarks>
        public static void DepthFunc(DepthFunction func) => GLPointers._DepthFunc_fnptr((uint)func);
        
        /// <summary> <b>[requires: v1.0]</b> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml" /></remarks>
        public static void PixelStoref(PixelStoreParameter pname, float param) => GLPointers._PixelStoref_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> Set pixel storage modes. </summary>
        /// <param name="pname"> Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT. </param>
        /// <param name="param"> Specifies the value that pname is set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPixelStore.xhtml" /></remarks>
        public static void PixelStorei(PixelStoreParameter pname, int param) => GLPointers._PixelStorei_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.0]</b> Select a color buffer source for pixels. </summary>
        /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
        public static void ReadBuffer(ReadBufferMode src) => GLPointers._ReadBuffer_fnptr((uint)src);
        
        /// <summary> <b>[requires: v1.0]</b> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="data">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
        public static void ReadPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._ReadPixels_fnptr(x, y, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetBooleanv(GetPName pname, bool* data) => GLPointers._GetBooleanv_fnptr((uint)pname, (byte*)data);
        
        /// <summary> <b>[requires: v1.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetDoublev(GetPName pname, double* data) => GLPointers._GetDoublev_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v1.0]</b> Return error information. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetError.xhtml" /></remarks>
        public static ErrorCode GetError() => (ErrorCode) GLPointers._GetError_fnptr();
        
        /// <summary> <b>[requires: v1.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetFloatv(GetPName pname, float* data) => GLPointers._GetFloatv_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v1.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetIntegerv(GetPName pname, int* data) => GLPointers._GetIntegerv_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v1.0]</b> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml" /></remarks>
        public static byte* GetString_(StringName name) => GLPointers._GetString_fnptr((uint)name);
        
        /// <summary> <b>[requires: v1.0]</b> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers._GetTexImage_fnptr((uint)target, level, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.0]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterfv(TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers._GetTexParameterfv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameteriv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._GetTexParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTexLevelParameterfv(TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers._GetTexLevelParameterfv_fnptr((uint)target, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTexLevelParameteriv(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._GetTexLevelParameteriv_fnptr((uint)target, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.0]</b> Test whether a capability is enabled. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml" /></remarks>
        public static bool IsEnabled(EnableCap cap) => GLPointers._IsEnabled_fnptr((uint)cap) != 0;
        
        /// <summary> <b>[requires: v1.0]</b> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
        public static void DepthRange(double n, double f) => GLPointers._DepthRange_fnptr(n, f);
        
        /// <summary> <b>[requires: v1.0]</b> Set the viewport. </summary>
        /// <param name="x"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="width"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <param name="height"> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml" /></remarks>
        public static void Viewport(int x, int y, int width, int height) => GLPointers._Viewport_fnptr(x, y, width, height);
        
        /// <summary> <b>[requires: v1.1]</b> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml" /></remarks>
        public static void DrawArrays(PrimitiveType mode, int first, int count) => GLPointers._DrawArrays_fnptr((uint)mode, first, count);
        
        /// <summary> <b>[requires: v1.1]</b> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElements.xhtml" /></remarks>
        public static void DrawElements(PrimitiveType mode, int count, DrawElementsType type, void* indices) => GLPointers._DrawElements_fnptr((uint)mode, count, (uint)type, indices);
        
        /// <summary> <b>[requires: v1.1]</b> Set the scale and units used to calculate depth values. </summary>
        /// <param name="factor"> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0. </param>
        /// <param name="units"> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml" /></remarks>
        public static void PolygonOffset(float factor, float units) => GLPointers._PolygonOffset_fnptr(factor, units);
        
        /// <summary> <b>[requires: v1.1]</b> Copy pixels into a 1D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the left corner of the row of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. The height of the texture image is 1. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage1D.xhtml" /></remarks>
        public static void CopyTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._CopyTexImage1D_fnptr((uint)target, level, (uint)internalformat, x, y, width, border);
        
        /// <summary> <b>[requires: v1.1]</b> Copy pixels into a 2D texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8. </param>
        /// <param name="x"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="y"> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied. </param>
        /// <param name="width"> Specifies the width of the texture image. </param>
        /// <param name="height"> Specifies the height of the texture image. </param>
        /// <param name="border"> Must be 0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexImage2D.xhtml" /></remarks>
        public static void CopyTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._CopyTexImage2D_fnptr((uint)target, level, (uint)internalformat, x, y, width, height, border);
        
        /// <summary> <b>[requires: v1.1]</b> Copy a one-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
        public static void CopyTexSubImage1D(TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._CopyTexSubImage1D_fnptr((uint)target, level, xoffset, x, y, width);
        
        /// <summary> <b>[requires: v1.1]</b> Copy a two-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
        public static void CopyTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._CopyTexSubImage2D_fnptr((uint)target, level, xoffset, yoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v1.1]</b> Specify a one-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage1D. Must be GL_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
        public static void TexSubImage1D(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexSubImage1D_fnptr((uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.1]</b> Specify a two-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage2D. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
        public static void TexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexSubImage2D_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.1]</b> Bind a named texture to a texturing target. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="texture"> Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTexture.xhtml" /></remarks>
        public static void BindTexture(TextureTarget target, TextureHandle texture) => GLPointers._BindTexture_fnptr((uint)target, (int)texture);
        
        /// <summary> <b>[requires: v1.1]</b> Delete named textures. </summary>
        /// <param name="n"> Specifies the number of textures to be deleted. </param>
        /// <param name="textures"> Specifies an array of textures to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTextures.xhtml" /></remarks>
        public static void DeleteTextures(int n, TextureHandle* textures) => GLPointers._DeleteTextures_fnptr(n, (int*)textures);
        
        /// <summary> <b>[requires: v1.1]</b> Generate texture names. </summary>
        /// <param name="n"> Specifies the number of texture names to be generated. </param>
        /// <param name="textures"> Specifies an array in which the generated texture names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTextures.xhtml" /></remarks>
        public static void GenTextures(int n, TextureHandle* textures) => GLPointers._GenTextures_fnptr(n, (int*)textures);
        
        /// <summary> <b>[requires: v1.1]</b> Determine if a name corresponds to a texture. </summary>
        /// <param name="texture"> Specifies a value that may be the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTexture.xhtml" /></remarks>
        public static bool IsTexture(TextureHandle texture) => GLPointers._IsTexture_fnptr((int)texture) != 0;
        
        /// <summary> <b>[requires: v1.2]</b> Render primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElements.xhtml" /></remarks>
        public static void DrawRangeElements(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => GLPointers._DrawRangeElements_fnptr((uint)mode, start, end, count, (uint)type, indices);
        
        /// <summary> <b>[requires: v1.2]</b> Specify a three-dimensional texture image. </summary>
        /// <param name="target"> Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="data"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3D.xhtml" /></remarks>
        public static void TexImage3D(TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexImage3D_fnptr((uint)target, level, internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.2]</b> Specify a three-dimensional texture subimage. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexSubImage3D. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
        public static void TexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexSubImage3D_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v1.2]</b> Copy a three-dimensional texture subimage. </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for glCopyTexSubImage3D function. Must be GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
        public static void CopyTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._CopyTexSubImage3D_fnptr((uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v1.3]</b> Select active texture unit. </summary>
        /// <param name="texture"> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from zero to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS minus one. The initial value is GL_TEXTURE0. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveTexture.xhtml" /></remarks>
        public static void ActiveTexture(TextureUnit texture) => GLPointers._ActiveTexture_fnptr((uint)texture);
        
        /// <summary> <b>[requires: v1.3]</b> Specify multisample coverage parameters. </summary>
        /// <param name="value"> Specify a single floating-point sample coverage value. The value is clamped to the range 0 1 . The initial value is 1.0. </param>
        /// <param name="invert"> Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleCoverage.xhtml" /></remarks>
        public static void SampleCoverage(float value, bool invert) => GLPointers._SampleCoverage_fnptr(value, (byte)(invert ? 1 : 0));
        
        /// <summary> <b>[requires: v1.3]</b> Specify a three-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high. </param>
        /// <param name="depth"> Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage3D.xhtml" /></remarks>
        public static void CompressedTexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => GLPointers._CompressedTexImage3D_fnptr((uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> Specify a two-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide. </param>
        /// <param name="height"> Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage2D.xhtml" /></remarks>
        public static void CompressedTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => GLPointers._CompressedTexImage2D_fnptr((uint)target, level, (uint)internalformat, width, height, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> Specify a one-dimensional texture image in a compressed format. </summary>
        /// <param name="target"> Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="internalformat"> Specifies the format of the compressed image data stored at address data. </param>
        /// <param name="width"> Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1. </param>
        /// <param name="border"> This value must be 0. </param>
        /// <param name="imageSize"> Specifies the number of unsigned bytes of image data starting at the address specified by data. </param>
        /// <param name="data"> Specifies a pointer to the compressed image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexImage1D.xhtml" /></remarks>
        public static void CompressedTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => GLPointers._CompressedTexImage1D_fnptr((uint)target, level, (uint)internalformat, width, border, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage3D function. Must be GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
        public static void CompressedTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTexSubImage3D_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glCompressedTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
        public static void CompressedTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTexSubImage2D_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="target">Specifies the target, to which the texture is bound, for glCompressedTexSubImage1D function. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
        public static void CompressedTexSubImage1D(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTexSubImage1D_fnptr((uint)target, level, xoffset, width, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v1.3]</b> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetCompressedTexImage(TextureTarget target, int level, void* img) => GLPointers._GetCompressedTexImage_fnptr((uint)target, level, img);
        
        /// <summary> <b>[requires: v1.4]</b> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="srcRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dstRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="srcAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dstAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml" /></remarks>
        public static void BlendFuncSeparate(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers._BlendFuncSeparate_fnptr((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
        
        /// <summary> <b>[requires: v1.4]</b> Render multiple sets of primitives from array data. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Points to an array of starting indices in the enabled arrays. </param>
        /// <param name="count"> Points to an array of the number of indices to be rendered. </param>
        /// <param name="drawcount"> Specifies the size of the first and count </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArrays.xhtml" /></remarks>
        public static void MultiDrawArrays(PrimitiveType mode, int* first, int* count, int drawcount) => GLPointers._MultiDrawArrays_fnptr((uint)mode, first, count, drawcount);
        
        /// <summary> <b>[requires: v1.4]</b> Render multiple sets of primitives by specifying indices of array data elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count and indices arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElements.xhtml" /></remarks>
        public static void MultiDrawElements(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount) => GLPointers._MultiDrawElements_fnptr((uint)mode, count, (uint)type, indices, drawcount);
        
        /// <summary> <b>[requires: v1.4]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameterf(PointParameterNameARB pname, float param) => GLPointers._PointParameterf_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.4]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameterfv(PointParameterNameARB pname, float* parameters) => GLPointers._PointParameterfv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.4]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="param"> For glPointParameterf and glPointParameteri, specifies the value that pname will be set to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameteri(PointParameterNameARB pname, int param) => GLPointers._PointParameteri_fnptr((uint)pname, param);
        
        /// <summary> <b>[requires: v1.4]</b> Specify point parameters. </summary>
        /// <param name="pname"> Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted. </param>
        /// <param name="parameters"> For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or values to be assigned to pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointParameter.xhtml" /></remarks>
        public static void PointParameteriv(PointParameterNameARB pname, int* parameters) => GLPointers._PointParameteriv_fnptr((uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> Set the blend color. </summary>
        /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
        /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml" /></remarks>
        public static void BlendColor(float red, float green, float blue, float alpha) => GLPointers._BlendColor_fnptr(red, green, blue, alpha);
        
        /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
        public static void BlendEquation(BlendEquationModeEXT mode) => GLPointers._BlendEquation_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v1.5]</b> Generate query object names. </summary>
        /// <param name="n"> Specifies the number of query object names to be generated. </param>
        /// <param name="ids"> Specifies an array in which the generated query object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenQueries.xhtml" /></remarks>
        public static void GenQueries(int n, QueryHandle* ids) => GLPointers._GenQueries_fnptr(n, (int*)ids);
        
        /// <summary> <b>[requires: v1.5]</b> Delete named query objects. </summary>
        /// <param name="n"> Specifies the number of query objects to be deleted. </param>
        /// <param name="ids"> Specifies an array of query objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteQueries.xhtml" /></remarks>
        public static void DeleteQueries(int n, QueryHandle* ids) => GLPointers._DeleteQueries_fnptr(n, (int*)ids);
        
        /// <summary> <b>[requires: v1.5]</b> Determine if a name corresponds to a query object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsQuery.xhtml" /></remarks>
        public static bool IsQuery(QueryHandle id) => GLPointers._IsQuery_fnptr((int)id) != 0;
        
        /// <summary> <b>[requires: v1.5]</b> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml" /></remarks>
        public static void BeginQuery(QueryTarget target, QueryHandle id) => GLPointers._BeginQuery_fnptr((uint)target, (int)id);
        
        /// <summary> <b>[requires: v1.5]</b> Delimit the boundaries of a query object. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml" /></remarks>
        public static void EndQuery(QueryTarget target) => GLPointers._EndQuery_fnptr((uint)target);
        
        /// <summary> <b>[requires: v1.5]</b> Return parameters of a query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryiv.xhtml" /></remarks>
        public static void GetQueryiv(QueryTarget target, QueryParameterName pname, int* parameters) => GLPointers._GetQueryiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectiv(QueryHandle id, QueryObjectParameterName pname, int* parameters) => GLPointers._GetQueryObjectiv_fnptr((int)id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectuiv(QueryHandle id, QueryObjectParameterName pname, uint* parameters) => GLPointers._GetQueryObjectuiv_fnptr((int)id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> Bind a named buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml" /></remarks>
        public static void BindBuffer(BufferTargetARB target, BufferHandle buffer) => GLPointers._BindBuffer_fnptr((uint)target, (int)buffer);
        
        /// <summary> <b>[requires: v1.5]</b> Delete named buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to be deleted. </param>
        /// <param name="buffers"> Specifies an array of buffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml" /></remarks>
        public static void DeleteBuffers(int n, BufferHandle* buffers) => GLPointers._DeleteBuffers_fnptr(n, (int*)buffers);
        
        /// <summary> <b>[requires: v1.5]</b> Generate buffer object names. </summary>
        /// <param name="n"> Specifies the number of buffer object names to be generated. </param>
        /// <param name="buffers"> Specifies an array in which the generated buffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml" /></remarks>
        public static void GenBuffers(int n, BufferHandle* buffers) => GLPointers._GenBuffers_fnptr(n, (int*)buffers);
        
        /// <summary> <b>[requires: v1.5]</b> Determine if a name corresponds to a buffer object. </summary>
        /// <param name="buffer"> Specifies a value that may be the name of a buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsBuffer.xhtml" /></remarks>
        public static bool IsBuffer(BufferHandle buffer) => GLPointers._IsBuffer_fnptr((int)buffer) != 0;
        
        /// <summary> <b>[requires: v1.5]</b> Creates and initializes a buffer object's data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
        public static void BufferData(BufferTargetARB target, nint size, void* data, BufferUsageARB usage) => GLPointers._BufferData_fnptr((uint)target, size, data, (uint)usage);
        
        /// <summary> <b>[requires: v1.5]</b> Updates a subset of a buffer object's data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
        public static void BufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._BufferSubData_fnptr((uint)target, offset, size, data);
        
        /// <summary> <b>[requires: v1.5]</b> Returns a subset of a buffer object's data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
        public static void GetBufferSubData(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._GetBufferSubData_fnptr((uint)target, offset, size, data);
        
        /// <summary> <b>[requires: v1.5]</b> Map all of a buffer object's data store into the client's address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
        public static void* MapBuffer(BufferTargetARB target, BufferAccessARB access) => GLPointers._MapBuffer_fnptr((uint)target, (uint)access);
        
        /// <summary> <b>[requires: v1.5]</b> Release the mapping of a buffer object's data store into the client's address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glUnmapBuffer, which must be one of the buffer binding targets in the following table: </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
        public static bool UnmapBuffer(BufferTargetARB target) => GLPointers._UnmapBuffer_fnptr((uint)target) != 0;
        
        /// <summary> <b>[requires: v1.5]</b> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="value"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="data"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetBufferParameteriv(BufferTargetARB target, BufferPNameARB pname, int* parameters) => GLPointers._GetBufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v1.5]</b> Return the pointer to a mapped buffer object's data store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
        public static void GetBufferPointerv(BufferTargetARB target, BufferPointerNameARB pname, void** parameters) => GLPointers._GetBufferPointerv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml" /></remarks>
        public static void BlendEquationSeparate(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._BlendEquationSeparate_fnptr((uint)modeRGB, (uint)modeAlpha);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
        public static void DrawBuffers(int n, DrawBufferMode* bufs) => GLPointers._DrawBuffers_fnptr(n, (uint*)bufs);
        
        /// <summary> <b>[requires: v2.0]</b> Set front and/or back stencil test actions. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="sfail"> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP. </param>
        /// <param name="dpfail"> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <param name="dppass"> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilOpSeparate.xhtml" /></remarks>
        public static void StencilOpSeparate(StencilFaceDirection face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => GLPointers._StencilOpSeparate_fnptr((uint)face, (uint)sfail, (uint)dpfail, (uint)dppass);
        
        /// <summary> <b>[requires: v2.0]</b> Set front and/or back function and reference value for stencil testing. </summary>
        /// <param name="face"> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="func"> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS. </param>
        /// <param name="reference"> Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n is the number of bitplanes in the stencil buffer. The initial value is 0. </param>
        /// <param name="mask"> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFuncSeparate.xhtml" /></remarks>
        public static void StencilFuncSeparate(StencilFaceDirection face, StencilFunction func, int reference, uint mask) => GLPointers._StencilFuncSeparate_fnptr((uint)face, (uint)func, reference, mask);
        
        /// <summary> <b>[requires: v2.0]</b> Control the front and/or back writing of individual bits in the stencil planes. </summary>
        /// <param name="face"> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. </param>
        /// <param name="mask"> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilMaskSeparate.xhtml" /></remarks>
        public static void StencilMaskSeparate(StencilFaceDirection face, uint mask) => GLPointers._StencilMaskSeparate_fnptr((uint)face, mask);
        
        /// <summary> <b>[requires: v2.0]</b> Attaches a shader object to a program object. </summary>
        /// <param name="program">Specifies the program object to which a shader object will be attached.</param>
        /// <param name="shader">Specifies the shader object that is to be attached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glAttachShader.xhtml" /></remarks>
        public static void AttachShader(ProgramHandle program, ShaderHandle shader) => GLPointers._AttachShader_fnptr((int)program, (int)shader);
        
        /// <summary> <b>[requires: v2.0]</b> Associates a generic vertex attribute index with a named attribute variable. </summary>
        /// <param name="program">Specifies the handle of the program object in which the association is to be made.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be bound.</param>
        /// <param name="name">Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindAttribLocation.xhtml" /></remarks>
        public static void BindAttribLocation(ProgramHandle program, uint index, byte* name) => GLPointers._BindAttribLocation_fnptr((int)program, index, name);
        
        /// <summary> <b>[requires: v2.0]</b> Compiles a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be compiled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompileShader.xhtml" /></remarks>
        public static void CompileShader(ShaderHandle shader) => GLPointers._CompileShader_fnptr((int)shader);
        
        /// <summary> <b>[requires: v2.0]</b> Creates a program object. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml" /></remarks>
        public static ProgramHandle CreateProgram() => (ProgramHandle) GLPointers._CreateProgram_fnptr();
        
        /// <summary> <b>[requires: v2.0]</b> Creates a shader object. </summary>
        /// <param name="shaderType">Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml" /></remarks>
        public static ShaderHandle CreateShader(ShaderType type) => (ShaderHandle) GLPointers._CreateShader_fnptr((uint)type);
        
        /// <summary> <b>[requires: v2.0]</b> Deletes a program object. </summary>
        /// <param name="program">Specifies the program object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml" /></remarks>
        public static void DeleteProgram(ProgramHandle program) => GLPointers._DeleteProgram_fnptr((int)program);
        
        /// <summary> <b>[requires: v2.0]</b> Deletes a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be deleted.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml" /></remarks>
        public static void DeleteShader(ShaderHandle shader) => GLPointers._DeleteShader_fnptr((int)shader);
        
        /// <summary> <b>[requires: v2.0]</b> Detaches a shader object from a program object to which it is attached. </summary>
        /// <param name="program">Specifies the program object from which to detach the shader object.</param>
        /// <param name="shader">Specifies the shader object to be detached.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDetachShader.xhtml" /></remarks>
        public static void DetachShader(ProgramHandle program, ShaderHandle shader) => GLPointers._DetachShader_fnptr((int)program, (int)shader);
        
        /// <summary> <b>[requires: v2.0]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void DisableVertexAttribArray(uint index) => GLPointers._DisableVertexAttribArray_fnptr(index);
        
        /// <summary> <b>[requires: v2.0]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void EnableVertexAttribArray(uint index) => GLPointers._EnableVertexAttribArray_fnptr(index);
        
        /// <summary> <b>[requires: v2.0]</b> Returns information about an active attribute variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the attribute variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute variable.</param>
        /// <param name="type">Returns the data type of the attribute variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the attribute variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAttrib.xhtml" /></remarks>
        public static void GetActiveAttrib(ProgramHandle program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers._GetActiveAttrib_fnptr((int)program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v2.0]</b> Returns information about an active uniform variable for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform variable.</param>
        /// <param name="type">Returns the data type of the uniform variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniform.xhtml" /></remarks>
        public static void GetActiveUniform(ProgramHandle program, uint index, int bufSize, int* length, int* size, UniformType* type, byte* name) => GLPointers._GetActiveUniform_fnptr((int)program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v2.0]</b> Returns the handles of the shader objects attached to a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned in shaders.</param>
        /// <param name="shaders">Specifies an array that is used to return the names of attached shader objects.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml" /></remarks>
        public static void GetAttachedShaders(ProgramHandle program, int maxCount, int* count, ShaderHandle* shaders) => GLPointers._GetAttachedShaders_fnptr((int)program, maxCount, count, (int*)shaders);
        
        /// <summary> <b>[requires: v2.0]</b> Returns the location of an attribute variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetAttribLocation.xhtml" /></remarks>
        public static int GetAttribLocation(ProgramHandle program, byte* name) => GLPointers._GetAttribLocation_fnptr((int)program, name);
        
        /// <summary> <b>[requires: v2.0]</b> Returns a parameter from a program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgram.xhtml" /></remarks>
        public static void GetProgramiv(ProgramHandle program, ProgramPropertyARB pname, int* parameters) => GLPointers._GetProgramiv_fnptr((int)program, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> Returns the information log for a program object. </summary>
        /// <param name="program">Specifies the program object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml" /></remarks>
        public static void GetProgramInfoLog(ProgramHandle program, int bufSize, int* length, byte* infoLog) => GLPointers._GetProgramInfoLog_fnptr((int)program, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v2.0]</b> Returns a parameter from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.</param>
        /// <param name="parameters">Returns the requested object parameter.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShader.xhtml" /></remarks>
        public static void GetShaderiv(ShaderHandle shader, ShaderParameterName pname, int* parameters) => GLPointers._GetShaderiv_fnptr((int)shader, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> Returns the information log for a shader object. </summary>
        /// <param name="shader">Specifies the shader object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml" /></remarks>
        public static void GetShaderInfoLog(ShaderHandle shader, int bufSize, int* length, byte* infoLog) => GLPointers._GetShaderInfoLog_fnptr((int)shader, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v2.0]</b> Returns the source code string from a shader object. </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in source (excluding the null terminator).</param>
        /// <param name="source">Specifies an array of characters that is used to return the source code string.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderSource.xhtml" /></remarks>
        public static void GetShaderSource(ShaderHandle shader, int bufSize, int* length, byte* source) => GLPointers._GetShaderSource_fnptr((int)shader, bufSize, length, source);
        
        /// <summary> <b>[requires: v2.0]</b> Returns the location of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml" /></remarks>
        public static int GetUniformLocation(ProgramHandle program, byte* name) => GLPointers._GetUniformLocation_fnptr((int)program, name);
        
        /// <summary> <b>[requires: v2.0]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformfv(ProgramHandle program, int location, float* parameters) => GLPointers._GetUniformfv_fnptr((int)program, location, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformiv(ProgramHandle program, int location, int* parameters) => GLPointers._GetUniformiv_fnptr((int)program, location, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribdv(uint index, VertexAttribPropertyARB pname, double* parameters) => GLPointers._GetVertexAttribdv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribfv(uint index, VertexAttribPropertyARB pname, float* parameters) => GLPointers._GetVertexAttribfv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribiv(uint index, VertexAttribPropertyARB pname, int* parameters) => GLPointers._GetVertexAttribiv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v2.0]</b> Return the address of the specified generic vertex attribute pointer. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be returned.</param>
        /// <param name="pname">Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.</param>
        /// <param name="pointer">Returns the pointer value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttribPointerv.xhtml" /></remarks>
        public static void GetVertexAttribPointerv(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => GLPointers._GetVertexAttribPointerv_fnptr(index, (uint)pname, pointer);
        
        /// <summary> <b>[requires: v2.0]</b> Determines if a name corresponds to a program object. </summary>
        /// <param name="program">Specifies a potential program object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgram.xhtml" /></remarks>
        public static bool IsProgram(ProgramHandle program) => GLPointers._IsProgram_fnptr((int)program) != 0;
        
        /// <summary> <b>[requires: v2.0]</b> Determines if a name corresponds to a shader object. </summary>
        /// <param name="shader">Specifies a potential shader object.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsShader.xhtml" /></remarks>
        public static bool IsShader(ShaderHandle shader) => GLPointers._IsShader_fnptr((int)shader) != 0;
        
        /// <summary> <b>[requires: v2.0]</b> Links a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be linked.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml" /></remarks>
        public static void LinkProgram(ProgramHandle program) => GLPointers._LinkProgram_fnptr((int)program);
        
        /// <summary> <b>[requires: v2.0]</b> Replaces the source code in a shader object. </summary>
        /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the string and length arrays.</param>
        /// <param name="str">Specifies an array of pointers to strings containing the source code to be loaded into the shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderSource.xhtml" /></remarks>
        public static void ShaderSource(ShaderHandle shader, int count, byte** str, int* length) => GLPointers._ShaderSource_fnptr((int)shader, count, str, length);
        
        /// <summary> <b>[requires: v2.0]</b> Installs a program object as part of current rendering state. </summary>
        /// <param name="program">Specifies the handle of the program object whose executables are to be used as part of current rendering state.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgram.xhtml" /></remarks>
        public static void UseProgram(ProgramHandle program) => GLPointers._UseProgram_fnptr((int)program);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1f(int location, float v0) => GLPointers._Uniform1f_fnptr(location, v0);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2f(int location, float v0, float v1) => GLPointers._Uniform2f_fnptr(location, v0, v1);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3f(int location, float v0, float v1, float v2) => GLPointers._Uniform3f_fnptr(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4f(int location, float v0, float v1, float v2, float v3) => GLPointers._Uniform4f_fnptr(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1i(int location, int v0) => GLPointers._Uniform1i_fnptr(location, v0);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2i(int location, int v0, int v1) => GLPointers._Uniform2i_fnptr(location, v0, v1);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3i(int location, int v0, int v1, int v2) => GLPointers._Uniform3i_fnptr(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4i(int location, int v0, int v1, int v2, int v3) => GLPointers._Uniform4i_fnptr(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1fv(int location, int count, float* value) => GLPointers._Uniform1fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2fv(int location, int count, float* value) => GLPointers._Uniform2fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3fv(int location, int count, float* value) => GLPointers._Uniform3fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4fv(int location, int count, float* value) => GLPointers._Uniform4fv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1iv(int location, int count, int* value) => GLPointers._Uniform1iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2iv(int location, int count, int* value) => GLPointers._Uniform2iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3iv(int location, int count, int* value) => GLPointers._Uniform3iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4iv(int location, int count, int* value) => GLPointers._Uniform4iv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2fv(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix2fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3fv(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix3fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4fv(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix4fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.0]</b> Validates a program object. </summary>
        /// <param name="program">Specifies the handle of the program object to be validated.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgram.xhtml" /></remarks>
        public static void ValidateProgram(ProgramHandle program) => GLPointers._ValidateProgram_fnptr((int)program);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1d(uint index, double x) => GLPointers._VertexAttrib1d_fnptr(index, x);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1dv(uint index, double* v) => GLPointers._VertexAttrib1dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1f(uint index, float x) => GLPointers._VertexAttrib1f_fnptr(index, x);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1fv(uint index, float* v) => GLPointers._VertexAttrib1fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1s(uint index, short x) => GLPointers._VertexAttrib1s_fnptr(index, x);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib1sv(uint index, short* v) => GLPointers._VertexAttrib1sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2d(uint index, double x, double y) => GLPointers._VertexAttrib2d_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2dv(uint index, double* v) => GLPointers._VertexAttrib2dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2f(uint index, float x, float y) => GLPointers._VertexAttrib2f_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2fv(uint index, float* v) => GLPointers._VertexAttrib2fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2s(uint index, short x, short y) => GLPointers._VertexAttrib2s_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib2sv(uint index, short* v) => GLPointers._VertexAttrib2sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3d(uint index, double x, double y, double z) => GLPointers._VertexAttrib3d_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3dv(uint index, double* v) => GLPointers._VertexAttrib3dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3f(uint index, float x, float y, float z) => GLPointers._VertexAttrib3f_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3fv(uint index, float* v) => GLPointers._VertexAttrib3fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3s(uint index, short x, short y, short z) => GLPointers._VertexAttrib3s_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib3sv(uint index, short* v) => GLPointers._VertexAttrib3sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nbv(uint index, sbyte* v) => GLPointers._VertexAttrib4Nbv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Niv(uint index, int* v) => GLPointers._VertexAttrib4Niv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nsv(uint index, short* v) => GLPointers._VertexAttrib4Nsv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nub(uint index, byte x, byte y, byte z, byte w) => GLPointers._VertexAttrib4Nub_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nubv(uint index, byte* v) => GLPointers._VertexAttrib4Nubv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nuiv(uint index, uint* v) => GLPointers._VertexAttrib4Nuiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4Nusv(uint index, ushort* v) => GLPointers._VertexAttrib4Nusv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4bv(uint index, sbyte* v) => GLPointers._VertexAttrib4bv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4d(uint index, double x, double y, double z, double w) => GLPointers._VertexAttrib4d_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4dv(uint index, double* v) => GLPointers._VertexAttrib4dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4f(uint index, float x, float y, float z, float w) => GLPointers._VertexAttrib4f_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4fv(uint index, float* v) => GLPointers._VertexAttrib4fv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4iv(uint index, int* v) => GLPointers._VertexAttrib4iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4s(uint index, short x, short y, short z, short w) => GLPointers._VertexAttrib4s_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4sv(uint index, short* v) => GLPointers._VertexAttrib4sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4ubv(uint index, byte* v) => GLPointers._VertexAttrib4ubv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4uiv(uint index, uint* v) => GLPointers._VertexAttrib4uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttrib4usv(uint index, ushort* v) => GLPointers._VertexAttrib4usv_fnptr(index, v);
        
        /// <summary> <b>[requires: v2.0]</b> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribPointer(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, void* pointer) => GLPointers._VertexAttribPointer_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, pointer);
        
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2x3fv(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix2x3fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3x2fv(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix3x2fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix2x4fv(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix2x4fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4x2fv(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix4x2fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix3x4fv(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix3x4fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v2.1]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void UniformMatrix4x3fv(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix4x3fv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.0]</b> Enable and disable writing of frame buffer color components. </summary>
        /// <param name="buf"> For glColorMaski, specifies the index of the draw buffer whose color mask to set. </param>
        /// <param name="red"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="green"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="blue"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <param name="alpha"> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glColorMask.xhtml" /></remarks>
        public static void ColorMaski(uint index, bool r, bool g, bool b, bool a) => GLPointers._ColorMaski_fnptr(index, (byte)(r ? 1 : 0), (byte)(g ? 1 : 0), (byte)(b ? 1 : 0), (byte)(a ? 1 : 0));
        
        /// <summary> <b>[requires: v3.0]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetBooleani_v(BufferTargetARB target, uint index, bool* data) => GLPointers._GetBooleani_v_fnptr((uint)target, index, (byte*)data);
        
        /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetIntegeri_v(GetPName target, uint index, int* data) => GLPointers._GetIntegeri_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v3.0]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Enablei(EnableCap target, uint index) => GLPointers._Enablei_fnptr((uint)target, index);
        
        /// <summary> <b>[requires: v3.0]</b> Enable or disable server-side GL capabilities. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the switch to disable (for glEnablei and glDisablei only). </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml" /></remarks>
        public static void Disablei(EnableCap target, uint index) => GLPointers._Disablei_fnptr((uint)target, index);
        
        /// <summary> <b>[requires: v3.0]</b> Test whether a capability is enabled. </summary>
        /// <param name="cap"> Specifies a symbolic constant indicating a GL capability. </param>
        /// <param name="index"> Specifies the index of the capability. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml" /></remarks>
        public static bool IsEnabledi(EnableCap target, uint index) => GLPointers._IsEnabledi_fnptr((uint)target, index) != 0;
        
        /// <summary> <b>[requires: v3.0]</b> Start transform feedback operation. </summary>
        /// <param name="primitiveMode"> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml" /></remarks>
        public static void BeginTransformFeedback(PrimitiveType primitiveMode) => GLPointers._BeginTransformFeedback_fnptr((uint)primitiveMode);
        
        /// <summary> <b>[requires: v3.0]</b> Start transform feedback operation. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml" /></remarks>
        public static void EndTransformFeedback() => GLPointers._EndTransformFeedback_fnptr();
        
        /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Bind a range within a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
        /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml" /></remarks>
        public static void BindBufferRange(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._BindBufferRange_fnptr((uint)target, index, (int)buffer, offset, size);
        
        /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Bind a buffer object to an indexed buffer target. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
        /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml" /></remarks>
        public static void BindBufferBase(BufferTargetARB target, uint index, BufferHandle buffer) => GLPointers._BindBufferBase_fnptr((uint)target, index, (int)buffer);
        
        /// <summary> <b>[requires: v3.0]</b> Specify values to record in transform feedback buffers. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="count"> The number of varying variables used for transform feedback. </param>
        /// <param name="varyings"> An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback. </param>
        /// <param name="bufferMode"> Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackVaryings.xhtml" /></remarks>
        public static void TransformFeedbackVaryings(ProgramHandle program, int count, byte** varyings, TransformFeedbackBufferMode bufferMode) => GLPointers._TransformFeedbackVaryings_fnptr((int)program, count, varyings, (uint)bufferMode);
        
        /// <summary> <b>[requires: v3.0]</b> Retrieve information about varying variables selected for transform feedback. </summary>
        /// <param name="program"> The name of the target program object. </param>
        /// <param name="index"> The index of the varying variable whose information to retrieve. </param>
        /// <param name="bufSize"> The maximum number of characters, including the null terminator, that may be written into name. </param>
        /// <param name="length"> The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned. </param>
        /// <param name="size"> The address of a variable that will receive the size of the varying. </param>
        /// <param name="type"> The address of a variable that will receive the type of the varying. </param>
        /// <param name="name"> The address of a buffer into which will be written the name of the varying. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedbackVarying.xhtml" /></remarks>
        public static void GetTransformFeedbackVarying(ProgramHandle program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers._GetTransformFeedbackVarying_fnptr((int)program, index, bufSize, length, size, (uint*)type, name);
        
        /// <summary> <b>[requires: v3.0]</b> Specify whether data read via glReadPixels should be clamped. </summary>
        /// <param name="target"> Target for color clamping. target must be GL_CLAMP_READ_COLOR. </param>
        /// <param name="clamp"> Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClampColor.xhtml" /></remarks>
        public static void ClampColor(ClampColorTargetARB target, ClampColorModeARB clamp) => GLPointers._ClampColor_fnptr((uint)target, (uint)clamp);
        
        /// <summary> <b>[requires: v3.0]</b> Start conditional rendering. </summary>
        /// <param name="id"> Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded. </param>
        /// <param name="mode"> Specifies how glBeginConditionalRender interprets the results of the occlusion query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml" /></remarks>
        public static void BeginConditionalRender(uint id, ConditionalRenderMode mode) => GLPointers._BeginConditionalRender_fnptr(id, (uint)mode);
        
        /// <summary> <b>[requires: v3.0]</b> Start conditional rendering. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml" /></remarks>
        public static void EndConditionalRender() => GLPointers._EndConditionalRender_fnptr();
        
        /// <summary> <b>[requires: v3.0]</b> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribIPointer(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers._VertexAttribIPointer_fnptr(index, size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v3.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribIiv(uint index, VertexAttribEnum pname, int* parameters) => GLPointers._GetVertexAttribIiv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribIuiv(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers._GetVertexAttribIuiv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1i(uint index, int x) => GLPointers._VertexAttribI1i_fnptr(index, x);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2i(uint index, int x, int y) => GLPointers._VertexAttribI2i_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3i(uint index, int x, int y, int z) => GLPointers._VertexAttribI3i_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4i(uint index, int x, int y, int z, int w) => GLPointers._VertexAttribI4i_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1ui(uint index, uint x) => GLPointers._VertexAttribI1ui_fnptr(index, x);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2ui(uint index, uint x, uint y) => GLPointers._VertexAttribI2ui_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3ui(uint index, uint x, uint y, uint z) => GLPointers._VertexAttribI3ui_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w) => GLPointers._VertexAttribI4ui_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1iv(uint index, int* v) => GLPointers._VertexAttribI1iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2iv(uint index, int* v) => GLPointers._VertexAttribI2iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3iv(uint index, int* v) => GLPointers._VertexAttribI3iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4iv(uint index, int* v) => GLPointers._VertexAttribI4iv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI1uiv(uint index, uint* v) => GLPointers._VertexAttribI1uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI2uiv(uint index, uint* v) => GLPointers._VertexAttribI2uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI3uiv(uint index, uint* v) => GLPointers._VertexAttribI3uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4uiv(uint index, uint* v) => GLPointers._VertexAttribI4uiv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4bv(uint index, sbyte* v) => GLPointers._VertexAttribI4bv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4sv(uint index, short* v) => GLPointers._VertexAttribI4sv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4ubv(uint index, byte* v) => GLPointers._VertexAttribI4ubv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribI4usv(uint index, ushort* v) => GLPointers._VertexAttribI4usv_fnptr(index, v);
        
        /// <summary> <b>[requires: v3.0]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformuiv(ProgramHandle program, int location, uint* parameters) => GLPointers._GetUniformuiv_fnptr((int)program, location, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> Bind a user-defined varying out variable to a fragment shader color number. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocation.xhtml" /></remarks>
        public static void BindFragDataLocation(ProgramHandle program, uint color, byte* name) => GLPointers._BindFragDataLocation_fnptr((int)program, color, name);
        
        /// <summary> <b>[requires: v3.0]</b> Query the bindings of color numbers to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataLocation.xhtml" /></remarks>
        public static int GetFragDataLocation(ProgramHandle program, byte* name) => GLPointers._GetFragDataLocation_fnptr((int)program, name);
        
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1ui(int location, uint v0) => GLPointers._Uniform1ui_fnptr(location, v0);
        
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2ui(int location, uint v0, uint v1) => GLPointers._Uniform2ui_fnptr(location, v0, v1);
        
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3ui(int location, uint v0, uint v1, uint v2) => GLPointers._Uniform3ui_fnptr(location, v0, v1, v2);
        
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._Uniform4ui_fnptr(location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform1uiv(int location, int count, uint* value) => GLPointers._Uniform1uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform2uiv(int location, int count, uint* value) => GLPointers._Uniform2uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform3uiv(int location, int count, uint* value) => GLPointers._Uniform3uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> Specify the value of a uniform variable for the current program object. </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml" /></remarks>
        public static void Uniform4uiv(int location, int count, uint* value) => GLPointers._Uniform4uiv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v3.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterIiv(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._TexParameterIiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> Set texture parameters. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glTexParameter functions. Must be one of GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or GL_TEXTURE_RECTANGLE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TexParameterIuiv(TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._TexParameterIuiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterIiv(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._GetTexParameterIiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> Return texture parameter values. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTexParameterIuiv(TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._GetTexParameterIuiv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferiv(Buffer buffer, int drawbuffer, int* value) => GLPointers._ClearBufferiv_fnptr((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v3.0]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferuiv(Buffer buffer, int drawbuffer, uint* value) => GLPointers._ClearBufferuiv_fnptr((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v3.0]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferfv(Buffer buffer, int drawbuffer, float* value) => GLPointers._ClearBufferfv_fnptr((uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v3.0]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearBufferfi(Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers._ClearBufferfi_fnptr((uint)buffer, drawbuffer, depth, stencil);
        
        /// <summary> <b>[requires: v3.0]</b> Return a string describing the current GL connection. </summary>
        /// <param name="name"> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token. </param>
        /// <param name="index"> For glGetStringi, specifies the index of the string to return. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml" /></remarks>
        public static byte* GetStringi_(StringName name, uint index) => GLPointers._GetStringi_fnptr((uint)name, index);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Determine if a name corresponds to a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml" /></remarks>
        public static bool IsRenderbuffer(RenderbufferHandle renderbuffer) => GLPointers._IsRenderbuffer_fnptr((int)renderbuffer) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Bind a renderbuffer to a renderbuffer target. </summary>
        /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml" /></remarks>
        public static void BindRenderbuffer(RenderbufferTarget target, RenderbufferHandle renderbuffer) => GLPointers._BindRenderbuffer_fnptr((uint)target, (int)renderbuffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Delete renderbuffer objects. </summary>
        /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
        /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml" /></remarks>
        public static void DeleteRenderbuffers(int n, RenderbufferHandle* renderbuffers) => GLPointers._DeleteRenderbuffers_fnptr(n, (int*)renderbuffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate renderbuffer object names. </summary>
        /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
        /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml" /></remarks>
        public static void GenRenderbuffers(int n, RenderbufferHandle* renderbuffers) => GLPointers._GenRenderbuffers_fnptr(n, (int*)renderbuffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Establish data storage, format and dimensions of a    renderbuffer object's image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
        public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers._RenderbufferStorage_fnptr((uint)target, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
        public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers._GetRenderbufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Determine if a name corresponds to a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml" /></remarks>
        public static bool IsFramebuffer(FramebufferHandle framebuffer) => GLPointers._IsFramebuffer_fnptr((int)framebuffer) != 0;
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Bind a framebuffer to a framebuffer target. </summary>
        /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml" /></remarks>
        public static void BindFramebuffer(FramebufferTarget target, FramebufferHandle framebuffer) => GLPointers._BindFramebuffer_fnptr((uint)target, (int)framebuffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Delete framebuffer objects. </summary>
        /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
        /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml" /></remarks>
        public static void DeleteFramebuffers(int n, FramebufferHandle* framebuffers) => GLPointers._DeleteFramebuffers_fnptr(n, (int*)framebuffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate framebuffer object names. </summary>
        /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
        /// <param name="ids"> Specifies an array in which the generated framebuffer object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml" /></remarks>
        public static void GenFramebuffers(int n, FramebufferHandle* framebuffers) => GLPointers._GenFramebuffers_fnptr(n, (int*)framebuffers);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Check the completeness status of a framebuffer. </summary>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
        public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => (FramebufferStatus) GLPointers._CheckFramebufferStatus_fnptr((uint)target);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => GLPointers._FramebufferTexture1D_fnptr((uint)target, (uint)attachment, (uint)textarget, (int)texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => GLPointers._FramebufferTexture2D_fnptr((uint)target, (uint)attachment, (uint)textarget, (int)texture, level);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset) => GLPointers._FramebufferTexture3D_fnptr((uint)target, (uint)attachment, (uint)textarget, (int)texture, level, zoffset);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
        public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => GLPointers._FramebufferRenderbuffer_fnptr((uint)target, (uint)attachment, (uint)renderbuffertarget, (int)renderbuffer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
        public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._GetFramebufferAttachmentParameteriv_fnptr((uint)target, (uint)attachment, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate mipmaps for a specified texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
        public static void GenerateMipmap(TextureTarget target) => GLPointers._GenerateMipmap_fnptr((uint)target);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
        public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._BlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object's image. </summary>
        /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
        public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers._RenderbufferStorageMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
        public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => GLPointers._FramebufferTextureLayer_fnptr((uint)target, (uint)attachment, (int)texture, level, layer);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> Map all or part of a buffer object's data store into the client's address space. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
        public static void* MapBufferRange(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._MapBufferRange_fnptr((uint)target, offset, length, (uint)access);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
        public static void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, nint length) => GLPointers._FlushMappedBufferRange_fnptr((uint)target, offset, length);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Bind a vertex array object. </summary>
        /// <param name="array"> Specifies the name of the vertex array to bind. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" /></remarks>
        public static void BindVertexArray(VertexArrayHandle array) => GLPointers._BindVertexArray_fnptr((int)array);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Delete vertex array objects. </summary>
        /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
        /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml" /></remarks>
        public static void DeleteVertexArrays(int n, VertexArrayHandle* arrays) => GLPointers._DeleteVertexArrays_fnptr(n, (int*)arrays);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Generate vertex array object names. </summary>
        /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
        /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" /></remarks>
        public static void GenVertexArrays(int n, VertexArrayHandle* arrays) => GLPointers._GenVertexArrays_fnptr(n, (int*)arrays);
        
        /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Determine if a name corresponds to a vertex array object. </summary>
        /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml" /></remarks>
        public static bool IsVertexArray(VertexArrayHandle array) => GLPointers._IsVertexArray_fnptr((int)array) != 0;
        
        /// <summary> <b>[requires: v3.1]</b> Draw multiple instances of a range of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstanced.xhtml" /></remarks>
        public static void DrawArraysInstanced(PrimitiveType mode, int first, int count, int instancecount) => GLPointers._DrawArraysInstanced_fnptr((uint)mode, first, count, instancecount);
        
        /// <summary> <b>[requires: v3.1]</b> Draw multiple instances of a set of elements. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstanced.xhtml" /></remarks>
        public static void DrawElementsInstanced(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount) => GLPointers._DrawElementsInstanced_fnptr((uint)mode, count, (uint)type, indices, instancecount);
        
        /// <summary> <b>[requires: v3.1]</b> Attach a buffer object's data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
        public static void TexBuffer(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer) => GLPointers._TexBuffer_fnptr((uint)target, (uint)internalformat, (int)buffer);
        
        /// <summary> <b>[requires: v3.1]</b> Specify the primitive restart index. </summary>
        /// <param name="index"> Specifies the value to be interpreted as the primitive restart index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPrimitiveRestartIndex.xhtml" /></remarks>
        public static void PrimitiveRestartIndex(uint index) => GLPointers._PrimitiveRestartIndex_fnptr(index);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
        /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
        public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._CopyBufferSubData_fnptr((uint)readTarget, (uint)writeTarget, readOffset, writeOffset, size);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
        /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
        /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
        /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml" /></remarks>
        public static void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, uint* uniformIndices) => GLPointers._GetUniformIndices_fnptr((int)program, uniformCount, uniformNames, uniformIndices);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Returns information about several active uniform variables for the specified program object. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
        /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
        /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
        /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml" /></remarks>
        public static void GetActiveUniformsiv(ProgramHandle program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => GLPointers._GetActiveUniformsiv_fnptr((int)program, uniformCount, uniformIndices, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Query the name of an active uniform. </summary>
        /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
        /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
        /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
        /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
        /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml" /></remarks>
        public static void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => GLPointers._GetActiveUniformName_fnptr((int)program, uniformIndex, bufSize, length, uniformName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the index of a named uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml" /></remarks>
        public static uint GetUniformBlockIndex(ProgramHandle program, byte* uniformBlockName) => GLPointers._GetUniformBlockIndex_fnptr((int)program, uniformBlockName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Query information about an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="pname"> Specifies the name of the parameter to query. </param>
        /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml" /></remarks>
        public static void GetActiveUniformBlockiv(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => GLPointers._GetActiveUniformBlockiv_fnptr((int)program, uniformBlockIndex, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the name of an active uniform block. </summary>
        /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
        /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
        /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
        /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml" /></remarks>
        public static void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => GLPointers._GetActiveUniformBlockName_fnptr((int)program, uniformBlockIndex, bufSize, length, uniformBlockName);
        
        /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Assign a binding point to an active uniform block. </summary>
        /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
        /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
        /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml" /></remarks>
        public static void UniformBlockBinding(ProgramHandle program, uint uniformBlockIndex, uint uniformBlockBinding) => GLPointers._UniformBlockBinding_fnptr((int)program, uniformBlockIndex, uniformBlockBinding);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml" /></remarks>
        public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._DrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, basevertex);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="start"> Specifies the minimum array index contained in indices. </param>
        /// <param name="end"> Specifies the maximum array index contained in indices. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml" /></remarks>
        public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._DrawRangeElementsBaseVertex_fnptr((uint)mode, start, end, count, (uint)type, indices, basevertex);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => GLPointers._DrawElementsInstancedBaseVertex_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Points to an array of the elements counts. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
        /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml" /></remarks>
        public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => GLPointers._MultiDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, drawcount, basevertex);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex]</b> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
        /// <param name="provokeMode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml" /></remarks>
        public static void ProvokingVertex(VertexProvokingMode mode) => GLPointers._ProvokingVertex_fnptr((uint)mode);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Create a new sync object and insert it into the GL command stream. </summary>
        /// <param name="condition"> Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
        /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml" /></remarks>
        public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) GLPointers._FenceSync_fnptr((uint)condition, (uint)flags);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Determine if a name corresponds to a sync object. </summary>
        /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml" /></remarks>
        public static bool IsSync(GLSync sync) => GLPointers._IsSync_fnptr((IntPtr)sync) != 0;
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Delete a sync object. </summary>
        /// <param name="sync"> The sync object to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml" /></remarks>
        public static void DeleteSync(GLSync sync) => GLPointers._DeleteSync_fnptr((IntPtr)sync);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Block and wait for a sync object to become signaled. </summary>
        /// <param name="sync"> The sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
        /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml" /></remarks>
        public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => (SyncStatus) GLPointers._ClientWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
        /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
        /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
        /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml" /></remarks>
        public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => GLPointers._WaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetInteger64v(GetPName pname, long* data) => GLPointers._GetInteger64v_fnptr((uint)pname, data);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Query the properties of a sync object. </summary>
        /// <param name="sync"> Specifies the sync object whose properties to query. </param>
        /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in values. </param>
        /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
        /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml" /></remarks>
        public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => GLPointers._GetSynciv_fnptr((IntPtr)sync, (uint)pname, count, length, values);
        
        /// <summary> <b>[requires: v3.2]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetInteger64i_v(GetPName target, uint index, long* data) => GLPointers._GetInteger64i_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v3.2]</b> Return parameters of a buffer object. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table: </param>
        /// <param name="value"> Specifies the name of the buffer object parameter to query. </param>
        /// <param name="data"> Returns the requested parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetBufferParameteri64v(BufferTargetARB target, BufferPNameARB pname, long* parameters) => GLPointers._GetBufferParameteri64v_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.2]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void FramebufferTexture(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level) => GLPointers._FramebufferTexture_fnptr((uint)target, (uint)attachment, (int)texture, level);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture's image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> The number of samples in the multisample texture's image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture's image, in texels. </param>
        /// <param name="height"> The height of the multisample texture's image, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml" /></remarks>
        public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._TexImage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture's image. </summary>
        /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> The number of samples in the multisample texture's image. </param>
        /// <param name="internalformat"> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
        /// <param name="width"> The width of the multisample texture's image, in texels. </param>
        /// <param name="height"> The height of the multisample texture's image, in texels. </param>
        /// <param name="depth">!!missing documentation!!</param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml" /></remarks>
        public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._TexImage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Retrieve the location of a sample. </summary>
        /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
        /// <param name="index"> Specifies the index of the sample whose position to query. </param>
        /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml" /></remarks>
        public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers._GetMultisamplefv_fnptr((uint)pname, index, val);
        
        /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Set the value of a sub-word of the sample mask. </summary>
        /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
        /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml" /></remarks>
        public static void SampleMaski(uint maskNumber, All mask) => GLPointers._SampleMaski_fnptr(maskNumber, (uint)mask);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
        /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
        /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
        /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml" /></remarks>
        public static void BindFragDataLocationIndexed(ProgramHandle program, uint colorNumber, uint index, byte* name) => GLPointers._BindFragDataLocationIndexed_fnptr((int)program, colorNumber, index, name);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> Query the bindings of color indices to user-defined varying out variables. </summary>
        /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
        /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml" /></remarks>
        public static int GetFragDataIndex(ProgramHandle program, byte* name) => GLPointers._GetFragDataIndex_fnptr((int)program, name);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Generate sampler object names. </summary>
        /// <param name="n"> Specifies the number of sampler object names to generate. </param>
        /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml" /></remarks>
        public static void GenSamplers(int count, SamplerHandle* samplers) => GLPointers._GenSamplers_fnptr(count, (int*)samplers);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Delete named sampler objects. </summary>
        /// <param name="n"> Specifies the number of sampler objects to be deleted. </param>
        /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml" /></remarks>
        public static void DeleteSamplers(int count, SamplerHandle* samplers) => GLPointers._DeleteSamplers_fnptr(count, (int*)samplers);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Determine if a name corresponds to a sampler object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a sampler object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml" /></remarks>
        public static bool IsSampler(SamplerHandle sampler) => GLPointers._IsSampler_fnptr((int)sampler) != 0;
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Bind a named sampler to a texturing target. </summary>
        /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
        /// <param name="sampler"> Specifies the name of a sampler. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml" /></remarks>
        public static void BindSampler(uint unit, SamplerHandle sampler) => GLPointers._BindSampler_fnptr(unit, (int)sampler);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, int param) => GLPointers._SamplerParameteri_fnptr((int)sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameteriv(SamplerHandle sampler, SamplerParameterI pname, int* param) => GLPointers._SamplerParameteriv_fnptr((int)sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, float param) => GLPointers._SamplerParameterf_fnptr((int)sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterfv(SamplerHandle sampler, SamplerParameterF pname, float* param) => GLPointers._SamplerParameterfv_fnptr((int)sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterIiv(SamplerHandle sampler, SamplerParameterI pname, int* param) => GLPointers._SamplerParameterIiv_fnptr((int)sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
        /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
        /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
        public static void SamplerParameterIuiv(SamplerHandle sampler, SamplerParameterI pname, uint* param) => GLPointers._SamplerParameterIuiv_fnptr((int)sampler, (uint)pname, param);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameteriv(SamplerHandle sampler, SamplerParameterI pname, int* parameters) => GLPointers._GetSamplerParameteriv_fnptr((int)sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterIiv(SamplerHandle sampler, SamplerParameterI pname, int* parameters) => GLPointers._GetSamplerParameterIiv_fnptr((int)sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterfv(SamplerHandle sampler, SamplerParameterF pname, float* parameters) => GLPointers._GetSamplerParameterfv_fnptr((int)sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
        /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
        /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
        /// <param name="parameters"> Returns the sampler parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
        public static void GetSamplerParameterIuiv(SamplerHandle sampler, SamplerParameterI pname, uint* parameters) => GLPointers._GetSamplerParameterIuiv_fnptr((int)sampler, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
        /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
        /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml" /></remarks>
        public static void QueryCounter(QueryHandle id, QueryCounterTarget target) => GLPointers._QueryCounter_fnptr((int)id, (uint)target);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjecti64v(QueryHandle id, QueryObjectParameterName pname, long* parameters) => GLPointers._GetQueryObjecti64v_fnptr((int)id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryObjectui64v(QueryHandle id, QueryObjectParameterName pname, ulong* parameters) => GLPointers._GetQueryObjectui64v_fnptr((int)id, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v3.3]</b> Modify the rate at which generic vertex attributes advance during instanced rendering. </summary>
        /// <param name="index"> Specify the index of the generic vertex attribute. </param>
        /// <param name="divisor"> Specify the number of instances that will pass between updates of the generic attribute at slot index. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribDivisor.xhtml" /></remarks>
        public static void VertexAttribDivisor(uint index, uint divisor) => GLPointers._VertexAttribDivisor_fnptr(index, divisor);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._VertexAttribP1ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._VertexAttribP1uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._VertexAttribP2ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._VertexAttribP2uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._VertexAttribP3ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._VertexAttribP3uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
        /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
        /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._VertexAttribP4ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._VertexAttribP4uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0]</b> Specifies minimum rate at which sample shading takes place. </summary>
        /// <param name="value"> Specifies the rate at which samples are shaded within each covered pixel. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMinSampleShading.xhtml" /></remarks>
        public static void MinSampleShading(float value) => GLPointers._MinSampleShading_fnptr(value);
        
        /// <summary> <b>[requires: v4.0]</b> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
        /// <param name="buf"> for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation. </param>
        /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
        public static void BlendEquationi(uint buf, BlendEquationModeEXT mode) => GLPointers._BlendEquationi_fnptr(buf, (uint)mode);
        
        /// <summary> <b>[requires: v4.0]</b> Set the RGB blend equation and the alpha blend equation separately. </summary>
        /// <param name="buf"> for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations. </param>
        /// <param name="modeRGB"> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <param name="modeAlpha"> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml" /></remarks>
        public static void BlendEquationSeparatei(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._BlendEquationSeparatei_fnptr(buf, (uint)modeRGB, (uint)modeAlpha);
        
        /// <summary> <b>[requires: v4.0]</b> Specify pixel arithmetic. </summary>
        /// <param name="buf"> For glBlendFunci, specifies the index of the draw buffer for which to set the blend function. </param>
        /// <param name="sfactor"> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dfactor"> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" /></remarks>
        public static void BlendFunci(uint buf, BlendingFactor src, BlendingFactor dst) => GLPointers._BlendFunci_fnptr(buf, (uint)src, (uint)dst);
        
        /// <summary> <b>[requires: v4.0]</b> Specify pixel arithmetic for RGB and alpha components separately. </summary>
        /// <param name="buf"> For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions. </param>
        /// <param name="srcRGB"> Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE. </param>
        /// <param name="dstRGB"> Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO. </param>
        /// <param name="srcAlpha"> Specified how the alpha source blending factor is computed. The initial value is GL_ONE. </param>
        /// <param name="dstAlpha"> Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml" /></remarks>
        public static void BlendFuncSeparatei(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers._BlendFuncSeparatei_fnptr(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> Render primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml" /></remarks>
        public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => GLPointers._DrawArraysIndirect_fnptr((uint)mode, indirect);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml" /></remarks>
        public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => GLPointers._DrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform1d(int location, double x) => GLPointers._Uniform1d_fnptr(location, x);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform2d(int location, double x, double y) => GLPointers._Uniform2d_fnptr(location, x, y);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform3d(int location, double x, double y, double z) => GLPointers._Uniform3d_fnptr(location, x, y, z);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform4d(int location, double x, double y, double z, double w) => GLPointers._Uniform4d_fnptr(location, x, y, z, w);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform1dv(int location, int count, double* value) => GLPointers._Uniform1dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform2dv(int location, int count, double* value) => GLPointers._Uniform2dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform3dv(int location, int count, double* value) => GLPointers._Uniform3dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void Uniform4dv(int location, int count, double* value) => GLPointers._Uniform4dv_fnptr(location, count, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix2dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix3dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix4dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix2x3dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix2x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix2x4dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix2x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix3x2dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix3x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix3x4dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix3x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix4x2dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix4x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void UniformMatrix4x3dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix4x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetUniformdv(ProgramHandle program, int location, double* parameters) => GLPointers._GetUniformdv_fnptr((int)program, location, parameters);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml" /></remarks>
        public static int GetSubroutineUniformLocation(ProgramHandle program, ShaderType shadertype, byte* name) => GLPointers._GetSubroutineUniformLocation_fnptr((int)program, (uint)shadertype, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml" /></remarks>
        public static uint GetSubroutineIndex(ProgramHandle program, ShaderType shadertype, byte* name) => GLPointers._GetSubroutineIndex_fnptr((int)program, (uint)shadertype, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query a property of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
        /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml" /></remarks>
        public static void GetActiveSubroutineUniformiv(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => GLPointers._GetActiveSubroutineUniformiv_fnptr((int)program, (uint)shadertype, index, (uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query the name of an active shader subroutine uniform. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
        /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml" /></remarks>
        public static void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._GetActiveSubroutineUniformName_fnptr((int)program, (uint)shadertype, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query the name of an active shader subroutine. </summary>
        /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
        /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
        /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
        /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml" /></remarks>
        public static void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._GetActiveSubroutineName_fnptr((int)program, (uint)shadertype, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Load active subroutine uniforms. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
        /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml" /></remarks>
        public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => GLPointers._UniformSubroutinesuiv_fnptr((uint)shadertype, count, indices);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
        /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="location"> Specifies the location of the subroutine uniform. </param>
        /// <param name="values"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml" /></remarks>
        public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => GLPointers._GetUniformSubroutineuiv_fnptr((uint)shadertype, location, parameters);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
        /// <param name="program"> Specifies the name of the program containing shader stage. </param>
        /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
        /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml" /></remarks>
        public static void GetProgramStageiv(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int* values) => GLPointers._GetProgramStageiv_fnptr((int)program, (uint)shadertype, (uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
        public static void PatchParameteri(PatchParameterName pname, int value) => GLPointers._PatchParameteri_fnptr((uint)pname, value);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> Specifies the parameters for patch primitives. </summary>
        /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
        /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
        public static void PatchParameterfv(PatchParameterName pname, float* values) => GLPointers._PatchParameterfv_fnptr((uint)pname, values);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Bind a transform feedback object. </summary>
        /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
        /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml" /></remarks>
        public static void BindTransformFeedback(BindTransformFeedbackTarget target, TransformFeedbackHandle id) => GLPointers._BindTransformFeedback_fnptr((uint)target, (int)id);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Delete transform feedback objects. </summary>
        /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
        /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml" /></remarks>
        public static void DeleteTransformFeedbacks(int n, TransformFeedbackHandle* ids) => GLPointers._DeleteTransformFeedbacks_fnptr(n, (int*)ids);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Reserve transform feedback object names. </summary>
        /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
        /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml" /></remarks>
        public static void GenTransformFeedbacks(int n, TransformFeedbackHandle* ids) => GLPointers._GenTransformFeedbacks_fnptr(n, (int*)ids);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Determine if a name corresponds to a transform feedback object. </summary>
        /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml" /></remarks>
        public static bool IsTransformFeedback(TransformFeedbackHandle id) => GLPointers._IsTransformFeedback_fnptr((int)id) != 0;
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Pause transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml" /></remarks>
        public static void PauseTransformFeedback() => GLPointers._PauseTransformFeedback_fnptr();
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Resume transform feedback operations. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml" /></remarks>
        public static void ResumeTransformFeedback() => GLPointers._ResumeTransformFeedback_fnptr();
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Render primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml" /></remarks>
        public static void DrawTransformFeedback(PrimitiveType mode, TransformFeedbackHandle id) => GLPointers._DrawTransformFeedback_fnptr((uint)mode, (int)id);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml" /></remarks>
        public static void DrawTransformFeedbackStream(PrimitiveType mode, TransformFeedbackHandle id, uint stream) => GLPointers._DrawTransformFeedbackStream_fnptr((uint)mode, (int)id, stream);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
        public static void BeginQueryIndexed(QueryTarget target, uint index, QueryHandle id) => GLPointers._BeginQueryIndexed_fnptr((uint)target, index, (int)id);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Delimit the boundaries of a query object on an indexed target. </summary>
        /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
        /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
        public static void EndQueryIndexed(QueryTarget target, uint index) => GLPointers._EndQueryIndexed_fnptr((uint)target, index);
        
        /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Return parameters of an indexed query object target. </summary>
        /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
        /// <param name="index"> Specifies the index of the query object target. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
        /// <param name="parameters"> Returns the requested data. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml" /></remarks>
        public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => GLPointers._GetQueryIndexediv_fnptr((uint)target, index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Release resources consumed by the implementation's shader compiler. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml" /></remarks>
        public static void ReleaseShaderCompiler() => GLPointers._ReleaseShaderCompiler_fnptr();
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Load pre-compiled shader binaries. </summary>
        /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
        /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
        /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
        /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
        /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml" /></remarks>
        public static void ShaderBinary(int count, ShaderHandle* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => GLPointers._ShaderBinary_fnptr(count, (int*)shaders, (uint)binaryFormat, binary, length);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
        /// <param name="shaderType"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
        /// <param name="precisionType"> Specifies the numeric format whose precision and range to query. </param>
        /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned. </param>
        /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml" /></remarks>
        public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => GLPointers._GetShaderPrecisionFormat_fnptr((uint)shadertype, (uint)precisiontype, range, precision);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
        public static void DepthRangef(float n, float f) => GLPointers._DepthRangef_fnptr(n, f);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Specify the clear value for the depth buffer. </summary>
        /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
        public static void ClearDepthf(float d) => GLPointers._ClearDepthf_fnptr(d);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> Return a binary representation of a program object's compiled and linked executable source. </summary>
        /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
        /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
        /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
        /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
        /// <param name="binary"> Specifies the address an array into which the GL will return program's binary representation. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml" /></remarks>
        public static void GetProgramBinary(ProgramHandle program, int bufSize, int* length, All* binaryFormat, void* binary) => GLPointers._GetProgramBinary_fnptr((int)program, bufSize, length, (uint*)binaryFormat, binary);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> Load a program object with a program binary. </summary>
        /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
        /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
        /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
        /// <param name="length"> Specifies the number of bytes contained in binary. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml" /></remarks>
        public static void ProgramBinary(ProgramHandle program, All binaryFormat, void* binary, int length) => GLPointers._ProgramBinary_fnptr((int)program, (uint)binaryFormat, binary, length);
        
        /// <summary> <b>[requires: v4.1 | v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects]</b> Specify a parameter for a program object. </summary>
        /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
        /// <param name="pname"> Specifies the name of the parameter to modify. </param>
        /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml" /></remarks>
        public static void ProgramParameteri(ProgramHandle program, ProgramParameterPName pname, int value) => GLPointers._ProgramParameteri_fnptr((int)program, (uint)pname, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Bind stages of a program object to a program pipeline. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
        /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
        /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml" /></remarks>
        public static void UseProgramStages(ProgramPipelineHandle pipeline, UseProgramStageMask stages, ProgramHandle program) => GLPointers._UseProgramStages_fnptr((int)pipeline, (uint)stages, (int)program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Set the active program object for a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
        /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml" /></remarks>
        public static void ActiveShaderProgram(ProgramPipelineHandle pipeline, ProgramHandle program) => GLPointers._ActiveShaderProgram_fnptr((int)pipeline, (int)program);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Create a stand-alone program from an array of null-terminated source code strings. </summary>
        /// <param name="type"> Specifies the type of shader to create. </param>
        /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
        /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml" /></remarks>
        public static ProgramHandle CreateShaderProgramv(ShaderType type, int count, byte** strings) => (ProgramHandle) GLPointers._CreateShaderProgramv_fnptr((uint)type, count, strings);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Bind a program pipeline to the current context. </summary>
        /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml" /></remarks>
        public static void BindProgramPipeline(ProgramPipelineHandle pipeline) => GLPointers._BindProgramPipeline_fnptr((int)pipeline);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Delete program pipeline objects. </summary>
        /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
        /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml" /></remarks>
        public static void DeleteProgramPipelines(int n, ProgramPipelineHandle* pipelines) => GLPointers._DeleteProgramPipelines_fnptr(n, (int*)pipelines);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Reserve program pipeline object names. </summary>
        /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
        /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml" /></remarks>
        public static void GenProgramPipelines(int n, ProgramPipelineHandle* pipelines) => GLPointers._GenProgramPipelines_fnptr(n, (int*)pipelines);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Determine if a name corresponds to a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml" /></remarks>
        public static bool IsProgramPipeline(ProgramPipelineHandle pipeline) => GLPointers._IsProgramPipeline_fnptr((int)pipeline) != 0;
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Retrieve properties of a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
        /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml" /></remarks>
        public static void GetProgramPipelineiv(ProgramPipelineHandle pipeline, PipelineParameterName pname, int* parameters) => GLPointers._GetProgramPipelineiv_fnptr((int)pipeline, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1i(ProgramHandle program, int location, int v0) => GLPointers._ProgramUniform1i_fnptr((int)program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1iv(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform1iv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1f(ProgramHandle program, int location, float v0) => GLPointers._ProgramUniform1f_fnptr((int)program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1fv(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform1fv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform1d(ProgramHandle program, int location, double v0) => GLPointers._ProgramUniform1d_fnptr((int)program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform1dv(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform1dv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1ui(ProgramHandle program, int location, uint v0) => GLPointers._ProgramUniform1ui_fnptr((int)program, location, v0);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform1uiv(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform1uiv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2i(ProgramHandle program, int location, int v0, int v1) => GLPointers._ProgramUniform2i_fnptr((int)program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2iv(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform2iv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2f(ProgramHandle program, int location, float v0, float v1) => GLPointers._ProgramUniform2f_fnptr((int)program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2fv(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform2fv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform2d(ProgramHandle program, int location, double v0, double v1) => GLPointers._ProgramUniform2d_fnptr((int)program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform2dv(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform2dv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2ui(ProgramHandle program, int location, uint v0, uint v1) => GLPointers._ProgramUniform2ui_fnptr((int)program, location, v0, v1);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform2uiv(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform2uiv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3i(ProgramHandle program, int location, int v0, int v1, int v2) => GLPointers._ProgramUniform3i_fnptr((int)program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3iv(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform3iv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3f(ProgramHandle program, int location, float v0, float v1, float v2) => GLPointers._ProgramUniform3f_fnptr((int)program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3fv(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform3fv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform3d(ProgramHandle program, int location, double v0, double v1, double v2) => GLPointers._ProgramUniform3d_fnptr((int)program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform3dv(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform3dv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3ui(ProgramHandle program, int location, uint v0, uint v1, uint v2) => GLPointers._ProgramUniform3ui_fnptr((int)program, location, v0, v1, v2);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform3uiv(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform3uiv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4i(ProgramHandle program, int location, int v0, int v1, int v2, int v3) => GLPointers._ProgramUniform4i_fnptr((int)program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4iv(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform4iv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4f(ProgramHandle program, int location, float v0, float v1, float v2, float v3) => GLPointers._ProgramUniform4f_fnptr((int)program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4fv(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform4fv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform4d(ProgramHandle program, int location, double v0, double v1, double v2, double v3) => GLPointers._ProgramUniform4d_fnptr((int)program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniform4dv(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform4dv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4ui(ProgramHandle program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._ProgramUniform4ui_fnptr((int)program, location, v0, v1, v2, v3);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniform4uiv(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform4uiv_fnptr((int)program, location, count, value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix2fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix3fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix4fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix2dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix2dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix3dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix3dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix4dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix4dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2x3fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix2x3fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3x2fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix3x2fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix2x4fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix2x4fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4x2fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix4x2fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix3x4fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix3x4fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
        /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
        /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
        public static void ProgramUniformMatrix4x3fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix4x3fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix2x3dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix2x3dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix3x2dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix3x2dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix2x4dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix2x4dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix4x2dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix4x2dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix3x4dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix3x4dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void ProgramUniformMatrix4x3dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix4x3dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Validate a program pipeline object against current GL state. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml" /></remarks>
        public static void ValidateProgramPipeline(ProgramPipelineHandle pipeline) => GLPointers._ValidateProgramPipeline_fnptr((int)pipeline);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Retrieve the info log string from a program pipeline object. </summary>
        /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
        /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
        /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
        /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml" /></remarks>
        public static void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, int* length, byte* infoLog) => GLPointers._GetProgramPipelineInfoLog_fnptr((int)pipeline, bufSize, length, infoLog);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL1d(uint index, double x) => GLPointers._VertexAttribL1d_fnptr(index, x);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL2d(uint index, double x, double y) => GLPointers._VertexAttribL2d_fnptr(index, x, y);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL3d(uint index, double x, double y, double z) => GLPointers._VertexAttribL3d_fnptr(index, x, y, z);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => GLPointers._VertexAttribL4d_fnptr(index, x, y, z, w);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL1dv(uint index, double* v) => GLPointers._VertexAttribL1dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL2dv(uint index, double* v) => GLPointers._VertexAttribL2dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL3dv(uint index, double* v) => GLPointers._VertexAttribL3dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
        public static void VertexAttribL4dv(uint index, double* v) => GLPointers._VertexAttribL4dv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Define an array of generic vertex attribute data. </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
        public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers._VertexAttribLPointer_fnptr(index, size, (uint)type, stride, pointer);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Return a generic vertex attribute parameter. </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
        public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => GLPointers._GetVertexAttribLdv_fnptr(index, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set multiple viewports. </summary>
        /// <param name="first"> Specify the first viewport to set. </param>
        /// <param name="count"> Specify the number of viewports to set. </param>
        /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml" /></remarks>
        public static void ViewportArrayv(uint first, int count, float* v) => GLPointers._ViewportArrayv_fnptr(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
        /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
        public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => GLPointers._ViewportIndexedf_fnptr(index, x, y, w, h);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set a specified viewport. </summary>
        /// <param name="index"> Specify the first viewport to set. </param>
        /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
        public static void ViewportIndexedfv(uint index, float* v) => GLPointers._ViewportIndexedfv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for multiple viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
        /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
        /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml" /></remarks>
        public static void ScissorArrayv(uint first, int count, int* v) => GLPointers._ScissorArrayv_fnptr(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
        /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
        public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => GLPointers._ScissorIndexed_fnptr(index, left, bottom, width, height);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for a specific viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
        /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
        public static void ScissorIndexedv(uint index, int* v) => GLPointers._ScissorIndexedv_fnptr(index, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
        /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
        /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
        /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml" /></remarks>
        public static void DepthRangeArrayv(uint first, int count, double* v) => GLPointers._DepthRangeArrayv_fnptr(first, count, v);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
        /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
        /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
        /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml" /></remarks>
        public static void DepthRangeIndexed(uint index, double n, double f) => GLPointers._DepthRangeIndexed_fnptr(index, n, f);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetFloati_v(GetPName target, uint index, float* data) => GLPointers._GetFloati_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Return the value or values of a selected parameter. </summary>
        /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
        /// <param name="index"> Specifies the index of the particular element being queried. </param>
        /// <param name="data"> Returns the value or values of the specified parameter. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
        public static void GetDoublei_v(GetPName target, uint index, double* data) => GLPointers._GetDoublei_v_fnptr((uint)target, index, data);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
        /// <param name="count"> Specifies the number of indices to be rendered. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml" /></remarks>
        public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => GLPointers._DrawArraysInstancedBaseInstance_fnptr((uint)mode, first, count, instancecount, baseinstance);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, PrimitiveType type, void* indices, int instancecount, uint baseinstance) => GLPointers._DrawElementsInstancedBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, baseinstance);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
        /// <param name="count"> Specifies the number of elements to be rendered. </param>
        /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
        /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
        /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
        /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
        /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml" /></remarks>
        public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => GLPointers._DrawElementsInstancedBaseVertexBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex, baseinstance);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
        public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => GLPointers._GetInternalformativ_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters]</b> Retrieve information about the set of active atomic counter buffers for a program. </summary>
        /// <param name="program"> The name of a program object from which to retrieve information. </param>
        /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
        /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml" /></remarks>
        public static void GetActiveAtomicCounterBufferiv(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => GLPointers._GetActiveAtomicCounterBufferiv_fnptr((int)program, bufferIndex, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> Bind a level of a texture to an image unit. </summary>
        /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
        /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
        /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
        /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
        /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
        /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
        /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml" /></remarks>
        public static void BindImageTexture(uint unit, TextureHandle texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format) => GLPointers._BindImageTexture_fnptr(unit, (int)texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, (uint)format);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
        public static void MemoryBarrier(MemoryBarrierMask barriers) => GLPointers._MemoryBarrier_fnptr((uint)barriers);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
        public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._TexStorage1D_fnptr((uint)target, levels, (uint)internalformat, width);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
        public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._TexStorage2D_fnptr((uint)target, levels, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
        public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._TexStorage3D_fnptr((uint)target, levels, (uint)internalformat, width, height, depth);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml" /></remarks>
        public static void DrawTransformFeedbackInstanced(PrimitiveType mode, TransformFeedbackHandle id, int instancecount) => GLPointers._DrawTransformFeedbackInstanced_fnptr((uint)mode, (int)id, instancecount);
        
        /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
        /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
        /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml" /></remarks>
        public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, TransformFeedbackHandle id, uint stream, int instancecount) => GLPointers._DrawTransformFeedbackStreamInstanced_fnptr((uint)mode, (int)id, stream, instancecount);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> Fill a buffer object's data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
        public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._ClearBufferData_fnptr((uint)target, (uint)internalformat, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> Fill all or part of buffer object's data store with a fixed value. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object's data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
        public static void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._ClearBufferSubData_fnptr((uint)target, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> Launch one or more compute work groups. </summary>
        /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
        /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
        /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml" /></remarks>
        public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => GLPointers._DispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> Launch one or more compute work groups using parameters stored in a buffer. </summary>
        /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml" /></remarks>
        public static void DispatchComputeIndirect(IntPtr indirect) => GLPointers._DispatchComputeIndirect_fnptr(indirect);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image]</b> Perform a raw data copy between two images. </summary>
        /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
        /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
        /// <param name="srcLevel"> The mipmap level to read from the source. </param>
        /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
        /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
        /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
        /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
        /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
        /// <param name="dstLevel">!!missing documentation!!</param>
        /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
        /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
        /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
        /// <param name="srcWidth"> The width of the region to be copied. </param>
        /// <param name="srcHeight"> The height of the region to be copied. </param>
        /// <param name="srcDepth"> The depth of the region to be copied. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml" /></remarks>
        public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers._CopyImageSubData_fnptr(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> Set a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
        public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers._FramebufferParameteri_fnptr((uint)target, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> Query a named parameter of a framebuffer object. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
        public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._GetFramebufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
        /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
        /// <param name="pname"> Specifies the type of information to query. </param>
        /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
        /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
        public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => GLPointers._GetInternalformati64v_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate a region of a texture image. </summary>
        /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
        /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
        /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
        /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
        /// <param name="width"> The width of the region to be invalidated. </param>
        /// <param name="height"> The height of the region to be invalidated. </param>
        /// <param name="depth"> The depth of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml" /></remarks>
        public static void InvalidateTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => GLPointers._InvalidateTexSubImage_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the entirety a texture image. </summary>
        /// <param name="texture"> The name of a texture object to invalidate. </param>
        /// <param name="level"> The level of detail of the texture object to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml" /></remarks>
        public static void InvalidateTexImage(TextureHandle texture, int level) => GLPointers._InvalidateTexImage_fnptr((int)texture, level);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate a region of a buffer object's data store. </summary>
        /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
        /// <param name="offset"> The offset within the buffer's data store of the start of the range to be invalidated. </param>
        /// <param name="length"> The length of the range within the buffer's data store to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml" /></remarks>
        public static void InvalidateBufferSubData(BufferHandle buffer, IntPtr offset, nint length) => GLPointers._InvalidateBufferSubData_fnptr((int)buffer, offset, length);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of a buffer object's data store. </summary>
        /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml" /></remarks>
        public static void InvalidateBufferData(BufferHandle buffer) => GLPointers._InvalidateBufferData_fnptr((int)buffer);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of some or all of a framebuffer's attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
        public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => GLPointers._InvalidateFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of a region of some or all of a framebuffer's attachments. </summary>
        /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
        public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._InvalidateSubFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments, x, y, width, height);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml" /></remarks>
        public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => GLPointers._MultiDrawArraysIndirect_fnptr((uint)mode, indirect, drawcount, stride);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
        /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
        /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
        /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
        /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
        /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml" /></remarks>
        public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => GLPointers._MultiDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect, drawcount, stride);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query a property of an interface in a program. </summary>
        /// <param name="program"> The name of a program object whose interface to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program to query. </param>
        /// <param name="pname"> The name of the parameter within programInterface to query. </param>
        /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml" /></remarks>
        public static void GetProgramInterfaceiv(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => GLPointers._GetProgramInterfaceiv_fnptr((int)program, (uint)programInterface, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the index of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the index of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml" /></remarks>
        public static uint GetProgramResourceIndex(ProgramHandle program, ProgramInterface programInterface, byte* name) => GLPointers._GetProgramResourceIndex_fnptr((int)program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the name of an indexed resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
        /// <param name="index"> The index of the resource within programInterface of program. </param>
        /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
        /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
        /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml" /></remarks>
        public static void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => GLPointers._GetProgramResourceName_fnptr((int)program, (uint)programInterface, index, bufSize, length, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Retrieve values for multiple properties of a single active resource within a program object. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="index">!!missing documentation!!</param>
        /// <param name="propCount">!!missing documentation!!</param>
        /// <param name="props">!!missing documentation!!</param>
        /// <param name="bufSize">!!missing documentation!!</param>
        /// <param name="length">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml" /></remarks>
        public static void GetProgramResourceiv(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => GLPointers._GetProgramResourceiv_fnptr((int)program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the location of a named resource within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml" /></remarks>
        public static int GetProgramResourceLocation(ProgramHandle program, ProgramInterface programInterface, byte* name) => GLPointers._GetProgramResourceLocation_fnptr((int)program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the fragment color index of a named variable within a program. </summary>
        /// <param name="program"> The name of a program object whose resources to query. </param>
        /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
        /// <param name="name"> The name of the resource to query the location of. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml" /></remarks>
        public static int GetProgramResourceLocationIndex(ProgramHandle program, ProgramInterface programInterface, byte* name) => GLPointers._GetProgramResourceLocationIndex_fnptr((int)program, (uint)programInterface, name);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object]</b> Change an active shader storage block binding. </summary>
        /// <param name="program"> The name of the program containing the block whose binding to change. </param>
        /// <param name="storageBlockIndex"> The index storage block within the program. </param>
        /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml" /></remarks>
        public static void ShaderStorageBlockBinding(ProgramHandle program, uint storageBlockIndex, uint storageBlockBinding) => GLPointers._ShaderStorageBlockBinding_fnptr((int)program, storageBlockIndex, storageBlockBinding);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range]</b> Attach a range of a buffer object's data store to a buffer texture object. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer's data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer's data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
        public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._TexBufferRange_fnptr((uint)target, (uint)internalformat, (int)buffer, offset, size);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
        public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._TexStorage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
        public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._TexStorage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view]</b> Initialize a texture as a data alias of another texture's data store. </summary>
        /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
        /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
        /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
        /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
        /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
        /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
        /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
        /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml" /></remarks>
        public static void TextureView(TextureHandle texture, TextureTarget target, TextureHandle origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => GLPointers._TextureView_fnptr((int)texture, (uint)target, (int)origtexture, (uint)internalformat, minlevel, numlevels, minlayer, numlayers);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
        public static void BindVertexBuffer(uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => GLPointers._BindVertexBuffer_fnptr(bindingindex, (int)buffer, offset, stride);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._VertexAttribFormat_fnptr(attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._VertexAttribIFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._VertexAttribLFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
        public static void VertexAttribBinding(uint attribindex, uint bindingindex) => GLPointers._VertexAttribBinding_fnptr(attribindex, bindingindex);
        
        /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
        public static void VertexBindingDivisor(uint bindingindex, uint divisor) => GLPointers._VertexBindingDivisor_fnptr(bindingindex, divisor);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Control the reporting of debug messages in a debug context. </summary>
        /// <param name="source"> The source of debug messages to enable or disable. </param>
        /// <param name="type"> The type of debug messages to enable or disable. </param>
        /// <param name="severity"> The severity of debug messages to enable or disable. </param>
        /// <param name="count"> The length of the array ids. </param>
        /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
        /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml" /></remarks>
        public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._DebugMessageControl_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Inject an application-supplied message into the debug message queue. </summary>
        /// <param name="source"> The source of the debug message to insert. </param>
        /// <param name="type"> The type of the debug message insert. </param>
        /// <param name="id"> The user-supplied identifier of the message to insert. </param>
        /// <param name="severity"> The severity of the debug messages to insert. </param>
        /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
        /// <param name="message"> The address of a character array containing the message to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml" /></remarks>
        public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._DebugMessageInsert_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Specify a callback to receive debugging messages from the GL. </summary>
        /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
        /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml" /></remarks>
        public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers._DebugMessageCallback_fnptr(callback, userParam);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve messages from the debug message log. </summary>
        /// <param name="count"> The number of debug messages to retrieve from the log. </param>
        /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
        /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
        /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
        /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
        /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
        /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
        /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml" /></remarks>
        public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._GetDebugMessageLog_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Push a named debug group into the command stream. </summary>
        /// <param name="source"> The source of the debug message. </param>
        /// <param name="id"> The identifier of the message. </param>
        /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
        /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml" /></remarks>
        public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => GLPointers._PushDebugGroup_fnptr((uint)source, id, length, message);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Pop the active debug group. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml" /></remarks>
        public static void PopDebugGroup() => GLPointers._PopDebugGroup_fnptr();
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Label a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object to label. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml" /></remarks>
        public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers._ObjectLabel_fnptr((uint)identifier, name, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve the label of a named object identified within a namespace. </summary>
        /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
        /// <param name="name"> The name of the object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml" /></remarks>
        public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => GLPointers._GetObjectLabel_fnptr((uint)identifier, name, bufSize, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Label a sync object identified by a pointer. </summary>
        /// <param name="ptr"> A pointer identifying a sync object. </param>
        /// <param name="length"> The length of the label to be used for the object. </param>
        /// <param name="label"> The address of a string containing the label to assign to the object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml" /></remarks>
        public static void ObjectPtrLabel(void* ptr, int length, byte* label) => GLPointers._ObjectPtrLabel_fnptr(ptr, length, label);
        
        /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve the label of a sync object identified by a pointer. </summary>
        /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
        /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
        /// <param name="length"> The address of a variable to receive the length of the object label. </param>
        /// <param name="label"> The address of a string that will receive the object label. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml" /></remarks>
        public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => GLPointers._GetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage]</b> Creates and initializes a buffer object's immutable data    store. </summary>
        /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
        public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => GLPointers._BufferStorage_fnptr((uint)target, size, data, (uint)flags);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> Fills all a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml" /></remarks>
        public static void ClearTexImage(TextureHandle texture, int level, PixelFormat format, PixelType type, void* data) => GLPointers._ClearTexImage_fnptr((int)texture, level, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> Fills all or part of a texture image with a constant value. </summary>
        /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
        /// <param name="level"> The level of texture containing the region to be cleared. </param>
        /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
        /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
        /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
        /// <param name="width"> The width of the region to be cleared. </param>
        /// <param name="height"> The height of the region to be cleared. </param>
        /// <param name="depth"> The depth of the region to be cleared. </param>
        /// <param name="format"> The format of the data whose address in memory is given by data. </param>
        /// <param name="type"> The type of the data whose address in memory is given by data. </param>
        /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml" /></remarks>
        public static void ClearTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => GLPointers._ClearTexSubImage_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml" /></remarks>
        public static void BindBuffersBase(BufferTargetARB target, uint first, int count, BufferHandle* buffers) => GLPointers._BindBuffersBase_fnptr((uint)target, first, count, (int*)buffers);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
        /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
        /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
        /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
        /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
        /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml" /></remarks>
        public static void BindBuffersRange(BufferTargetARB target, uint first, int count, BufferHandle* buffers, IntPtr* offsets, nint* sizes) => GLPointers._BindBuffersRange_fnptr((uint)target, first, count, (int*)buffers, offsets, sizes);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named textures to a sequence of consecutive texture units. </summary>
        /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml" /></remarks>
        public static void BindTextures(uint first, int count, TextureHandle* textures) => GLPointers._BindTextures_fnptr(first, count, (int*)textures);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
        /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
        /// <param name="count"> Specifies the number of samplers to bind. </param>
        /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml" /></remarks>
        public static void BindSamplers(uint first, int count, SamplerHandle* samplers) => GLPointers._BindSamplers_fnptr(first, count, (int*)samplers);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named texture images to a sequence of consecutive image units. </summary>
        /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
        /// <param name="count"> Specifies the number of textures to bind. </param>
        /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml" /></remarks>
        public static void BindImageTextures(uint first, int count, TextureHandle* textures) => GLPointers._BindImageTextures_fnptr(first, count, (int*)textures);
        
        /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
        public static void BindVertexBuffers(uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides) => GLPointers._BindVertexBuffers_fnptr(first, count, (int*)buffers, offsets, strides);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control]</b> Control clip coordinate to window coordinate behavior. </summary>
        /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
        /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml" /></remarks>
        public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => GLPointers._ClipControl_fnptr((uint)origin, (uint)depth);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create transform feedback objects. </summary>
        /// <param name="n"> Number of transform feedback objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml" /></remarks>
        public static void CreateTransformFeedbacks(int n, TransformFeedbackHandle* ids) => GLPointers._CreateTransformFeedbacks_fnptr(n, (int*)ids);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml" /></remarks>
        public static void TransformFeedbackBufferBase(TransformFeedbackHandle xfb, uint index, BufferHandle buffer) => GLPointers._TransformFeedbackBufferBase_fnptr((int)xfb, index, (int)buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a range within a buffer object to a transform feedback buffer object. </summary>
        /// <param name="xfb"> Name of the transform feedback buffer object. </param>
        /// <param name="index"> Index of the binding point within xfb. </param>
        /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
        /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
        /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml" /></remarks>
        public static void TransformFeedbackBufferRange(TransformFeedbackHandle xfb, uint index, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._TransformFeedbackBufferRange_fnptr((int)xfb, index, (int)buffer, offset, size);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbackiv(TransformFeedbackHandle xfb, TransformFeedbackPName pname, int* param) => GLPointers._GetTransformFeedbackiv_fnptr((int)xfb, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbacki_v(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, int* param) => GLPointers._GetTransformFeedbacki_v_fnptr((int)xfb, (uint)pname, index, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
        /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
        /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
        /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
        /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
        public static void GetTransformFeedbacki64_v(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, long* param) => GLPointers._GetTransformFeedbacki64_v_fnptr((int)xfb, (uint)pname, index, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create buffer objects. </summary>
        /// <param name="n"> Specifies the number of buffer objects to create. </param>
        /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml" /></remarks>
        public static void CreateBuffers(int n, BufferHandle* buffers) => GLPointers._CreateBuffers_fnptr(n, (int*)buffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Creates and initializes a buffer object's immutable data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
        public static void NamedBufferStorage(BufferHandle buffer, nint size, void* data, BufferStorageMask flags) => GLPointers._NamedBufferStorage_fnptr((int)buffer, size, data, (uint)flags);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Creates and initializes a buffer object's data    store. </summary>
        /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
        public static void NamedBufferData(BufferHandle buffer, nint size, void* data, VertexBufferObjectUsage usage) => GLPointers._NamedBufferData_fnptr((int)buffer, size, data, (uint)usage);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Updates a subset of a buffer object's data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
        /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
        public static void NamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, void* data) => GLPointers._NamedBufferSubData_fnptr((int)buffer, offset, size, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
        /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
        /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
        /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
        /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
        public static void CopyNamedBufferSubData(BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._CopyNamedBufferSubData_fnptr((int)readBuffer, (int)writeBuffer, readOffset, writeOffset, size);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Fill a buffer object's data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
        public static void ClearNamedBufferData(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._ClearNamedBufferData_fnptr((int)buffer, (uint)internalformat, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Fill all or part of buffer object's data store with a fixed value. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
        /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
        /// <param name="offset"> The offset in basic machine units into the buffer object's data store at which to start filling. </param>
        /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
        /// <param name="format"> The format of the data in memory addressed by data. </param>
        /// <param name="type"> The type of the data in memory addressed by data. </param>
        /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
        public static void ClearNamedBufferSubData(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._ClearNamedBufferSubData_fnptr((int)buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Map all of a buffer object's data store into the client's address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
        /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
        public static void* MapNamedBuffer(BufferHandle buffer, BufferAccessARB access) => GLPointers._MapNamedBuffer_fnptr((int)buffer, (uint)access);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Map all or part of a buffer object's data store into the client's address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
        /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
        /// <param name="length"> Specifies the length of the range to be mapped. </param>
        /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
        public static void* MapNamedBufferRange(BufferHandle buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._MapNamedBufferRange_fnptr((int)buffer, offset, length, (uint)access);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Release the mapping of a buffer object's data store into the client's address space. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
        public static bool UnmapNamedBuffer(BufferHandle buffer) => GLPointers._UnmapNamedBuffer_fnptr((int)buffer) != 0;
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Indicate modifications to a range of a mapped buffer. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
        /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
        /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
        public static void FlushMappedNamedBufferRange(BufferHandle buffer, IntPtr offset, nint length) => GLPointers._FlushMappedNamedBufferRange_fnptr((int)buffer, offset, length);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetNamedBufferParameteriv(BufferHandle buffer, BufferPNameARB pname, int* parameters) => GLPointers._GetNamedBufferParameteriv_fnptr((int)buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a buffer object. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
        /// <param name="pname">!!missing documentation!!</param>
        /// <param name="parameters">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
        public static void GetNamedBufferParameteri64v(BufferHandle buffer, BufferPNameARB pname, long* parameters) => GLPointers._GetNamedBufferParameteri64v_fnptr((int)buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return the pointer to a mapped buffer object's data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
        /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
        /// <param name="parameters"> Returns the pointer value specified by pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
        public static void GetNamedBufferPointerv(BufferHandle buffer, BufferPointerNameARB pname, void** parameters) => GLPointers._GetNamedBufferPointerv_fnptr((int)buffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Returns a subset of a buffer object's data store. </summary>
        /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
        /// <param name="offset"> Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes. </param>
        /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
        /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
        public static void GetNamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, void* data) => GLPointers._GetNamedBufferSubData_fnptr((int)buffer, offset, size, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create framebuffer objects. </summary>
        /// <param name="n"> Number of framebuffer objects to create. </param>
        /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml" /></remarks>
        public static void CreateFramebuffers(int n, FramebufferHandle* framebuffers) => GLPointers._CreateFramebuffers_fnptr(n, (int*)framebuffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
        /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
        public static void NamedFramebufferRenderbuffer(FramebufferHandle framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => GLPointers._NamedFramebufferRenderbuffer_fnptr((int)framebuffer, (uint)attachment, (uint)renderbuffertarget, (int)renderbuffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
        /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
        /// <param name="param"> The new value for the parameter named pname. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
        public static void NamedFramebufferParameteri(FramebufferHandle framebuffer, FramebufferParameterName pname, int param) => GLPointers._NamedFramebufferParameteri_fnptr((int)framebuffer, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
        public static void NamedFramebufferTexture(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level) => GLPointers._NamedFramebufferTexture_fnptr((int)framebuffer, (uint)attachment, (int)texture, level);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
        /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
        /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
        /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
        /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
        public static void NamedFramebufferTextureLayer(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => GLPointers._NamedFramebufferTextureLayer_fnptr((int)framebuffer, (uint)attachment, (int)texture, level, layer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify which color buffers are to be drawn into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
        /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
        public static void NamedFramebufferDrawBuffer(FramebufferHandle framebuffer, ColorBuffer buf) => GLPointers._NamedFramebufferDrawBuffer_fnptr((int)framebuffer, (uint)buf);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specifies a list of color buffers to be drawn    into. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
        public static void NamedFramebufferDrawBuffers(FramebufferHandle framebuffer, int n, ColorBuffer* bufs) => GLPointers._NamedFramebufferDrawBuffers_fnptr((int)framebuffer, n, (uint*)bufs);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Select a color buffer source for pixels. </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
        /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
        public static void NamedFramebufferReadBuffer(FramebufferHandle framebuffer, ColorBuffer src) => GLPointers._NamedFramebufferReadBuffer_fnptr((int)framebuffer, (uint)src);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Invalidate the content of some or all of a framebuffer's attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
        public static void InvalidateNamedFramebufferData(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments) => GLPointers._InvalidateNamedFramebufferData_fnptr((int)framebuffer, numAttachments, (uint*)attachments);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Invalidate the content of a region of some or all of a framebuffer's attachments. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
        /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
        /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
        /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
        /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
        /// <param name="width"> Specifies the width of the region to be invalidated. </param>
        /// <param name="height"> Specifies the height of the region to be invalidated. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
        public static void InvalidateNamedFramebufferSubData(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._InvalidateNamedFramebufferSubData_fnptr((int)framebuffer, numAttachments, (uint*)attachments, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferiv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, int* value) => GLPointers._ClearNamedFramebufferiv_fnptr((int)framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferuiv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, uint* value) => GLPointers._ClearNamedFramebufferuiv_fnptr((int)framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferfv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float* value) => GLPointers._ClearNamedFramebufferfv_fnptr((int)framebuffer, (uint)buffer, drawbuffer, value);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
        /// <param name="buffer"> Specify the buffer to clear. </param>
        /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
        /// <param name="depth"> The value to clear the depth buffer to. </param>
        /// <param name="stencil"> The value to clear the stencil buffer to. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
        public static void ClearNamedFramebufferfi(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers._ClearNamedFramebufferfi_fnptr((int)framebuffer, (uint)buffer, drawbuffer, depth, stencil);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a block of pixels from one framebuffer object to another. </summary>
        /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
        /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
        /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
        /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
        /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
        public static void BlitNamedFramebuffer(FramebufferHandle readFramebuffer, FramebufferHandle drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._BlitNamedFramebuffer_fnptr((int)readFramebuffer, (int)drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Check the completeness status of a framebuffer. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
        /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
        public static FramebufferStatus CheckNamedFramebufferStatus(FramebufferHandle framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers._CheckNamedFramebufferStatus_fnptr((int)framebuffer, (uint)target);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query a named parameter of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
        /// <param name="param">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
        public static void GetNamedFramebufferParameteriv(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* param) => GLPointers._GetNamedFramebufferParameteriv_fnptr((int)framebuffer, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve information about attachments of a framebuffer object. </summary>
        /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
        /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
        /// <param name="pname"> Specifies the parameter of attachment to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
        public static void GetNamedFramebufferAttachmentParameteriv(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._GetNamedFramebufferAttachmentParameteriv_fnptr((int)framebuffer, (uint)attachment, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create renderbuffer objects. </summary>
        /// <param name="n"> Number of renderbuffer objects to create. </param>
        /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml" /></remarks>
        public static void CreateRenderbuffers(int n, RenderbufferHandle* renderbuffers) => GLPointers._CreateRenderbuffers_fnptr(n, (int*)renderbuffers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Establish data storage, format and dimensions of a    renderbuffer object's image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
        public static void NamedRenderbufferStorage(RenderbufferHandle renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers._NamedRenderbufferStorage_fnptr((int)renderbuffer, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object's image. </summary>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
        public static void NamedRenderbufferStorageMultisample(RenderbufferHandle renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers._NamedRenderbufferStorageMultisample_fnptr((int)renderbuffer, samples, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query a named parameter of a renderbuffer object. </summary>
        /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
        /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
        /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
        public static void GetNamedRenderbufferParameteriv(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers._GetNamedRenderbufferParameteriv_fnptr((int)renderbuffer, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create texture objects. </summary>
        /// <param name="target"> Specifies the effective texture target of each created texture. </param>
        /// <param name="n"> Number of texture objects to create. </param>
        /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml" /></remarks>
        public static void CreateTextures(TextureTarget target, int n, TextureHandle* textures) => GLPointers._CreateTextures_fnptr((uint)target, n, (int*)textures);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a buffer object's data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
        public static void TextureBuffer(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer) => GLPointers._TextureBuffer_fnptr((int)texture, (uint)internalformat, (int)buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a range of a buffer object's data store to a buffer texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
        /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
        /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
        /// <param name="offset"> Specifies the offset of the start of the range of the buffer's data store to attach. </param>
        /// <param name="size"> Specifies the size of the range of the buffer's data store to attach. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
        public static void TextureBufferRange(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._TextureBufferRange_fnptr((int)texture, (uint)internalformat, (int)buffer, offset, size);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
        public static void TextureStorage1D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width) => GLPointers._TextureStorage1D_fnptr((int)texture, levels, (uint)internalformat, width);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
        public static void TextureStorage2D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._TextureStorage2D_fnptr((int)texture, levels, (uint)internalformat, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="levels"> Specify the number of texture levels. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
        public static void TextureStorage3D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._TextureStorage3D_fnptr((int)texture, levels, (uint)internalformat, width, height, depth);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify storage for a two-dimensional multisample texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
        public static void TextureStorage2DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._TextureStorage2DMultisample_fnptr((int)texture, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify storage for a two-dimensional multisample array texture. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
        /// <param name="samples"> Specify the number of samples in the texture. </param>
        /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
        /// <param name="width"> Specifies the width of the texture, in texels. </param>
        /// <param name="height"> Specifies the height of the texture, in texels. </param>
        /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
        /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
        public static void TextureStorage3DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._TextureStorage3DMultisample_fnptr((int)texture, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a one-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
        public static void TextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureSubImage1D_fnptr((int)texture, level, xoffset, width, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a two-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
        public static void TextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureSubImage2D_fnptr((int)texture, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a three-dimensional texture subimage. </summary>
        /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
        /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
        /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
        /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
        /// <param name="width"> Specifies the width of the texture subimage. </param>
        /// <param name="height"> Specifies the height of the texture subimage. </param>
        /// <param name="depth"> Specifies the depth of the texture subimage. </param>
        /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
        /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
        /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
        public static void TextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureSubImage3D_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a one-dimensional texture subimage in a compressed    format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
        public static void CompressedTextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTextureSubImage1D_fnptr((int)texture, level, xoffset, width, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a two-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
        public static void CompressedTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTextureSubImage2D_fnptr((int)texture, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a three-dimensional texture subimage in a compressed format. </summary>
        /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">!!missing documentation!!</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
        public static void CompressedTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTextureSubImage3D_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a one-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
        public static void CopyTextureSubImage1D(TextureHandle texture, int level, int xoffset, int x, int y, int width) => GLPointers._CopyTextureSubImage1D_fnptr((int)texture, level, xoffset, x, y, width);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a two-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
        public static void CopyTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._CopyTextureSubImage2D_fnptr((int)texture, level, xoffset, yoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a three-dimensional texture subimage. </summary>
        /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
        public static void CopyTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._CopyTextureSubImage3D_fnptr((int)texture, level, xoffset, yoffset, zoffset, x, y, width, height);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterf(TextureHandle texture, TextureParameterName pname, float param) => GLPointers._TextureParameterf_fnptr((int)texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterfv(TextureHandle texture, TextureParameterName pname, float* param) => GLPointers._TextureParameterfv_fnptr((int)texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">For the scalar commands, specifies the value of pname.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameteri(TextureHandle texture, TextureParameterName pname, int param) => GLPointers._TextureParameteri_fnptr((int)texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterIiv(TextureHandle texture, TextureParameterName pname, int* parameters) => GLPointers._TextureParameterIiv_fnptr((int)texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameterIuiv(TextureHandle texture, TextureParameterName pname, uint* parameters) => GLPointers._TextureParameterIuiv_fnptr((int)texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
        /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
        public static void TextureParameteriv(TextureHandle texture, TextureParameterName pname, int* param) => GLPointers._TextureParameteriv_fnptr((int)texture, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Generate mipmaps for a specified texture object. </summary>
        /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
        public static void GenerateTextureMipmap(TextureHandle texture) => GLPointers._GenerateTextureMipmap_fnptr((int)texture);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind an existing texture object to the specified texture unit . </summary>
        /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
        /// <param name="texture">Specifies the name of a texture. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml" /></remarks>
        public static void BindTextureUnit(uint unit, TextureHandle texture) => GLPointers._BindTextureUnit_fnptr(unit, (int)texture);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return a texture image. </summary>
        /// <param name="texture"> Specifies the texture object name. </param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetTextureImage(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._GetTextureImage_fnptr((int)texture, level, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return a compressed texture image. </summary>
        /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetCompressedTextureImage(TextureHandle texture, int level, int bufSize, void* pixels) => GLPointers._GetCompressedTextureImage_fnptr((int)texture, level, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTextureLevelParameterfv(TextureHandle texture, int level, GetTextureParameter pname, float* parameters) => GLPointers._GetTextureLevelParameterfv_fnptr((int)texture, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values for a specific level of    detail. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="parameters">Returns the requested data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
        public static void GetTextureLevelParameteriv(TextureHandle texture, int level, GetTextureParameter pname, int* parameters) => GLPointers._GetTextureLevelParameteriv_fnptr((int)texture, level, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterfv(TextureHandle texture, GetTextureParameter pname, float* parameters) => GLPointers._GetTextureParameterfv_fnptr((int)texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterIiv(TextureHandle texture, GetTextureParameter pname, int* parameters) => GLPointers._GetTextureParameterIiv_fnptr((int)texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameterIuiv(TextureHandle texture, GetTextureParameter pname, uint* parameters) => GLPointers._GetTextureParameterIuiv_fnptr((int)texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
        /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="parameters">Returns the texture parameters.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
        public static void GetTextureParameteriv(TextureHandle texture, GetTextureParameter pname, int* parameters) => GLPointers._GetTextureParameteriv_fnptr((int)texture, (uint)pname, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create vertex array objects. </summary>
        /// <param name="n"> Number of vertex array objects to create. </param>
        /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml" /></remarks>
        public static void CreateVertexArrays(int n, VertexArrayHandle* arrays) => GLPointers._CreateVertexArrays_fnptr(n, (int*)arrays);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void DisableVertexArrayAttrib(VertexArrayHandle vaobj, uint index) => GLPointers._DisableVertexArrayAttrib_fnptr((int)vaobj, index);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Enable or disable a generic vertex attribute    array. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
        public static void EnableVertexArrayAttrib(VertexArrayHandle vaobj, uint index) => GLPointers._EnableVertexArrayAttrib_fnptr((int)vaobj, index);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Configures element array buffer binding of a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
        /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml" /></remarks>
        public static void VertexArrayElementBuffer(VertexArrayHandle vaobj, BufferHandle buffer) => GLPointers._VertexArrayElementBuffer_fnptr((int)vaobj, (int)buffer);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a buffer to a vertex buffer bind point. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
        public static void VertexArrayVertexBuffer(VertexArrayHandle vaobj, uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => GLPointers._VertexArrayVertexBuffer_fnptr((int)vaobj, bindingindex, (int)buffer, offset, stride);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach multiple buffer objects to a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
        /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
        /// <param name="count"> Specifies the number of buffers to bind. </param>
        /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
        /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
        /// <param name="strides">!!missing documentation!!</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
        public static void VertexArrayVertexBuffers(VertexArrayHandle vaobj, uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides) => GLPointers._VertexArrayVertexBuffers_fnptr((int)vaobj, first, count, (int*)buffers, offsets, strides);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
        /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
        /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
        /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
        public static void VertexArrayAttribBinding(VertexArrayHandle vaobj, uint attribindex, uint bindingindex) => GLPointers._VertexArrayAttribBinding_fnptr((int)vaobj, attribindex, bindingindex);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._VertexArrayAttribFormat_fnptr((int)vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribIFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._VertexArrayAttribIFormat_fnptr((int)vaobj, attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
        public static void VertexArrayAttribLFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._VertexArrayAttribLFormat_fnptr((int)vaobj, attribindex, size, (uint)type, relativeoffset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Modify the rate at which generic vertex attributes    advance. </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
        public static void VertexArrayBindingDivisor(VertexArrayHandle vaobj, uint bindingindex, uint divisor) => GLPointers._VertexArrayBindingDivisor_fnptr((int)vaobj, bindingindex, divisor);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of a vertex array object. </summary>
        /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
        /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml" /></remarks>
        public static void GetVertexArrayiv(VertexArrayHandle vaobj, VertexArrayPName pname, int* param) => GLPointers._GetVertexArrayiv_fnptr((int)vaobj, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
        public static void GetVertexArrayIndexediv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers._GetVertexArrayIndexediv_fnptr((int)vaobj, index, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
        /// <param name="vaobj">Specifies the name of a vertex array object.</param>
        /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
        /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
        /// <param name="param">Returns the requested value.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
        public static void GetVertexArrayIndexed64iv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, long* param) => GLPointers._GetVertexArrayIndexed64iv_fnptr((int)vaobj, index, (uint)pname, param);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create sampler objects. </summary>
        /// <param name="n"> Number of sampler objects to create. </param>
        /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml" /></remarks>
        public static void CreateSamplers(int n, SamplerHandle* samplers) => GLPointers._CreateSamplers_fnptr(n, (int*)samplers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create program pipeline objects. </summary>
        /// <param name="n"> Number of program pipeline objects to create. </param>
        /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml" /></remarks>
        public static void CreateProgramPipelines(int n, ProgramPipelineHandle* pipelines) => GLPointers._CreateProgramPipelines_fnptr(n, (int*)pipelines);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create query objects. </summary>
        /// <param name="target"> Specifies the target of each created query object. </param>
        /// <param name="n"> Number of query objects to create. </param>
        /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml" /></remarks>
        public static void CreateQueries(QueryTarget target, int n, QueryHandle* ids) => GLPointers._CreateQueries_fnptr((uint)target, n, (int*)ids);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjecti64v(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._GetQueryBufferObjecti64v_fnptr((int)id, (int)buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectiv(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._GetQueryBufferObjectiv_fnptr((int)id, (int)buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectui64v(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._GetQueryBufferObjectui64v_fnptr((int)id, (int)buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
        /// <param name="id"> Specifies the name of a query object. </param>
        /// <param name="buffer"> Specifies the name of a buffer object. </param>
        /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
        /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
        public static void GetQueryBufferObjectuiv(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._GetQueryBufferObjectuiv_fnptr((int)id, (int)buffer, (uint)pname, offset);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility]</b> Defines a barrier ordering memory transactions. </summary>
        /// <param name="barriers"> Specifies the barriers to insert. </param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
        public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => GLPointers._MemoryBarrierByRegion_fnptr((uint)barriers);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> Retrieve a sub-region of a texture image from a texture    object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml" /></remarks>
        public static void GetTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._GetTextureSubImage_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the offset is zero and the size equals the texture image size.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml" /></remarks>
        public static void GetCompressedTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => GLPointers._GetCompressedTextureSubImage_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Check if the rendering context has not been lost due to software or hardware issues. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml" /></remarks>
        public static GraphicsResetStatus GetGraphicsResetStatus() => (GraphicsResetStatus) GLPointers._GetGraphicsResetStatus_fnptr();
        
        /// <summary> <b>[requires: v4.5]</b> Return a compressed texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
        public static void GetnCompressedTexImage(TextureTarget target, int lod, int bufSize, void* pixels) => GLPointers._GetnCompressedTexImage_fnptr((uint)target, lod, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5]</b> Return a texture image. </summary>
        /// <param name="target">Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.</param>
        /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
        /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
        public static void GetnTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._GetnTexImage_fnptr((uint)target, level, (uint)format, (uint)type, bufSize, pixels);
        
        /// <summary> <b>[requires: v4.5]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformdv(ProgramHandle program, int location, int bufSize, double* parameters) => GLPointers._GetnUniformdv_fnptr((int)program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformfv(ProgramHandle program, int location, int bufSize, float* parameters) => GLPointers._GetnUniformfv_fnptr((int)program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformiv(ProgramHandle program, int location, int bufSize, int* parameters) => GLPointers._GetnUniformiv_fnptr((int)program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the size of the buffer params.</param>
        /// <param name="parameters">Returns the value of the specified uniform variable.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
        public static void GetnUniformuiv(ProgramHandle program, int location, int bufSize, uint* parameters) => GLPointers._GetnUniformuiv_fnptr((int)program, location, bufSize, parameters);
        
        /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Read a block of pixels from the frame buffer. </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
        /// <param name="data">Returns the pixel data.</param>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
        public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._ReadnPixels_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
        
        /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier]</b> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
        /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml" /></remarks>
        public static void TextureBarrier() => GLPointers._TextureBarrier_fnptr();
        
        public static void SpecializeShader(ShaderHandle shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => GLPointers._SpecializeShader_fnptr((int)shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        
        public static void MultiDrawArraysIndirectCount(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._MultiDrawArraysIndirectCount_fnptr((uint)mode, indirect, drawcount, maxdrawcount, stride);
        
        public static void MultiDrawElementsIndirectCount(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._MultiDrawElementsIndirectCount_fnptr((uint)mode, (uint)type, indirect, drawcount, maxdrawcount, stride);
        
        /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp]</b>  </summary>
        /// <remarks><see href="" /></remarks>
        public static void PolygonOffsetClamp(float factor, float units, float clamp) => GLPointers._PolygonOffsetClamp_fnptr(factor, units, clamp);
        
        public static unsafe partial class _3DFX
        {
            /// <summary> <b>[requires: GL_3DFX_tbuffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TbufferMask3DFX(uint mask) => GLPointers._TbufferMask3DFX_fnptr(mask);
            
        }
        public static unsafe partial class AMD
        {
            /// <summary> <b>[requires: GL_AMD_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageEnableAMD(All category, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._DebugMessageEnableAMD_fnptr((uint)category, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageInsertAMD(All category, DebugSeverity severity, uint id, int length, byte* buf) => GLPointers._DebugMessageInsertAMD_fnptr((uint)category, (uint)severity, id, length, buf);
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageCallbackAMD(IntPtr callback, void* userParam) => GLPointers._DebugMessageCallbackAMD_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: GL_AMD_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GetDebugMessageLogAMD(uint count, int bufSize, All* categories, uint* severities, uint* ids, int* lengths, byte* message) => GLPointers._GetDebugMessageLogAMD_fnptr(count, bufSize, (uint*)categories, severities, ids, lengths, message);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncIndexedAMD(uint buf, All src, All dst) => GLPointers._BlendFuncIndexedAMD_fnptr(buf, (uint)src, (uint)dst);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncSeparateIndexedAMD(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers._BlendFuncSeparateIndexedAMD_fnptr(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationIndexedAMD(uint buf, BlendEquationModeEXT mode) => GLPointers._BlendEquationIndexedAMD_fnptr(buf, (uint)mode);
            
            /// <summary> <b>[requires: GL_AMD_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationSeparateIndexedAMD(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._BlendEquationSeparateIndexedAMD_fnptr(buf, (uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderbufferStorageMultisampleAdvancedAMD(RenderbufferTarget target, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => GLPointers._RenderbufferStorageMultisampleAdvancedAMD_fnptr((uint)target, samples, storageSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_multisample_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedRenderbufferStorageMultisampleAdvancedAMD(RenderbufferHandle renderbuffer, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => GLPointers._NamedRenderbufferStorageMultisampleAdvancedAMD_fnptr((int)renderbuffer, samples, storageSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferSamplePositionsfvAMD(FramebufferTarget target, uint numsamples, uint pixelindex, float* values) => GLPointers._FramebufferSamplePositionsfvAMD_fnptr((uint)target, numsamples, pixelindex, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferSamplePositionsfvAMD(FramebufferHandle framebuffer, uint numsamples, uint pixelindex, float* values) => GLPointers._NamedFramebufferSamplePositionsfvAMD_fnptr((int)framebuffer, numsamples, pixelindex, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFramebufferParameterfvAMD(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, float* values) => GLPointers._GetFramebufferParameterfvAMD_fnptr((uint)target, (uint)pname, numsamples, pixelindex, size, values);
            
            /// <summary> <b>[requires: GL_AMD_framebuffer_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedFramebufferParameterfvAMD(FramebufferHandle framebuffer, All pname, uint numsamples, uint pixelindex, int size, float* values) => GLPointers._GetNamedFramebufferParameterfvAMD_fnptr((int)framebuffer, (uint)pname, numsamples, pixelindex, size, values);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64NV(int location, long x) => GLPointers._Uniform1i64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64NV(int location, long x, long y) => GLPointers._Uniform2i64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64NV(int location, long x, long y, long z) => GLPointers._Uniform3i64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64NV(int location, long x, long y, long z, long w) => GLPointers._Uniform4i64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64vNV(int location, int count, long* value) => GLPointers._Uniform1i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64vNV(int location, int count, long* value) => GLPointers._Uniform2i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64vNV(int location, int count, long* value) => GLPointers._Uniform3i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64vNV(int location, int count, long* value) => GLPointers._Uniform4i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64NV(int location, ulong x) => GLPointers._Uniform1ui64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64NV(int location, ulong x, ulong y) => GLPointers._Uniform2ui64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z) => GLPointers._Uniform3ui64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._Uniform4ui64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64vNV(int location, int count, ulong* value) => GLPointers._Uniform1ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64vNV(int location, int count, ulong* value) => GLPointers._Uniform2ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64vNV(int location, int count, ulong* value) => GLPointers._Uniform3ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64vNV(int location, int count, ulong* value) => GLPointers._Uniform4ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformi64vNV(ProgramHandle program, int location, long* parameters) => GLPointers._GetUniformi64vNV_fnptr((int)program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformui64vNV(ProgramHandle program, int location, ulong* parameters) => GLPointers._GetUniformui64vNV_fnptr((int)program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64NV(ProgramHandle program, int location, long x) => GLPointers._ProgramUniform1i64NV_fnptr((int)program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64NV(ProgramHandle program, int location, long x, long y) => GLPointers._ProgramUniform2i64NV_fnptr((int)program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64NV(ProgramHandle program, int location, long x, long y, long z) => GLPointers._ProgramUniform3i64NV_fnptr((int)program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64NV(ProgramHandle program, int location, long x, long y, long z, long w) => GLPointers._ProgramUniform4i64NV_fnptr((int)program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64vNV(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform1i64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64vNV(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform2i64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64vNV(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform3i64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64vNV(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform4i64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64NV(ProgramHandle program, int location, ulong x) => GLPointers._ProgramUniform1ui64NV_fnptr((int)program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64NV(ProgramHandle program, int location, ulong x, ulong y) => GLPointers._ProgramUniform2ui64NV_fnptr((int)program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64NV(ProgramHandle program, int location, ulong x, ulong y, ulong z) => GLPointers._ProgramUniform3ui64NV_fnptr((int)program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64NV(ProgramHandle program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._ProgramUniform4ui64NV_fnptr((int)program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64vNV(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform1ui64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64vNV(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform2ui64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64vNV(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform3ui64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64vNV(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform4ui64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_interleaved_elements]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribParameteriAMD(uint index, All pname, int param) => GLPointers._VertexAttribParameteriAMD_fnptr(index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysIndirectAMD(PrimitiveType mode, void* indirect, int primcount, int stride) => GLPointers._MultiDrawArraysIndirectAMD_fnptr((uint)mode, indirect, primcount, stride);
            
            /// <summary> <b>[requires: GL_AMD_multi_draw_indirect]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsIndirectAMD(PrimitiveType mode, DrawElementsType type, void* indirect, int primcount, int stride) => GLPointers._MultiDrawElementsIndirectAMD_fnptr((uint)mode, (uint)type, indirect, primcount, stride);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenNamesAMD(All identifier, uint num, uint* names) => GLPointers._GenNamesAMD_fnptr((uint)identifier, num, names);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteNamesAMD(All identifier, uint num, uint* names) => GLPointers._DeleteNamesAMD_fnptr((uint)identifier, num, names);
            
            /// <summary> <b>[requires: GL_AMD_name_gen_delete]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsNameAMD(All identifier, uint name) => GLPointers._IsNameAMD_fnptr((uint)identifier, name) != 0;
            
            /// <summary> <b>[requires: GL_AMD_occlusion_query_event]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void QueryObjectParameteruiAMD(QueryTarget target, QueryHandle id, All pname, uint param) => GLPointers._QueryObjectParameteruiAMD_fnptr((uint)target, (int)id, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorGroupsAMD(int* numGroups, int groupsSize, uint* groups) => GLPointers._GetPerfMonitorGroupsAMD_fnptr(numGroups, groupsSize, groups);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorCountersAMD(uint group, int* numCounters, int* maxActiveCounters, int counterSize, uint* counters) => GLPointers._GetPerfMonitorCountersAMD_fnptr(group, numCounters, maxActiveCounters, counterSize, counters);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorGroupStringAMD(uint group, int bufSize, int* length, byte* groupString) => GLPointers._GetPerfMonitorGroupStringAMD_fnptr(group, bufSize, length, groupString);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, int* length, byte* counterString) => GLPointers._GetPerfMonitorCounterStringAMD_fnptr(group, counter, bufSize, length, counterString);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorCounterInfoAMD(uint group, uint counter, All pname, void* data) => GLPointers._GetPerfMonitorCounterInfoAMD_fnptr(group, counter, (uint)pname, data);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenPerfMonitorsAMD(int n, uint* monitors) => GLPointers._GenPerfMonitorsAMD_fnptr(n, monitors);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeletePerfMonitorsAMD(int n, uint* monitors) => GLPointers._DeletePerfMonitorsAMD_fnptr(n, monitors);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, uint* counterList) => GLPointers._SelectPerfMonitorCountersAMD_fnptr(monitor, (byte)(enable ? 1 : 0), group, numCounters, counterList);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginPerfMonitorAMD(uint monitor) => GLPointers._BeginPerfMonitorAMD_fnptr(monitor);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndPerfMonitorAMD(uint monitor) => GLPointers._EndPerfMonitorAMD_fnptr(monitor);
            
            /// <summary> <b>[requires: GL_AMD_performance_monitor]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfMonitorCounterDataAMD(uint monitor, All pname, int dataSize, uint* data, int* bytesWritten) => GLPointers._GetPerfMonitorCounterDataAMD_fnptr(monitor, (uint)pname, dataSize, data, bytesWritten);
            
            /// <summary> <b>[requires: GL_AMD_sample_positions]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetMultisamplefvAMD(All pname, uint index, float* val) => GLPointers._SetMultisamplefvAMD_fnptr((uint)pname, index, val);
            
            /// <summary> <b>[requires: GL_AMD_sparse_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageSparseAMD(TextureTarget target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => GLPointers._TexStorageSparseAMD_fnptr((uint)target, (uint)internalFormat, width, height, depth, layers, (uint)flags);
            
            /// <summary> <b>[requires: GL_AMD_sparse_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageSparseAMD(TextureHandle texture, All target, SizedInternalFormat internalFormat, int width, int height, int depth, int layers, TextureStorageMaskAMD flags) => GLPointers._TextureStorageSparseAMD_fnptr((int)texture, (uint)target, (uint)internalFormat, width, height, depth, layers, (uint)flags);
            
            /// <summary> <b>[requires: GL_AMD_stencil_operation_extended]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilOpValueAMD(StencilFaceDirection face, uint value) => GLPointers._StencilOpValueAMD_fnptr((uint)face, value);
            
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TessellationFactorAMD(float factor) => GLPointers._TessellationFactorAMD_fnptr(factor);
            
            /// <summary> <b>[requires: GL_AMD_vertex_shader_tessellator]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TessellationModeAMD(All mode) => GLPointers._TessellationModeAMD_fnptr((uint)mode);
            
        }
        public static unsafe partial class APPLE
        {
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ElementPointerAPPLE(ElementPointerTypeATI type, void* pointer) => GLPointers._ElementPointerAPPLE_fnptr((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawElementArrayAPPLE(PrimitiveType mode, int first, int count) => GLPointers._DrawElementArrayAPPLE_fnptr((uint)mode, first, count);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int first, int count) => GLPointers._DrawRangeElementArrayAPPLE_fnptr((uint)mode, start, end, first, count);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementArrayAPPLE(PrimitiveType mode, int* first, int* count, int primcount) => GLPointers._MultiDrawElementArrayAPPLE_fnptr((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_APPLE_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int* first, int* count, int primcount) => GLPointers._MultiDrawRangeElementArrayAPPLE_fnptr((uint)mode, start, end, first, count, primcount);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenFencesAPPLE(int n, uint* fences) => GLPointers._GenFencesAPPLE_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteFencesAPPLE(int n, uint* fences) => GLPointers._DeleteFencesAPPLE_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetFenceAPPLE(uint fence) => GLPointers._SetFenceAPPLE_fnptr(fence);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsFenceAPPLE(uint fence) => GLPointers._IsFenceAPPLE_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool TestFenceAPPLE(uint fence) => GLPointers._TestFenceAPPLE_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinishFenceAPPLE(uint fence) => GLPointers._FinishFenceAPPLE_fnptr(fence);
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool TestObjectAPPLE(ObjectTypeAPPLE obj, uint name) => GLPointers._TestObjectAPPLE_fnptr((uint)obj, name) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinishObjectAPPLE(ObjectTypeAPPLE obj, int name) => GLPointers._FinishObjectAPPLE_fnptr((uint)obj, name);
            
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferParameteriAPPLE(All target, All pname, int param) => GLPointers._BufferParameteriAPPLE_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_APPLE_flush_buffer_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushMappedBufferRangeAPPLE(BufferTargetARB target, IntPtr offset, nint size) => GLPointers._FlushMappedBufferRangeAPPLE_fnptr((uint)target, offset, size);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All ObjectPurgeableAPPLE(All objectType, uint name, All option) => (All) GLPointers._ObjectPurgeableAPPLE_fnptr((uint)objectType, name, (uint)option);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All ObjectUnpurgeableAPPLE(All objectType, uint name, All option) => (All) GLPointers._ObjectUnpurgeableAPPLE_fnptr((uint)objectType, name, (uint)option);
            
            /// <summary> <b>[requires: GL_APPLE_object_purgeable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectParameterivAPPLE(All objectType, uint name, All pname, int* parameters) => GLPointers._GetObjectParameterivAPPLE_fnptr((uint)objectType, name, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_APPLE_texture_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureRangeAPPLE(All target, int length, void* pointer) => GLPointers._TextureRangeAPPLE_fnptr((uint)target, length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_texture_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexParameterPointervAPPLE(All target, All pname, void** parameters) => GLPointers._GetTexParameterPointervAPPLE_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindVertexArrayAPPLE(VertexArrayHandle array) => GLPointers._BindVertexArrayAPPLE_fnptr((int)array);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteVertexArraysAPPLE(int n, VertexArrayHandle* arrays) => GLPointers._DeleteVertexArraysAPPLE_fnptr(n, (int*)arrays);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenVertexArraysAPPLE(int n, VertexArrayHandle* arrays) => GLPointers._GenVertexArraysAPPLE_fnptr(n, (int*)arrays);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsVertexArrayAPPLE(VertexArrayHandle array) => GLPointers._IsVertexArrayAPPLE_fnptr((int)array) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayRangeAPPLE(int length, void* pointer) => GLPointers._VertexArrayRangeAPPLE_fnptr(length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushVertexArrayRangeAPPLE(int length, void* pointer) => GLPointers._FlushVertexArrayRangeAPPLE_fnptr(length, pointer);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayParameteriAPPLE(VertexArrayPNameAPPLE pname, int param) => GLPointers._VertexArrayParameteriAPPLE_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVertexAttribAPPLE(uint index, All pname) => GLPointers._EnableVertexAttribAPPLE_fnptr(index, (uint)pname);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVertexAttribAPPLE(uint index, All pname) => GLPointers._DisableVertexAttribAPPLE_fnptr(index, (uint)pname);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsVertexAttribEnabledAPPLE(uint index, All pname) => GLPointers._IsVertexAttribEnabledAPPLE_fnptr(index, (uint)pname) != 0;
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, double* points) => GLPointers._MapVertexAttrib1dAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, float* points) => GLPointers._MapVertexAttrib1fAPPLE_fnptr(index, size, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) => GLPointers._MapVertexAttrib2dAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_APPLE_vertex_program_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) => GLPointers._MapVertexAttrib2fAPPLE_fnptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
        }
        public static unsafe partial class ARB
        {
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Release resources consumed by the implementation's shader compiler. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml" /></remarks>
            public static void ReleaseShaderCompiler() => GLPointers._ReleaseShaderCompiler_fnptr();
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Load pre-compiled shader binaries. </summary>
            /// <param name="count"> Specifies the number of shader object handles contained in shaders. </param>
            /// <param name="shaders"> Specifies the address of an array of shader handles into which to load pre-compiled shader binaries. </param>
            /// <param name="binaryFormat"> Specifies the format of the shader binaries contained in binary. </param>
            /// <param name="binary"> Specifies the address of an array of bytes containing pre-compiled binary shader code. </param>
            /// <param name="length"> Specifies the length of the array whose address is given in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml" /></remarks>
            public static void ShaderBinary(int count, ShaderHandle* shaders, ShaderBinaryFormat binaryFormat, void* binary, int length) => GLPointers._ShaderBinary_fnptr(count, (int*)shaders, (uint)binaryFormat, binary, length);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Retrieve the range and precision for numeric formats supported by the shader compiler. </summary>
            /// <param name="shaderType"> Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="precisionType"> Specifies the numeric format whose precision and range to query. </param>
            /// <param name="range"> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned. </param>
            /// <param name="precision"> Specifies the address of an integer into which the numeric precision of the implementation is written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml" /></remarks>
            public static void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int* range, int* precision) => GLPointers._GetShaderPrecisionFormat_fnptr((uint)shadertype, (uint)precisiontype, range, precision);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Specify mapping of depth values from normalized device coordinates to window coordinates. </summary>
            /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml" /></remarks>
            public static void DepthRangef(float n, float f) => GLPointers._DepthRangef_fnptr(n, f);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_ES2_compatibility]</b> Specify the clear value for the depth buffer. </summary>
            /// <param name="depth"> Specifies the depth value used when the depth buffer is cleared. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearDepth.xhtml" /></remarks>
            public static void ClearDepthf(float d) => GLPointers._ClearDepthf_fnptr(d);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_ES3_1_compatibility]</b> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
            public static void MemoryBarrierByRegion(MemoryBarrierMask barriers) => GLPointers._MemoryBarrierByRegion_fnptr((uint)barriers);
            
            /// <summary> <b>[requires: GL_ARB_ES3_2_compatibility]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrimitiveBoundingBoxARB(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) => GLPointers._PrimitiveBoundingBoxARB_fnptr(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Draw multiple instances of a range of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="first"> Specifies the starting index in the enabled arrays. </param>
            /// <param name="count"> Specifies the number of indices to be rendered. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml" /></remarks>
            public static void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => GLPointers._DrawArraysInstancedBaseInstance_fnptr((uint)mode, first, count, instancecount, baseinstance);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Draw multiple instances of a set of elements with offset applied to instanced attributes. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the specified range of indices to be rendered. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, PrimitiveType type, void* indices, int instancecount, uint baseinstance) => GLPointers._DrawElementsInstancedBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, baseinstance);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_base_instance]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <param name="baseinstance"> Specifies the base instance for use in fetching instanced vertex attributes. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance) => GLPointers._DrawElementsInstancedBaseVertexBaseInstance_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex, baseinstance);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetTextureHandleARB(TextureHandle texture) => GLPointers._GetTextureHandleARB_fnptr((int)texture);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetTextureSamplerHandleARB(TextureHandle texture, SamplerHandle sampler) => GLPointers._GetTextureSamplerHandleARB_fnptr((int)texture, (int)sampler);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeTextureHandleResidentARB(ulong handle) => GLPointers._MakeTextureHandleResidentARB_fnptr(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeTextureHandleNonResidentARB(ulong handle) => GLPointers._MakeTextureHandleNonResidentARB_fnptr(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetImageHandleARB(TextureHandle texture, int level, bool layered, int layer, PixelFormat format) => GLPointers._GetImageHandleARB_fnptr((int)texture, level, (byte)(layered ? 1 : 0), layer, (uint)format);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeImageHandleResidentARB(ulong handle, All access) => GLPointers._MakeImageHandleResidentARB_fnptr(handle, (uint)access);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeImageHandleNonResidentARB(ulong handle) => GLPointers._MakeImageHandleNonResidentARB_fnptr(handle);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformHandleui64ARB(int location, ulong value) => GLPointers._UniformHandleui64ARB_fnptr(location, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformHandleui64vARB(int location, int count, ulong* value) => GLPointers._UniformHandleui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformHandleui64ARB(ProgramHandle program, int location, ulong value) => GLPointers._ProgramUniformHandleui64ARB_fnptr((int)program, location, value);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformHandleui64vARB(ProgramHandle program, int location, int count, ulong* values) => GLPointers._ProgramUniformHandleui64vARB_fnptr((int)program, location, count, values);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsTextureHandleResidentARB(ulong handle) => GLPointers._IsTextureHandleResidentARB_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsImageHandleResidentARB(ulong handle) => GLPointers._IsImageHandleResidentARB_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1ui64ARB(uint index, ulong x) => GLPointers._VertexAttribL1ui64ARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1ui64vARB(uint index, ulong* v) => GLPointers._VertexAttribL1ui64vARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribLui64vARB(uint index, VertexAttribEnum pname, ulong* parameters) => GLPointers._GetVertexAttribLui64vARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> Bind a user-defined varying out variable to a fragment shader color number and index. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to modify </param>
            /// <param name="colorNumber"> The color number to bind the user-defined varying out variable to </param>
            /// <param name="index"> The index of the color input to bind the user-defined varying out variable to </param>
            /// <param name="name"> The name of the user-defined varying out variable whose binding to modify </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml" /></remarks>
            public static void BindFragDataLocationIndexed(ProgramHandle program, uint colorNumber, uint index, byte* name) => GLPointers._BindFragDataLocationIndexed_fnptr((int)program, colorNumber, index, name);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_blend_func_extended]</b> Query the bindings of color indices to user-defined varying out variables. </summary>
            /// <param name="program"> The name of the program containing varying out variable whose binding to query </param>
            /// <param name="name"> The name of the user-defined varying out variable whose index to query </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml" /></remarks>
            public static int GetFragDataIndex(ProgramHandle program, byte* name) => GLPointers._GetFragDataIndex_fnptr((int)program, name);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_buffer_storage]</b> Creates and initializes a buffer object's immutable data    store. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
            public static void BufferStorage(BufferStorageTarget target, nint size, void* data, BufferStorageMask flags) => GLPointers._BufferStorage_fnptr((uint)target, size, data, (uint)flags);
            
            /// <summary> <b>[requires: GL_ARB_cl_event]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLSync CreateSyncFromCLeventARB(CLContext* context, CLEvent* @event, All flags) => (GLSync) GLPointers._CreateSyncFromCLeventARB_fnptr((IntPtr*)context, (IntPtr*)@event, (uint)flags);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> Fill a buffer object's data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
            public static void ClearBufferData(BufferStorageTarget target, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._ClearBufferData_fnptr((uint)target, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_clear_buffer_object]</b> Fill all or part of buffer object's data store with a fixed value. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object's data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
            public static void ClearBufferSubData(BufferTargetARB target, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._ClearBufferSubData_fnptr((uint)target, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> Fills all a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml" /></remarks>
            public static void ClearTexImage(TextureHandle texture, int level, PixelFormat format, PixelType type, void* data) => GLPointers._ClearTexImage_fnptr((int)texture, level, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_clear_texture]</b> Fills all or part of a texture image with a constant value. </summary>
            /// <param name="texture"> The name of an existing texture object containing the image to be cleared. </param>
            /// <param name="level"> The level of texture containing the region to be cleared. </param>
            /// <param name="xoffset"> The coordinate of the left edge of the region to be cleared. </param>
            /// <param name="yoffset"> The coordinate of the lower edge of the region to be cleared. </param>
            /// <param name="zoffset"> The coordinate of the front of the region to be cleared. </param>
            /// <param name="width"> The width of the region to be cleared. </param>
            /// <param name="height"> The height of the region to be cleared. </param>
            /// <param name="depth"> The depth of the region to be cleared. </param>
            /// <param name="format"> The format of the data whose address in memory is given by data. </param>
            /// <param name="type"> The type of the data whose address in memory is given by data. </param>
            /// <param name="data"> The address in memory of the data to be used to clear the specified region. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml" /></remarks>
            public static void ClearTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* data) => GLPointers._ClearTexSubImage_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_clip_control]</b> Control clip coordinate to window coordinate behavior. </summary>
            /// <param name="origin"> Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT. </param>
            /// <param name="depth"> Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml" /></remarks>
            public static void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => GLPointers._ClipControl_fnptr((uint)origin, (uint)depth);
            
            /// <summary> <b>[requires: GL_ARB_color_buffer_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClampColorARB(ClampColorTargetARB target, ClampColorModeARB clamp) => GLPointers._ClampColorARB_fnptr((uint)target, (uint)clamp);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> Launch one or more compute work groups. </summary>
            /// <param name="num_groups_x"> The number of work groups to be launched in the X dimension. </param>
            /// <param name="num_groups_y"> The number of work groups to be launched in the Y dimension. </param>
            /// <param name="num_groups_z"> The number of work groups to be launched in the Z dimension. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml" /></remarks>
            public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => GLPointers._DispatchCompute_fnptr(num_groups_x, num_groups_y, num_groups_z);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_compute_shader]</b> Launch one or more compute work groups using parameters stored in a buffer. </summary>
            /// <param name="indirect"> The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml" /></remarks>
            public static void DispatchComputeIndirect(IntPtr indirect) => GLPointers._DispatchComputeIndirect_fnptr(indirect);
            
            /// <summary> <b>[requires: GL_ARB_compute_variable_group_size]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DispatchComputeGroupSizeARB(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z) => GLPointers._DispatchComputeGroupSizeARB_fnptr(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_copy_buffer]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readTarget"> Specifies the target to which the source buffer object is bound for glCopyBufferSubData </param>
            /// <param name="writeTarget"> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
            public static void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._CopyBufferSubData_fnptr((uint)readTarget, (uint)writeTarget, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_copy_image]</b> Perform a raw data copy between two images. </summary>
            /// <param name="srcName"> The name of a texture or renderbuffer object from which to copy. </param>
            /// <param name="srcTarget"> The target representing the namespace of the source name srcName. </param>
            /// <param name="srcLevel"> The mipmap level to read from the source. </param>
            /// <param name="srcX"> The X coordinate of the left edge of the souce region to copy. </param>
            /// <param name="srcY"> The Y coordinate of the top edge of the souce region to copy. </param>
            /// <param name="srcZ"> The Z coordinate of the near edge of the souce region to copy. </param>
            /// <param name="dstName"> The name of a texture or renderbuffer object to which to copy. </param>
            /// <param name="dstTarget"> The target representing the namespace of the destination name dstName. </param>
            /// <param name="dstLevel">!!missing documentation!!</param>
            /// <param name="dstX"> The X coordinate of the left edge of the destination region. </param>
            /// <param name="dstY"> The Y coordinate of the top edge of the destination region. </param>
            /// <param name="dstZ"> The Z coordinate of the near edge of the destination region. </param>
            /// <param name="srcWidth"> The width of the region to be copied. </param>
            /// <param name="srcHeight"> The height of the region to be copied. </param>
            /// <param name="srcDepth"> The depth of the region to be copied. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml" /></remarks>
            public static void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers._CopyImageSubData_fnptr(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._DebugMessageControlARB_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageInsertARB(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._DebugMessageInsertARB_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageCallbackARB(IntPtr callback, void* userParam) => GLPointers._DebugMessageCallbackARB_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: GL_ARB_debug_output]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GetDebugMessageLogARB(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._GetDebugMessageLogARB_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create transform feedback objects. </summary>
            /// <param name="n"> Number of transform feedback objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new transform feedback objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml" /></remarks>
            public static void CreateTransformFeedbacks(int n, TransformFeedbackHandle* ids) => GLPointers._CreateTransformFeedbacks_fnptr(n, (int*)ids);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml" /></remarks>
            public static void TransformFeedbackBufferBase(TransformFeedbackHandle xfb, uint index, BufferHandle buffer) => GLPointers._TransformFeedbackBufferBase_fnptr((int)xfb, index, (int)buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a range within a buffer object to a transform feedback buffer object. </summary>
            /// <param name="xfb"> Name of the transform feedback buffer object. </param>
            /// <param name="index"> Index of the binding point within xfb. </param>
            /// <param name="buffer"> Name of the buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object. </param>
            /// <param name="size"> The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml" /></remarks>
            public static void TransformFeedbackBufferRange(TransformFeedbackHandle xfb, uint index, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._TransformFeedbackBufferRange_fnptr((int)xfb, index, (int)buffer, offset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbackiv(TransformFeedbackHandle xfb, TransformFeedbackPName pname, int* param) => GLPointers._GetTransformFeedbackiv_fnptr((int)xfb, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbacki_v(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, int* param) => GLPointers._GetTransformFeedbacki_v_fnptr((int)xfb, (uint)pname, index, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query the state of a transform feedback object.. </summary>
            /// <param name="xfb">The name of an existing transform feedback object, or zero for the default transform feedback object.</param>
            /// <param name="pname">Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE.</param>
            /// <param name="index">Index of the transform feedback stream (for indexed state).</param>
            /// <param name="param">The address of a buffer into which will be written the requested state information.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTransformFeedback.xhtml" /></remarks>
            public static void GetTransformFeedbacki64_v(TransformFeedbackHandle xfb, TransformFeedbackPName pname, uint index, long* param) => GLPointers._GetTransformFeedbacki64_v_fnptr((int)xfb, (uint)pname, index, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create buffer objects. </summary>
            /// <param name="n"> Specifies the number of buffer objects to create. </param>
            /// <param name="buffers"> Specifies an array in which names of the new buffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml" /></remarks>
            public static void CreateBuffers(int n, BufferHandle* buffers) => GLPointers._CreateBuffers_fnptr(n, (int*)buffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Creates and initializes a buffer object's immutable data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferStorage function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="flags">Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml" /></remarks>
            public static void NamedBufferStorage(BufferHandle buffer, nint size, void* data, BufferStorageMask flags) => GLPointers._NamedBufferStorage_fnptr((int)buffer, size, data, (uint)flags);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Creates and initializes a buffer object's data    store. </summary>
            /// <param name="buffer">Specifies the name of the buffer object for glNamedBufferData function.</param>
            /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
            /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
            /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" /></remarks>
            public static void NamedBufferData(BufferHandle buffer, nint size, void* data, VertexBufferObjectUsage usage) => GLPointers._NamedBufferData_fnptr((int)buffer, size, data, (uint)usage);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Updates a subset of a buffer object's data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being replaced. </param>
            /// <param name="data"> Specifies a pointer to the new data that will be copied into the data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml" /></remarks>
            public static void NamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, void* data) => GLPointers._NamedBufferSubData_fnptr((int)buffer, offset, size, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy all or part of the data store of a buffer object to the data store of another buffer object. </summary>
            /// <param name="readBuffer"> Specifies the name of the source buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="writeBuffer"> Specifies the name of the destination buffer object for glCopyNamedBufferSubData. </param>
            /// <param name="readOffset"> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read. </param>
            /// <param name="writeOffset"> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written. </param>
            /// <param name="size"> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml" /></remarks>
            public static void CopyNamedBufferSubData(BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._CopyNamedBufferSubData_fnptr((int)readBuffer, (int)writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Fill a buffer object's data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml" /></remarks>
            public static void ClearNamedBufferData(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._ClearNamedBufferData_fnptr((int)buffer, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Fill all or part of buffer object's data store with a fixed value. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glClearNamedBufferSubData. </param>
            /// <param name="internalformat"> The internal format with which the data will be stored in the buffer object. </param>
            /// <param name="offset"> The offset in basic machine units into the buffer object's data store at which to start filling. </param>
            /// <param name="size"> The size in basic machine units of the range of the data store to fill. </param>
            /// <param name="format"> The format of the data in memory addressed by data. </param>
            /// <param name="type"> The type of the data in memory addressed by data. </param>
            /// <param name="data"> The address of a memory location storing the data to be replicated into the buffer's data store. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml" /></remarks>
            public static void ClearNamedBufferSubData(BufferHandle buffer, SizedInternalFormat internalformat, IntPtr offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._ClearNamedBufferSubData_fnptr((int)buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Map all of a buffer object's data store into the client's address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBuffer. </param>
            /// <param name="access"> Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml" /></remarks>
            public static void* MapNamedBuffer(BufferHandle buffer, BufferAccessARB access) => GLPointers._MapNamedBuffer_fnptr((int)buffer, (uint)access);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Map all or part of a buffer object's data store into the client's address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glMapNamedBufferRange. </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
            public static void* MapNamedBufferRange(BufferHandle buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._MapNamedBufferRange_fnptr((int)buffer, offset, length, (uint)access);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Release the mapping of a buffer object's data store into the client's address space. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glUnmapNamedBuffer. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml" /></remarks>
            public static bool UnmapNamedBuffer(BufferHandle buffer) => GLPointers._UnmapNamedBuffer_fnptr((int)buffer) != 0;
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glFlushMappedNamedBufferRange. </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
            public static void FlushMappedNamedBufferRange(BufferHandle buffer, IntPtr offset, nint length) => GLPointers._FlushMappedNamedBufferRange_fnptr((int)buffer, offset, length);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
            public static void GetNamedBufferParameteriv(BufferHandle buffer, BufferPNameARB pname, int* parameters) => GLPointers._GetNamedBufferParameteriv_fnptr((int)buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a buffer object. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferParameteriv and glGetNamedBufferParameteri64v. </param>
            /// <param name="pname">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferParameter.xhtml" /></remarks>
            public static void GetNamedBufferParameteri64v(BufferHandle buffer, BufferPNameARB pname, long* parameters) => GLPointers._GetNamedBufferParameteri64v_fnptr((int)buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return the pointer to a mapped buffer object's data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferPointerv. </param>
            /// <param name="pname"> Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER. </param>
            /// <param name="parameters"> Returns the pointer value specified by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml" /></remarks>
            public static void GetNamedBufferPointerv(BufferHandle buffer, BufferPointerNameARB pname, void** parameters) => GLPointers._GetNamedBufferPointerv_fnptr((int)buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Returns a subset of a buffer object's data store. </summary>
            /// <param name="buffer"> Specifies the name of the buffer object for glGetNamedBufferSubData. </param>
            /// <param name="offset"> Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes. </param>
            /// <param name="size"> Specifies the size in bytes of the data store region being returned. </param>
            /// <param name="data"> Specifies a pointer to the location where buffer object data is returned. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml" /></remarks>
            public static void GetNamedBufferSubData(BufferHandle buffer, IntPtr offset, nint size, void* data) => GLPointers._GetNamedBufferSubData_fnptr((int)buffer, offset, size, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create framebuffer objects. </summary>
            /// <param name="n"> Number of framebuffer objects to create. </param>
            /// <param name="framebuffers"> Specifies an array in which names of the new framebuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml" /></remarks>
            public static void CreateFramebuffers(int n, FramebufferHandle* framebuffers) => GLPointers._CreateFramebuffers_fnptr(n, (int*)framebuffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
            public static void NamedFramebufferRenderbuffer(FramebufferHandle framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => GLPointers._NamedFramebufferRenderbuffer_fnptr((int)framebuffer, (uint)attachment, (uint)renderbuffertarget, (int)renderbuffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
            public static void NamedFramebufferParameteri(FramebufferHandle framebuffer, FramebufferParameterName pname, int param) => GLPointers._NamedFramebufferParameteri_fnptr((int)framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void NamedFramebufferTexture(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level) => GLPointers._NamedFramebufferTexture_fnptr((int)framebuffer, (uint)attachment, (int)texture, level);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glNamedFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
            public static void NamedFramebufferTextureLayer(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => GLPointers._NamedFramebufferTextureLayer_fnptr((int)framebuffer, (uint)attachment, (int)texture, level, layer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify which color buffers are to be drawn into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function. Must be zero or the name of a framebuffer object.</param>
            /// <param name="buf">For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml" /></remarks>
            public static void NamedFramebufferDrawBuffer(FramebufferHandle framebuffer, ColorBuffer buf) => GLPointers._NamedFramebufferDrawBuffer_fnptr((int)framebuffer, (uint)buf);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specifies a list of color buffers to be drawn    into. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers.</param>
            /// <param name="n">Specifies the number of buffers in bufs.</param>
            /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml" /></remarks>
            public static void NamedFramebufferDrawBuffers(FramebufferHandle framebuffer, int n, ColorBuffer* bufs) => GLPointers._NamedFramebufferDrawBuffers_fnptr((int)framebuffer, n, (uint*)bufs);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Select a color buffer source for pixels. </summary>
            /// <param name="framebuffer">Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function.</param>
            /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml" /></remarks>
            public static void NamedFramebufferReadBuffer(FramebufferHandle framebuffer, ColorBuffer src) => GLPointers._NamedFramebufferReadBuffer_fnptr((int)framebuffer, (uint)src);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Invalidate the content of some or all of a framebuffer's attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
            public static void InvalidateNamedFramebufferData(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments) => GLPointers._InvalidateNamedFramebufferData_fnptr((int)framebuffer, numAttachments, (uint*)attachments);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Invalidate the content of a region of some or all of a framebuffer's attachments. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glInvalidateNamedFramebufferSubData. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
            public static void InvalidateNamedFramebufferSubData(FramebufferHandle framebuffer, int numAttachments, FramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._InvalidateNamedFramebufferSubData_fnptr((int)framebuffer, numAttachments, (uint*)attachments, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferiv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, int* value) => GLPointers._ClearNamedFramebufferiv_fnptr((int)framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferuiv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, uint* value) => GLPointers._ClearNamedFramebufferuiv_fnptr((int)framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="value"> A pointer to the value or values to clear the buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferfv(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float* value) => GLPointers._ClearNamedFramebufferfv_fnptr((int)framebuffer, (uint)buffer, drawbuffer, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Clear individual buffers of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glClearNamedFramebuffer*. </param>
            /// <param name="buffer"> Specify the buffer to clear. </param>
            /// <param name="drawbuffer"> Specify a particular draw buffer to clear. </param>
            /// <param name="depth"> The value to clear the depth buffer to. </param>
            /// <param name="stencil"> The value to clear the stencil buffer to. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearBuffer.xhtml" /></remarks>
            public static void ClearNamedFramebufferfi(FramebufferHandle framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => GLPointers._ClearNamedFramebufferfi_fnptr((int)framebuffer, (uint)buffer, drawbuffer, depth, stencil);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="readFramebuffer"> Specifies the name of the source framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="drawFramebuffer"> Specifies the name of the destination framebuffer object for glBlitNamedFramebuffer. </param>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
            public static void BlitNamedFramebuffer(FramebufferHandle readFramebuffer, FramebufferHandle drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._BlitNamedFramebuffer_fnptr((int)readFramebuffer, (int)drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Check the completeness status of a framebuffer. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glCheckNamedFramebufferStatus </param>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
            public static FramebufferStatus CheckNamedFramebufferStatus(FramebufferHandle framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers._CheckNamedFramebufferStatus_fnptr((int)framebuffer, (uint)target);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query a named parameter of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="param">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
            public static void GetNamedFramebufferParameteriv(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* param) => GLPointers._GetNamedFramebufferParameteriv_fnptr((int)framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object for glGetNamedFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
            public static void GetNamedFramebufferAttachmentParameteriv(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._GetNamedFramebufferAttachmentParameteriv_fnptr((int)framebuffer, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create renderbuffer objects. </summary>
            /// <param name="n"> Number of renderbuffer objects to create. </param>
            /// <param name="renderbuffers"> Specifies an array in which names of the new renderbuffer objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml" /></remarks>
            public static void CreateRenderbuffers(int n, RenderbufferHandle* renderbuffers) => GLPointers._CreateRenderbuffers_fnptr(n, (int*)renderbuffers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Establish data storage, format and dimensions of a    renderbuffer object's image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorage function.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
            public static void NamedRenderbufferStorage(RenderbufferHandle renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers._NamedRenderbufferStorage_fnptr((int)renderbuffer, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object's image. </summary>
            /// <param name="renderbuffer">Specifies the name of the renderbuffer object for glNamedRenderbufferStorageMultisample function.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
            public static void NamedRenderbufferStorageMultisample(RenderbufferHandle renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers._NamedRenderbufferStorageMultisample_fnptr((int)renderbuffer, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object for glGetNamedRenderbufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
            public static void GetNamedRenderbufferParameteriv(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers._GetNamedRenderbufferParameteriv_fnptr((int)renderbuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create texture objects. </summary>
            /// <param name="target"> Specifies the effective texture target of each created texture. </param>
            /// <param name="n"> Number of texture objects to create. </param>
            /// <param name="textures"> Specifies an array in which names of the new texture objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml" /></remarks>
            public static void CreateTextures(TextureTarget target, int n, TextureHandle* textures) => GLPointers._CreateTextures_fnptr((uint)target, n, (int*)textures);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a buffer object's data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBuffer. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml" /></remarks>
            public static void TextureBuffer(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer) => GLPointers._TextureBuffer_fnptr((int)texture, (uint)internalformat, (int)buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach a range of a buffer object's data store to a buffer texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureBufferRange. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer's data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer's data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
            public static void TextureBufferRange(TextureHandle texture, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._TextureBufferRange_fnptr((int)texture, (uint)internalformat, (int)buffer, offset, size);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage1D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
            public static void TextureStorage1D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width) => GLPointers._TextureStorage1D_fnptr((int)texture, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
            public static void TextureStorage2D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._TextureStorage2D_fnptr((int)texture, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3D. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
            public static void TextureStorage3D(TextureHandle texture, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._TextureStorage3D_fnptr((int)texture, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage2DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
            public static void TextureStorage2DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._TextureStorage2DMultisample_fnptr((int)texture, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureStorage3DMultisample. The effective target of texture must be one of the valid non-proxy target values above. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
            public static void TextureStorage3DMultisample(TextureHandle texture, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._TextureStorage3DMultisample_fnptr((int)texture, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a one-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage1D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml" /></remarks>
            public static void TextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureSubImage1D_fnptr((int)texture, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a two-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage2D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml" /></remarks>
            public static void TextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureSubImage2D_fnptr((int)texture, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a three-dimensional texture subimage. </summary>
            /// <param name="texture"> Specifies the texture object name for glTextureSubImage3D. The effective target of texture must be one of the valid target values above. </param>
            /// <param name="level"> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="xoffset"> Specifies a texel offset in the x direction within the texture array. </param>
            /// <param name="yoffset"> Specifies a texel offset in the y direction within the texture array. </param>
            /// <param name="zoffset"> Specifies a texel offset in the z direction within the texture array. </param>
            /// <param name="width"> Specifies the width of the texture subimage. </param>
            /// <param name="height"> Specifies the height of the texture subimage. </param>
            /// <param name="depth"> Specifies the depth of the texture subimage. </param>
            /// <param name="format"> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX. </param>
            /// <param name="type"> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV. </param>
            /// <param name="pixels"> Specifies a pointer to the image data in memory. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml" /></remarks>
            public static void TextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureSubImage3D_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a one-dimensional texture subimage in a compressed    format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml" /></remarks>
            public static void CompressedTextureSubImage1D(TextureHandle texture, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTextureSubImage1D_fnptr((int)texture, level, xoffset, width, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a two-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml" /></remarks>
            public static void CompressedTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTextureSubImage2D_fnptr((int)texture, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify a three-dimensional texture subimage in a compressed format. </summary>
            /// <param name="texture">Specifies the texture object name for glCompressedTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">!!missing documentation!!</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
            /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
            /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml" /></remarks>
            public static void CompressedTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTextureSubImage3D_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a one-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage1D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml" /></remarks>
            public static void CopyTextureSubImage1D(TextureHandle texture, int level, int xoffset, int x, int y, int width) => GLPointers._CopyTextureSubImage1D_fnptr((int)texture, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a two-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage2D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml" /></remarks>
            public static void CopyTextureSubImage2D(TextureHandle texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._CopyTextureSubImage2D_fnptr((int)texture, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Copy a three-dimensional texture subimage. </summary>
            /// <param name="texture">Specifies the texture object name for glCopyTextureSubImage3D function.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml" /></remarks>
            public static void CopyTextureSubImage3D(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._CopyTextureSubImage3D_fnptr((int)texture, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterf(TextureHandle texture, TextureParameterName pname, float param) => GLPointers._TextureParameterf_fnptr((int)texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterfv(TextureHandle texture, TextureParameterName pname, float* param) => GLPointers._TextureParameterfv_fnptr((int)texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="param">For the scalar commands, specifies the value of pname.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameteri(TextureHandle texture, TextureParameterName pname, int param) => GLPointers._TextureParameteri_fnptr((int)texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterIiv(TextureHandle texture, TextureParameterName pname, int* parameters) => GLPointers._TextureParameterIiv_fnptr((int)texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameterIuiv(TextureHandle texture, TextureParameterName pname, uint* parameters) => GLPointers._TextureParameterIuiv_fnptr((int)texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Set texture parameters. </summary>
            /// <param name="texture">Specifies the texture object name for glTextureParameter functions.</param>
            /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
            /// <param name="parameters">For the vector commands, specifies a pointer to an array where the value or values of pname are stored.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" /></remarks>
            public static void TextureParameteriv(TextureHandle texture, TextureParameterName pname, int* param) => GLPointers._TextureParameteriv_fnptr((int)texture, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Generate mipmaps for a specified texture object. </summary>
            /// <param name="texture"> Specifies the texture object name for glGenerateTextureMipmap. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
            public static void GenerateTextureMipmap(TextureHandle texture) => GLPointers._GenerateTextureMipmap_fnptr((int)texture);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind an existing texture object to the specified texture unit . </summary>
            /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to. </param>
            /// <param name="texture">Specifies the name of a texture. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml" /></remarks>
            public static void BindTextureUnit(uint unit, TextureHandle texture) => GLPointers._BindTextureUnit_fnptr(unit, (int)texture);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return a texture image. </summary>
            /// <param name="texture"> Specifies the texture object name. </param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
            /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetnTexImage and glGetTextureImage functions.</param>
            /// <param name="pixels">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml" /></remarks>
            public static void GetTextureImage(TextureHandle texture, int level, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._GetTextureImage_fnptr((int)texture, level, (uint)format, (uint)type, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return a compressed texture image. </summary>
            /// <param name="texture">Specifies the texture object name for glGetCompressedTextureImage function.</param>
            /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
            /// <param name="bufSize">Specifies the size of the buffer pixels for glGetCompressedTextureImage and glGetnCompressedTexImage functions.</param>
            /// <param name="pixels">Returns the compressed texture image.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml" /></remarks>
            public static void GetCompressedTextureImage(TextureHandle texture, int level, int bufSize, void* pixels) => GLPointers._GetCompressedTextureImage_fnptr((int)texture, level, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
            public static void GetTextureLevelParameterfv(TextureHandle texture, int level, GetTextureParameter pname, float* parameters) => GLPointers._GetTextureLevelParameterfv_fnptr((int)texture, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values for a specific level of    detail. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureLevelParameterfv and glGetTextureLevelParameteriv functions.</param>
            /// <param name="level"> Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image. </param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexLevelParameter.xhtml" /></remarks>
            public static void GetTextureLevelParameteriv(TextureHandle texture, int level, GetTextureParameter pname, int* parameters) => GLPointers._GetTextureLevelParameteriv_fnptr((int)texture, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterfv(TextureHandle texture, GetTextureParameter pname, float* parameters) => GLPointers._GetTextureParameterfv_fnptr((int)texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterIiv(TextureHandle texture, GetTextureParameter pname, int* parameters) => GLPointers._GetTextureParameterIiv_fnptr((int)texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameterIuiv(TextureHandle texture, GetTextureParameter pname, uint* parameters) => GLPointers._GetTextureParameterIuiv_fnptr((int)texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return texture parameter values. </summary>
            /// <param name="texture">Specifies the texture object name for glGetTextureParameterfv, glGetTextureParameteriv, glGetTextureParameterIiv, and glGetTextureParameterIuiv functions.</param>
            /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
            /// <param name="parameters">Returns the texture parameters.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTexParameter.xhtml" /></remarks>
            public static void GetTextureParameteriv(TextureHandle texture, GetTextureParameter pname, int* parameters) => GLPointers._GetTextureParameteriv_fnptr((int)texture, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create vertex array objects. </summary>
            /// <param name="n"> Number of vertex array objects to create. </param>
            /// <param name="arrays"> Specifies an array in which names of the new vertex array objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml" /></remarks>
            public static void CreateVertexArrays(int n, VertexArrayHandle* arrays) => GLPointers._CreateVertexArrays_fnptr(n, (int*)arrays);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
            public static void DisableVertexArrayAttrib(VertexArrayHandle vaobj, uint index) => GLPointers._DisableVertexArrayAttrib_fnptr((int)vaobj, index);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Enable or disable a generic vertex attribute    array. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions.</param>
            /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" /></remarks>
            public static void EnableVertexArrayAttrib(VertexArrayHandle vaobj, uint index) => GLPointers._EnableVertexArrayAttrib_fnptr((int)vaobj, index);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Configures element array buffer binding of a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object. </param>
            /// <param name="buffer"> Specifies the name of the buffer object to use for the element array buffer binding. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml" /></remarks>
            public static void VertexArrayElementBuffer(VertexArrayHandle vaobj, BufferHandle buffer) => GLPointers._VertexArrayElementBuffer_fnptr((int)vaobj, (int)buffer);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function.</param>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
            public static void VertexArrayVertexBuffer(VertexArrayHandle vaobj, uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => GLPointers._VertexArrayVertexBuffer_fnptr((int)vaobj, bindingindex, (int)buffer, offset, stride);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayVertexBuffers. </param>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
            public static void VertexArrayVertexBuffers(VertexArrayHandle vaobj, uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides) => GLPointers._VertexArrayVertexBuffers_fnptr((int)vaobj, first, count, (int*)buffers, offsets, strides);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="vaobj"> Specifies the name of the vertex array object for glVertexArrayAttribBinding. </param>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
            public static void VertexArrayAttribBinding(VertexArrayHandle vaobj, uint attribindex, uint bindingindex) => GLPointers._VertexArrayAttribBinding_fnptr((int)vaobj, attribindex, bindingindex);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._VertexArrayAttribFormat_fnptr((int)vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribIFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._VertexArrayAttribIFormat_fnptr((int)vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions.</param>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexArrayAttribLFormat(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._VertexArrayAttribLFormat_fnptr((int)vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="vaobj">Specifies the name of the vertex array object for glVertexArrayBindingDivisor function.</param>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
            public static void VertexArrayBindingDivisor(VertexArrayHandle vaobj, uint bindingindex, uint divisor) => GLPointers._VertexArrayBindingDivisor_fnptr((int)vaobj, bindingindex, divisor);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of a vertex array object. </summary>
            /// <param name="vaobj">specifies the name of the vertex array object to use for the query.</param>
            /// <param name="pname">Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml" /></remarks>
            public static void GetVertexArrayiv(VertexArrayHandle vaobj, VertexArrayPName pname, int* param) => GLPointers._GetVertexArrayiv_fnptr((int)vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
            public static void GetVertexArrayIndexediv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers._GetVertexArrayIndexediv_fnptr((int)vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Retrieve parameters of an attribute of a vertex array    object. </summary>
            /// <param name="vaobj">Specifies the name of a vertex array object.</param>
            /// <param name="index">Specifies the index of the vertex array object attribute. Must be a number between 0 and (GL_MAX_VERTEX_ATTRIBS - 1).</param>
            /// <param name="pname">Specifies the property to be used for the query. For glGetVertexArrayIndexediv, it must be one of the following values: GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For glGetVertexArrayIndexed64v, it must be equal to GL_VERTEX_BINDING_OFFSET.</param>
            /// <param name="param">Returns the requested value.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed.xhtml" /></remarks>
            public static void GetVertexArrayIndexed64iv(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, long* param) => GLPointers._GetVertexArrayIndexed64iv_fnptr((int)vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create sampler objects. </summary>
            /// <param name="n"> Number of sampler objects to create. </param>
            /// <param name="samplers"> Specifies an array in which names of the new sampler objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml" /></remarks>
            public static void CreateSamplers(int n, SamplerHandle* samplers) => GLPointers._CreateSamplers_fnptr(n, (int*)samplers);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create program pipeline objects. </summary>
            /// <param name="n"> Number of program pipeline objects to create. </param>
            /// <param name="pipelines"> Specifies an array in which names of the new program pipeline objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml" /></remarks>
            public static void CreateProgramPipelines(int n, ProgramPipelineHandle* pipelines) => GLPointers._CreateProgramPipelines_fnptr(n, (int*)pipelines);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Create query objects. </summary>
            /// <param name="target"> Specifies the target of each created query object. </param>
            /// <param name="n"> Number of query objects to create. </param>
            /// <param name="ids"> Specifies an array in which names of the new query objects are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml" /></remarks>
            public static void CreateQueries(QueryTarget target, int n, QueryHandle* ids) => GLPointers._CreateQueries_fnptr((uint)target, n, (int*)ids);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjecti64v(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._GetQueryBufferObjecti64v_fnptr((int)id, (int)buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectiv(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._GetQueryBufferObjectiv_fnptr((int)id, (int)buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectui64v(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._GetQueryBufferObjectui64v_fnptr((int)id, (int)buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_direct_state_access]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="buffer"> Specifies the name of a buffer object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="offset"> Specifies the byte offset into buffer's data store where the queried result will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryBufferObjectuiv(QueryHandle id, BufferHandle buffer, QueryObjectParameterName pname, IntPtr offset) => GLPointers._GetQueryBufferObjectuiv_fnptr((int)id, (int)buffer, (uint)pname, offset);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawBuffersARB(int n, DrawBufferMode* bufs) => GLPointers._DrawBuffersARB_fnptr(n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationiARB(uint buf, BlendEquationModeEXT mode) => GLPointers._BlendEquationiARB_fnptr(buf, (uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationSeparateiARB(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._BlendEquationSeparateiARB_fnptr(buf, (uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFunciARB(uint buf, BlendingFactor src, BlendingFactor dst) => GLPointers._BlendFunciARB_fnptr(buf, (uint)src, (uint)dst);
            
            /// <summary> <b>[requires: GL_ARB_draw_buffers_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncSeparateiARB(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => GLPointers._BlendFuncSeparateiARB_fnptr(buf, (uint)srcRGB, (uint)dstRGB, (uint)srcAlpha, (uint)dstAlpha);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml" /></remarks>
            public static void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._DrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, basevertex);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="start"> Specifies the minimum array index contained in indices. </param>
            /// <param name="end"> Specifies the maximum array index contained in indices. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml" /></remarks>
            public static void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices, int basevertex) => GLPointers._DrawRangeElementsBaseVertex_fnptr((uint)mode, start, end, count, (uint)type, indices, basevertex);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render multiple instances of a set of primitives from array data with a per-element offset. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Specifies the number of elements to be rendered. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="instancecount"> Specifies the number of instances of the indexed geometry that should be drawn. </param>
            /// <param name="basevertex"> Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml" /></remarks>
            public static void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, void* indices, int instancecount, int basevertex) => GLPointers._DrawElementsInstancedBaseVertex_fnptr((uint)mode, count, (uint)type, indices, instancecount, basevertex);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_draw_elements_base_vertex]</b> Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted. </param>
            /// <param name="count"> Points to an array of the elements counts. </param>
            /// <param name="type"> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT. </param>
            /// <param name="indices"> Specifies a pointer to the location where the indices are stored. </param>
            /// <param name="drawcount"> Specifies the size of the count, indices and basevertex arrays. </param>
            /// <param name="basevertex"> Specifies a pointer to the location where the base vertices are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml" /></remarks>
            public static void MultiDrawElementsBaseVertex(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int drawcount, int* basevertex) => GLPointers._MultiDrawElementsBaseVertex_fnptr((uint)mode, count, (uint)type, indices, drawcount, basevertex);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> Render primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml" /></remarks>
            public static void DrawArraysIndirect(PrimitiveType mode, void* indirect) => GLPointers._DrawArraysIndirect_fnptr((uint)mode, indirect);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_draw_indirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing the draw parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml" /></remarks>
            public static void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect) => GLPointers._DrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect);
            
            /// <summary> <b>[requires: GL_ARB_draw_instanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawArraysInstancedARB(PrimitiveType mode, int first, int count, int primcount) => GLPointers._DrawArraysInstancedARB_fnptr((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_ARB_draw_instanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawElementsInstancedARB(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => GLPointers._DrawElementsInstancedARB_fnptr((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramStringARB(ProgramTarget target, ProgramFormat format, int len, void* str) => GLPointers._ProgramStringARB_fnptr((uint)target, (uint)format, len, str);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindProgramARB(ProgramTarget target, ProgramHandle program) => GLPointers._BindProgramARB_fnptr((uint)target, (int)program);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteProgramsARB(int n, ProgramHandle* programs) => GLPointers._DeleteProgramsARB_fnptr(n, (int*)programs);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenProgramsARB(int n, ProgramHandle* programs) => GLPointers._GenProgramsARB_fnptr(n, (int*)programs);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers._ProgramEnvParameter4dARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, double* parameters) => GLPointers._ProgramEnvParameter4dvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers._ProgramEnvParameter4fARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, float* parameters) => GLPointers._ProgramEnvParameter4fvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers._ProgramLocalParameter4dARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, double* parameters) => GLPointers._ProgramLocalParameter4dvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers._ProgramLocalParameter4fARB_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, float* parameters) => GLPointers._ProgramLocalParameter4fvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, double* parameters) => GLPointers._GetProgramEnvParameterdvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, float* parameters) => GLPointers._GetProgramEnvParameterfvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, double* parameters) => GLPointers._GetProgramLocalParameterdvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, float* parameters) => GLPointers._GetProgramLocalParameterfvARB_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramivARB(ProgramTarget target, ProgramPropertyARB pname, int* parameters) => GLPointers._GetProgramivARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramStringARB(ProgramTarget target, ProgramStringProperty pname, void* str) => GLPointers._GetProgramStringARB_fnptr((uint)target, (uint)pname, str);
            
            /// <summary> <b>[requires: GL_ARB_fragment_program | GL_ARB_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsProgramARB(ProgramHandle program) => GLPointers._IsProgramARB_fnptr((int)program) != 0;
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> Set a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferParameteri. </param>
            /// <param name="pname"> Specifies the framebuffer parameter to be modified. </param>
            /// <param name="param"> The new value for the parameter named pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml" /></remarks>
            public static void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers._FramebufferParameteri_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_framebuffer_no_attachments]</b> Query a named parameter of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv. </param>
            /// <param name="pname"> Specifies the parameter of the framebuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferParameter.xhtml" /></remarks>
            public static void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._GetFramebufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Determine if a name corresponds to a renderbuffer object. </summary>
            /// <param name="renderbuffer"> Specifies a value that may be the name of a renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml" /></remarks>
            public static bool IsRenderbuffer(RenderbufferHandle renderbuffer) => GLPointers._IsRenderbuffer_fnptr((int)renderbuffer) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Bind a renderbuffer to a renderbuffer target. </summary>
            /// <param name="target"> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of the renderbuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml" /></remarks>
            public static void BindRenderbuffer(RenderbufferTarget target, RenderbufferHandle renderbuffer) => GLPointers._BindRenderbuffer_fnptr((uint)target, (int)renderbuffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Delete renderbuffer objects. </summary>
            /// <param name="n"> Specifies the number of renderbuffer objects to be deleted. </param>
            /// <param name="renderbuffers"> A pointer to an array containing n renderbuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml" /></remarks>
            public static void DeleteRenderbuffers(int n, RenderbufferHandle* renderbuffers) => GLPointers._DeleteRenderbuffers_fnptr(n, (int*)renderbuffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate renderbuffer object names. </summary>
            /// <param name="n"> Specifies the number of renderbuffer object names to generate. </param>
            /// <param name="renderbuffers"> Specifies an array in which the generated renderbuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml" /></remarks>
            public static void GenRenderbuffers(int n, RenderbufferHandle* renderbuffers) => GLPointers._GenRenderbuffers_fnptr(n, (int*)renderbuffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Establish data storage, format and dimensions of a    renderbuffer object's image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml" /></remarks>
            public static void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers._RenderbufferStorage_fnptr((uint)target, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Query a named parameter of a renderbuffer object. </summary>
            /// <param name="target"> Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv. target must be GL_RENDERBUFFER. </param>
            /// <param name="pname"> Specifies the parameter of the renderbuffer object to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for the renderbuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetRenderbufferParameter.xhtml" /></remarks>
            public static void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers._GetRenderbufferParameteriv_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Determine if a name corresponds to a framebuffer object. </summary>
            /// <param name="framebuffer"> Specifies a value that may be the name of a framebuffer object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml" /></remarks>
            public static bool IsFramebuffer(FramebufferHandle framebuffer) => GLPointers._IsFramebuffer_fnptr((int)framebuffer) != 0;
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Bind a framebuffer to a framebuffer target. </summary>
            /// <param name="target"> Specifies the framebuffer target of the binding operation. </param>
            /// <param name="framebuffer"> Specifies the name of the framebuffer object to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml" /></remarks>
            public static void BindFramebuffer(FramebufferTarget target, FramebufferHandle framebuffer) => GLPointers._BindFramebuffer_fnptr((uint)target, (int)framebuffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Delete framebuffer objects. </summary>
            /// <param name="n"> Specifies the number of framebuffer objects to be deleted. </param>
            /// <param name="framebuffers"> A pointer to an array containing n framebuffer objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml" /></remarks>
            public static void DeleteFramebuffers(int n, FramebufferHandle* framebuffers) => GLPointers._DeleteFramebuffers_fnptr(n, (int*)framebuffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate framebuffer object names. </summary>
            /// <param name="n"> Specifies the number of framebuffer object names to generate. </param>
            /// <param name="ids"> Specifies an array in which the generated framebuffer object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml" /></remarks>
            public static void GenFramebuffers(int n, FramebufferHandle* framebuffers) => GLPointers._GenFramebuffers_fnptr(n, (int*)framebuffers);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Check the completeness status of a framebuffer. </summary>
            /// <param name="target"> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" /></remarks>
            public static FramebufferStatus CheckFramebufferStatus(FramebufferTarget target) => (FramebufferStatus) GLPointers._CheckFramebufferStatus_fnptr((uint)target);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => GLPointers._FramebufferTexture1D_fnptr((uint)target, (uint)attachment, (uint)textarget, (int)texture, level);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => GLPointers._FramebufferTexture2D_fnptr((uint)target, (uint)attachment, (uint)textarget, (int)texture, level);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a level of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="textarget"> For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml" /></remarks>
            public static void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset) => GLPointers._FramebufferTexture3D_fnptr((uint)target, (uint)attachment, (uint)textarget, (int)texture, level, zoffset);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a renderbuffer as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="renderbuffertarget"> Specifies the renderbuffer target. Must be GL_RENDERBUFFER. </param>
            /// <param name="renderbuffer"> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml" /></remarks>
            public static void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => GLPointers._FramebufferRenderbuffer_fnptr((uint)target, (uint)attachment, (uint)renderbuffertarget, (int)renderbuffer);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Retrieve information about attachments of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv. </param>
            /// <param name="attachment"> Specifies the attachment of the framebuffer object to query. </param>
            /// <param name="pname"> Specifies the parameter of attachment to query. </param>
            /// <param name="parameters"> Returns the value of parameter pname for attachment. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameter.xhtml" /></remarks>
            public static void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._GetFramebufferAttachmentParameteriv_fnptr((uint)target, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Generate mipmaps for a specified texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" /></remarks>
            public static void GenerateMipmap(TextureTarget target) => GLPointers._GenerateMipmap_fnptr((uint)target);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Copy a block of pixels from one framebuffer object to another. </summary>
            /// <param name="srcX0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY0"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcX1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="srcY1"> Specify the bounds of the source rectangle within the read buffer of the read framebuffer. </param>
            /// <param name="dstX0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY0"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstX1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="dstY1"> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer. </param>
            /// <param name="mask"> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. </param>
            /// <param name="filter"> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml" /></remarks>
            public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._BlitFramebuffer_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Establish data storage, format, dimensions and sample count of    a renderbuffer object's image. </summary>
            /// <param name="target">Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</param>
            /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
            /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
            /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
            /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml" /></remarks>
            public static void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers._RenderbufferStorageMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_framebuffer_object]</b> Attach a single layer of a texture object as a logical buffer of a framebuffer object. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer. </param>
            /// <param name="attachment"> Specifies the attachment point of the framebuffer. </param>
            /// <param name="texture"> Specifies the name of an existing texture object to attach. </param>
            /// <param name="level"> Specifies the mipmap level of the texture object to attach. </param>
            /// <param name="layer"> Specifies the layer of the texture object to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml" /></remarks>
            public static void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => GLPointers._FramebufferTextureLayer_fnptr((uint)target, (uint)attachment, (int)texture, level, layer);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameteriARB(ProgramHandle program, ProgramParameterPName pname, int value) => GLPointers._ProgramParameteriARB_fnptr((int)program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureARB(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level) => GLPointers._FramebufferTextureARB_fnptr((uint)target, (uint)attachment, (int)texture, level);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureLayerARB(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => GLPointers._FramebufferTextureLayerARB_fnptr((uint)target, (uint)attachment, (int)texture, level, layer);
            
            /// <summary> <b>[requires: GL_ARB_geometry_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureFaceARB(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, TextureTarget face) => GLPointers._FramebufferTextureFaceARB_fnptr((uint)target, (uint)attachment, (int)texture, level, (uint)face);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> Return a binary representation of a program object's compiled and linked executable source. </summary>
            /// <param name="program"> Specifies the name of a program object whose binary representation to retrieve. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given by binary. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of bytes written into binary. </param>
            /// <param name="binaryFormat"> Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL. </param>
            /// <param name="binary"> Specifies the address an array into which the GL will return program's binary representation. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml" /></remarks>
            public static void GetProgramBinary(ProgramHandle program, int bufSize, int* length, All* binaryFormat, void* binary) => GLPointers._GetProgramBinary_fnptr((int)program, bufSize, length, (uint*)binaryFormat, binary);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_get_program_binary]</b> Load a program object with a program binary. </summary>
            /// <param name="program"> Specifies the name of a program object into which to load a program binary. </param>
            /// <param name="binaryFormat"> Specifies the format of the binary data in binary. </param>
            /// <param name="binary"> Specifies the address an array containing the binary to be loaded into program. </param>
            /// <param name="length"> Specifies the number of bytes contained in binary. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml" /></remarks>
            public static void ProgramBinary(ProgramHandle program, All binaryFormat, void* binary, int length) => GLPointers._ProgramBinary_fnptr((int)program, (uint)binaryFormat, binary, length);
            
            /// <summary> <b>[requires: v4.1 | v4.1 | GL_ARB_get_program_binary | GL_ARB_separate_shader_objects]</b> Specify a parameter for a program object. </summary>
            /// <param name="program"> Specifies the name of a program object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the name of the parameter to modify. </param>
            /// <param name="value"> Specifies the new value of the parameter specified by pname for program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramParameter.xhtml" /></remarks>
            public static void ProgramParameteri(ProgramHandle program, ProgramParameterPName pname, int value) => GLPointers._ProgramParameteri_fnptr((int)program, (uint)pname, value);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> Retrieve a sub-region of a texture image from a texture    object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage.</param>
            /// <param name="height">Specifies the height of the texture subimage.</param>
            /// <param name="depth">Specifies the depth of the texture subimage.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.</param>
            /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml" /></remarks>
            public static void GetTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, void* pixels) => GLPointers._GetTextureSubImage_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, bufSize, pixels);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_get_texture_sub_image]</b> Retrieve a sub-region of a compressed texture image from a    compressed texture object. </summary>
            /// <param name="texture">Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.</param>
            /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.</param>
            /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
            /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
            /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
            /// <param name="width">Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="height">Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="depth">Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the offset is zero and the size equals the texture image size.</param>
            /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved pixel data.</param>
            /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array of the type specified by type.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml" /></remarks>
            public static void GetCompressedTextureSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) => GLPointers._GetCompressedTextureSubImage_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
            
            /// <summary> <b>[requires: GL_ARB_gl_spirv]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpecializeShaderARB(ShaderHandle shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) => GLPointers._SpecializeShaderARB_fnptr((int)shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1d(int location, double x) => GLPointers._Uniform1d_fnptr(location, x);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2d(int location, double x, double y) => GLPointers._Uniform2d_fnptr(location, x, y);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3d(int location, double x, double y, double z) => GLPointers._Uniform3d_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4d(int location, double x, double y, double z, double w) => GLPointers._Uniform4d_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1dv(int location, int count, double* value) => GLPointers._Uniform1dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2dv(int location, int count, double* value) => GLPointers._Uniform2dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3dv(int location, int count, double* value) => GLPointers._Uniform3dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4dv(int location, int count, double* value) => GLPointers._Uniform4dv_fnptr(location, count, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix2dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix3dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix4dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix2x3dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix2x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix2x4dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix2x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix3x2dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix3x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix3x4dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix3x4dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix4x2dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix4x2dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix4x3dv(int location, int count, bool transpose, double* value) => GLPointers._UniformMatrix4x3dv_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_gpu_shader_fp64]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetUniformdv(ProgramHandle program, int location, double* parameters) => GLPointers._GetUniformdv_fnptr((int)program, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64ARB(int location, long x) => GLPointers._Uniform1i64ARB_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64ARB(int location, long x, long y) => GLPointers._Uniform2i64ARB_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64ARB(int location, long x, long y, long z) => GLPointers._Uniform3i64ARB_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64ARB(int location, long x, long y, long z, long w) => GLPointers._Uniform4i64ARB_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64vARB(int location, int count, long* value) => GLPointers._Uniform1i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64vARB(int location, int count, long* value) => GLPointers._Uniform2i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64vARB(int location, int count, long* value) => GLPointers._Uniform3i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64vARB(int location, int count, long* value) => GLPointers._Uniform4i64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64ARB(int location, ulong x) => GLPointers._Uniform1ui64ARB_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64ARB(int location, ulong x, ulong y) => GLPointers._Uniform2ui64ARB_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64ARB(int location, ulong x, ulong y, ulong z) => GLPointers._Uniform3ui64ARB_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64ARB(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._Uniform4ui64ARB_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64vARB(int location, int count, ulong* value) => GLPointers._Uniform1ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64vARB(int location, int count, ulong* value) => GLPointers._Uniform2ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64vARB(int location, int count, ulong* value) => GLPointers._Uniform3ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64vARB(int location, int count, ulong* value) => GLPointers._Uniform4ui64vARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformi64vARB(ProgramHandle program, int location, long* parameters) => GLPointers._GetUniformi64vARB_fnptr((int)program, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformui64vARB(ProgramHandle program, int location, ulong* parameters) => GLPointers._GetUniformui64vARB_fnptr((int)program, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformi64vARB(ProgramHandle program, int location, int bufSize, long* parameters) => GLPointers._GetnUniformi64vARB_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformui64vARB(ProgramHandle program, int location, int bufSize, ulong* parameters) => GLPointers._GetnUniformui64vARB_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64ARB(ProgramHandle program, int location, long x) => GLPointers._ProgramUniform1i64ARB_fnptr((int)program, location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64ARB(ProgramHandle program, int location, long x, long y) => GLPointers._ProgramUniform2i64ARB_fnptr((int)program, location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64ARB(ProgramHandle program, int location, long x, long y, long z) => GLPointers._ProgramUniform3i64ARB_fnptr((int)program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64ARB(ProgramHandle program, int location, long x, long y, long z, long w) => GLPointers._ProgramUniform4i64ARB_fnptr((int)program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64vARB(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform1i64vARB_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64vARB(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform2i64vARB_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64vARB(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform3i64vARB_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64vARB(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform4i64vARB_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64ARB(ProgramHandle program, int location, ulong x) => GLPointers._ProgramUniform1ui64ARB_fnptr((int)program, location, x);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64ARB(ProgramHandle program, int location, ulong x, ulong y) => GLPointers._ProgramUniform2ui64ARB_fnptr((int)program, location, x, y);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64ARB(ProgramHandle program, int location, ulong x, ulong y, ulong z) => GLPointers._ProgramUniform3ui64ARB_fnptr((int)program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64ARB(ProgramHandle program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._ProgramUniform4ui64ARB_fnptr((int)program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64vARB(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform1ui64vARB_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64vARB(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform2ui64vARB_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64vARB(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform3ui64vARB_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_gpu_shader_int64]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64vARB(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform4ui64vARB_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> Set the blend color. </summary>
            /// <param name="red"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="green"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="blue"> specify the components of GL_BLEND_COLOR </param>
            /// <param name="alpha"> specify the components of GL_BLEND_COLOR </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendColor.xhtml" /></remarks>
            public static void BlendColor(float red, float green, float blue, float alpha) => GLPointers._BlendColor_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: v1.4 | GL_ARB_imaging]</b> Specify the equation used for both the RGB blend equation and the Alpha blend equation. </summary>
            /// <param name="mode"> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml" /></remarks>
            public static void BlendEquation(BlendEquationModeEXT mode) => GLPointers._BlendEquation_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_indirect_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysIndirectCountARB(PrimitiveType mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._MultiDrawArraysIndirectCountARB_fnptr((uint)mode, indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_indirect_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsIndirectCountARB(PrimitiveType mode, DrawElementsType type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._MultiDrawElementsIndirectCountARB_fnptr((uint)mode, (uint)type, indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_instanced_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribDivisorARB(uint index, uint divisor) => GLPointers._VertexAttribDivisorARB_fnptr(index, divisor);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_internalformat_query]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
            public static void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int* parameters) => GLPointers._GetInternalformativ_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_internalformat_query2]</b> Retrieve information about implementation-dependent support for internal formats. </summary>
            /// <param name="target"> Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="internalformat"> Specifies the internal format about which to retrieve information. </param>
            /// <param name="pname"> Specifies the type of information to query. </param>
            /// <param name="bufSize"> Specifies the maximum number of integers of the specified width that may be written to params by the function. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetInternalformat.xhtml" /></remarks>
            public static void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, long* parameters) => GLPointers._GetInternalformati64v_fnptr((uint)target, (uint)internalformat, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate a region of a texture image. </summary>
            /// <param name="texture"> The name of a texture object a subregion of which to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object within which the region resides. </param>
            /// <param name="xoffset"> The X offset of the region to be invalidated. </param>
            /// <param name="yoffset"> The Y offset of the region to be invalidated. </param>
            /// <param name="zoffset"> The Z offset of the region to be invalidated. </param>
            /// <param name="width"> The width of the region to be invalidated. </param>
            /// <param name="height"> The height of the region to be invalidated. </param>
            /// <param name="depth"> The depth of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml" /></remarks>
            public static void InvalidateTexSubImage(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => GLPointers._InvalidateTexSubImage_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the entirety a texture image. </summary>
            /// <param name="texture"> The name of a texture object to invalidate. </param>
            /// <param name="level"> The level of detail of the texture object to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml" /></remarks>
            public static void InvalidateTexImage(TextureHandle texture, int level) => GLPointers._InvalidateTexImage_fnptr((int)texture, level);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate a region of a buffer object's data store. </summary>
            /// <param name="buffer"> The name of a buffer object, a subrange of whose data store to invalidate. </param>
            /// <param name="offset"> The offset within the buffer's data store of the start of the range to be invalidated. </param>
            /// <param name="length"> The length of the range within the buffer's data store to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml" /></remarks>
            public static void InvalidateBufferSubData(BufferHandle buffer, IntPtr offset, nint length) => GLPointers._InvalidateBufferSubData_fnptr((int)buffer, offset, length);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of a buffer object's data store. </summary>
            /// <param name="buffer"> The name of a buffer object whose data store to invalidate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml" /></remarks>
            public static void InvalidateBufferData(BufferHandle buffer) => GLPointers._InvalidateBufferData_fnptr((int)buffer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of some or all of a framebuffer's attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml" /></remarks>
            public static void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments) => GLPointers._InvalidateFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_invalidate_subdata]</b> Invalidate the content of a region of some or all of a framebuffer's attachments. </summary>
            /// <param name="target"> Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer. </param>
            /// <param name="numAttachments"> Specifies the number of entries in the attachments array. </param>
            /// <param name="attachments"> Specifies a pointer to an array identifying the attachments to be invalidated. </param>
            /// <param name="x"> Specifies the X offset of the region to be invalidated. </param>
            /// <param name="y"> Specifies the Y offset of the region to be invalidated. </param>
            /// <param name="width"> Specifies the width of the region to be invalidated. </param>
            /// <param name="height"> Specifies the height of the region to be invalidated. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml" /></remarks>
            public static void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment* attachments, int x, int y, int width, int height) => GLPointers._InvalidateSubFramebuffer_fnptr((uint)target, numAttachments, (uint*)attachments, x, y, width, height);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> Map all or part of a buffer object's data store into the client's address space. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the starting offset within the buffer of the range to be mapped. </param>
            /// <param name="length"> Specifies the length of the range to be mapped. </param>
            /// <param name="access"> Specifies a combination of access flags indicating the desired access to the mapped range. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml" /></remarks>
            public static void* MapBufferRange(BufferTargetARB target, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._MapBufferRange_fnptr((uint)target, offset, length, (uint)access);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_map_buffer_range]</b> Indicate modifications to a range of a mapped buffer. </summary>
            /// <param name="target"> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table: </param>
            /// <param name="offset"> Specifies the start of the buffer subrange, in basic machine units. </param>
            /// <param name="length"> Specifies the length of the buffer subrange, in basic machine units. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml" /></remarks>
            public static void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, nint length) => GLPointers._FlushMappedBufferRange_fnptr((uint)target, offset, length);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CurrentPaletteMatrixARB(int index) => GLPointers._CurrentPaletteMatrixARB_fnptr(index);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixIndexubvARB(int size, byte* indices) => GLPointers._MatrixIndexubvARB_fnptr(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixIndexusvARB(int size, ushort* indices) => GLPointers._MatrixIndexusvARB_fnptr(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixIndexuivARB(int size, uint* indices) => GLPointers._MatrixIndexuivARB_fnptr(size, indices);
            
            /// <summary> <b>[requires: GL_ARB_matrix_palette]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixIndexPointerARB(int size, MatrixIndexPointerTypeARB type, int stride, void* pointer) => GLPointers._MatrixIndexPointerARB_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml" /></remarks>
            public static void BindBuffersBase(BufferTargetARB target, uint first, int count, BufferHandle* buffers) => GLPointers._BindBuffersBase_fnptr((uint)target, first, count, (int*)buffers);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind ranges of one or more buffer objects to a sequence of indexed buffer targets. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="first"> Specify the index of the first binding point within the array specified by target. </param>
            /// <param name="count"> Specify the number of contiguous binding points to which to bind buffers. </param>
            /// <param name="buffers"> A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL. </param>
            /// <param name="offsets"> A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <param name="sizes"> A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is NULL. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml" /></remarks>
            public static void BindBuffersRange(BufferTargetARB target, uint first, int count, BufferHandle* buffers, IntPtr* offsets, nint* sizes) => GLPointers._BindBuffersRange_fnptr((uint)target, first, count, (int*)buffers, offsets, sizes);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named textures to a sequence of consecutive texture units. </summary>
            /// <param name="first"> Specifies the first texture unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTextures.xhtml" /></remarks>
            public static void BindTextures(uint first, int count, TextureHandle* textures) => GLPointers._BindTextures_fnptr(first, count, (int*)textures);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named sampler objects to a sequence of consecutive sampler units. </summary>
            /// <param name="first"> Specifies the first sampler unit to which a sampler object is to be bound. </param>
            /// <param name="count"> Specifies the number of samplers to bind. </param>
            /// <param name="samplers"> Specifies the address of an array of names of existing sampler objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml" /></remarks>
            public static void BindSamplers(uint first, int count, SamplerHandle* samplers) => GLPointers._BindSamplers_fnptr(first, count, (int*)samplers);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Bind one or more named texture images to a sequence of consecutive image units. </summary>
            /// <param name="first"> Specifies the first image unit to which a texture is to be bound. </param>
            /// <param name="count"> Specifies the number of textures to bind. </param>
            /// <param name="textures"> Specifies the address of an array of names of existing texture objects. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml" /></remarks>
            public static void BindImageTextures(uint first, int count, TextureHandle* textures) => GLPointers._BindImageTextures_fnptr(first, count, (int*)textures);
            
            /// <summary> <b>[requires: v4.4 | GL_ARB_multi_bind]</b> Attach multiple buffer objects to a vertex array object. </summary>
            /// <param name="first"> Specifies the first vertex buffer binding point to which a buffer object is to be bound. </param>
            /// <param name="count"> Specifies the number of buffers to bind. </param>
            /// <param name="buffers"> Specifies the address of an array of names of existing buffer objects. </param>
            /// <param name="offsets"> Specifies the address of an array of offsets to associate with the binding points. </param>
            /// <param name="strides">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml" /></remarks>
            public static void BindVertexBuffers(uint first, int count, BufferHandle* buffers, IntPtr* offsets, int* strides) => GLPointers._BindVertexBuffers_fnptr(first, count, (int*)buffers, offsets, strides);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> Render multiple sets of primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="indirect"> Specifies the address of an array of structures containing the draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array of draw parameter structures. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml" /></remarks>
            public static void MultiDrawArraysIndirect(PrimitiveType mode, void* indirect, int drawcount, int stride) => GLPointers._MultiDrawArraysIndirect_fnptr((uint)mode, indirect, drawcount, stride);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_multi_draw_indirect]</b> Render indexed primitives from array data, taking parameters from memory. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="type"> Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding. </param>
            /// <param name="indirect"> Specifies the address of a structure containing an array of draw parameters. </param>
            /// <param name="drawcount"> Specifies the number of elements in the array addressed by indirect. </param>
            /// <param name="stride"> Specifies the distance in basic machine units between elements of the draw parameter array. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml" /></remarks>
            public static void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, void* indirect, int drawcount, int stride) => GLPointers._MultiDrawElementsIndirect_fnptr((uint)mode, (uint)type, indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_ARB_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleCoverageARB(float value, bool invert) => GLPointers._SampleCoverageARB_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveTextureARB(TextureUnit texture) => GLPointers._ActiveTextureARB_fnptr((uint)texture);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClientActiveTextureARB(TextureUnit texture) => GLPointers._ClientActiveTextureARB_fnptr((uint)texture);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1dARB(TextureUnit target, double s) => GLPointers._MultiTexCoord1dARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1dvARB(TextureUnit target, double* v) => GLPointers._MultiTexCoord1dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1fARB(TextureUnit target, float s) => GLPointers._MultiTexCoord1fARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1fvARB(TextureUnit target, float* v) => GLPointers._MultiTexCoord1fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1iARB(TextureUnit target, int s) => GLPointers._MultiTexCoord1iARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1ivARB(TextureUnit target, int* v) => GLPointers._MultiTexCoord1ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1sARB(TextureUnit target, short s) => GLPointers._MultiTexCoord1sARB_fnptr((uint)target, s);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1svARB(TextureUnit target, short* v) => GLPointers._MultiTexCoord1svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2dARB(TextureUnit target, double s, double t) => GLPointers._MultiTexCoord2dARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2dvARB(TextureUnit target, double* v) => GLPointers._MultiTexCoord2dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2fARB(TextureUnit target, float s, float t) => GLPointers._MultiTexCoord2fARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2fvARB(TextureUnit target, float* v) => GLPointers._MultiTexCoord2fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2iARB(TextureUnit target, int s, int t) => GLPointers._MultiTexCoord2iARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2ivARB(TextureUnit target, int* v) => GLPointers._MultiTexCoord2ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2sARB(TextureUnit target, short s, short t) => GLPointers._MultiTexCoord2sARB_fnptr((uint)target, s, t);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2svARB(TextureUnit target, short* v) => GLPointers._MultiTexCoord2svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3dARB(TextureUnit target, double s, double t, double r) => GLPointers._MultiTexCoord3dARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3dvARB(TextureUnit target, double* v) => GLPointers._MultiTexCoord3dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3fARB(TextureUnit target, float s, float t, float r) => GLPointers._MultiTexCoord3fARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3fvARB(TextureUnit target, float* v) => GLPointers._MultiTexCoord3fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3iARB(TextureUnit target, int s, int t, int r) => GLPointers._MultiTexCoord3iARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3ivARB(TextureUnit target, int* v) => GLPointers._MultiTexCoord3ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3sARB(TextureUnit target, short s, short t, short r) => GLPointers._MultiTexCoord3sARB_fnptr((uint)target, s, t, r);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3svARB(TextureUnit target, short* v) => GLPointers._MultiTexCoord3svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4dARB(TextureUnit target, double s, double t, double r, double q) => GLPointers._MultiTexCoord4dARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4dvARB(TextureUnit target, double* v) => GLPointers._MultiTexCoord4dvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4fARB(TextureUnit target, float s, float t, float r, float q) => GLPointers._MultiTexCoord4fARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4fvARB(TextureUnit target, float* v) => GLPointers._MultiTexCoord4fvARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4iARB(TextureUnit target, int s, int t, int r, int q) => GLPointers._MultiTexCoord4iARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4ivARB(TextureUnit target, int* v) => GLPointers._MultiTexCoord4ivARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4sARB(TextureUnit target, short s, short t, short r, short q) => GLPointers._MultiTexCoord4sARB_fnptr((uint)target, s, t, r, q);
            
            /// <summary> <b>[requires: GL_ARB_multitexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4svARB(TextureUnit target, short* v) => GLPointers._MultiTexCoord4svARB_fnptr((uint)target, v);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenQueriesARB(int n, QueryHandle* ids) => GLPointers._GenQueriesARB_fnptr(n, (int*)ids);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteQueriesARB(int n, QueryHandle* ids) => GLPointers._DeleteQueriesARB_fnptr(n, (int*)ids);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsQueryARB(QueryHandle id) => GLPointers._IsQueryARB_fnptr((int)id) != 0;
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginQueryARB(QueryTarget target, QueryHandle id) => GLPointers._BeginQueryARB_fnptr((uint)target, (int)id);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndQueryARB(QueryTarget target) => GLPointers._EndQueryARB_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryivARB(QueryTarget target, QueryParameterName pname, int* parameters) => GLPointers._GetQueryivARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryObjectivARB(QueryHandle id, QueryObjectParameterName pname, int* parameters) => GLPointers._GetQueryObjectivARB_fnptr((int)id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryObjectuivARB(QueryHandle id, QueryObjectParameterName pname, uint* parameters) => GLPointers._GetQueryObjectuivARB_fnptr((int)id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_parallel_shader_compile]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MaxShaderCompilerThreadsARB(uint count) => GLPointers._MaxShaderCompilerThreadsARB_fnptr(count);
            
            /// <summary> <b>[requires: GL_ARB_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfARB(PointParameterNameARB pname, float param) => GLPointers._PointParameterfARB_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ARB_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfvARB(PointParameterNameARB pname, float* parameters) => GLPointers._PointParameterfvARB_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.6 | GL_ARB_polygon_offset_clamp]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PolygonOffsetClamp(float factor, float units, float clamp) => GLPointers._PolygonOffsetClamp_fnptr(factor, units, clamp);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query a property of an interface in a program. </summary>
            /// <param name="program"> The name of a program object whose interface to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program to query. </param>
            /// <param name="pname"> The name of the parameter within programInterface to query. </param>
            /// <param name="parameters"> The address of a variable to retrieve the value of pname for the program interface. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInterface.xhtml" /></remarks>
            public static void GetProgramInterfaceiv(ProgramHandle program, ProgramInterface programInterface, ProgramInterfacePName pname, int* parameters) => GLPointers._GetProgramInterfaceiv_fnptr((int)program, (uint)programInterface, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the index of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the index of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml" /></remarks>
            public static uint GetProgramResourceIndex(ProgramHandle program, ProgramInterface programInterface, byte* name) => GLPointers._GetProgramResourceIndex_fnptr((int)program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the name of an indexed resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the indexed resource. </param>
            /// <param name="index"> The index of the resource within programInterface of program. </param>
            /// <param name="bufSize"> The size of the character array whose address is given by name. </param>
            /// <param name="length"> The address of a variable which will receive the length of the resource name. </param>
            /// <param name="name"> The address of a character array into which will be written the name of the resource. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml" /></remarks>
            public static void GetProgramResourceName(ProgramHandle program, ProgramInterface programInterface, uint index, int bufSize, int* length, byte* name) => GLPointers._GetProgramResourceName_fnptr((int)program, (uint)programInterface, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Retrieve values for multiple properties of a single active resource within a program object. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="index">!!missing documentation!!</param>
            /// <param name="propCount">!!missing documentation!!</param>
            /// <param name="props">!!missing documentation!!</param>
            /// <param name="bufSize">!!missing documentation!!</param>
            /// <param name="length">!!missing documentation!!</param>
            /// <param name="parameters">!!missing documentation!!</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResource.xhtml" /></remarks>
            public static void GetProgramResourceiv(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty* props, int count, int* length, int* parameters) => GLPointers._GetProgramResourceiv_fnptr((int)program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the location of a named resource within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml" /></remarks>
            public static int GetProgramResourceLocation(ProgramHandle program, ProgramInterface programInterface, byte* name) => GLPointers._GetProgramResourceLocation_fnptr((int)program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_program_interface_query]</b> Query the fragment color index of a named variable within a program. </summary>
            /// <param name="program"> The name of a program object whose resources to query. </param>
            /// <param name="programInterface"> A token identifying the interface within program containing the resource named name. </param>
            /// <param name="name"> The name of the resource to query the location of. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml" /></remarks>
            public static int GetProgramResourceLocationIndex(ProgramHandle program, ProgramInterface programInterface, byte* name) => GLPointers._GetProgramResourceLocationIndex_fnptr((int)program, (uint)programInterface, name);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_provoking_vertex]</b> Specifiy the vertex to be used as the source of data for flat shaded varyings. </summary>
            /// <param name="provokeMode"> Specifies the vertex to be used as the source of data for flat shaded varyings. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml" /></remarks>
            public static void ProvokingVertex(VertexProvokingMode mode) => GLPointers._ProvokingVertex_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatusARB() => (GraphicsResetStatus) GLPointers._GetGraphicsResetStatusARB_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnTexImageARB(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, void* img) => GLPointers._GetnTexImageARB_fnptr((uint)target, level, (uint)format, (uint)type, bufSize, img);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReadnPixelsARB(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._ReadnPixelsARB_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnCompressedTexImageARB(TextureTarget target, int lod, int bufSize, void* img) => GLPointers._GetnCompressedTexImageARB_fnptr((uint)target, lod, bufSize, img);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformfvARB(ProgramHandle program, int location, int bufSize, float* parameters) => GLPointers._GetnUniformfvARB_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformivARB(ProgramHandle program, int location, int bufSize, int* parameters) => GLPointers._GetnUniformivARB_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformuivARB(ProgramHandle program, int location, int bufSize, uint* parameters) => GLPointers._GetnUniformuivARB_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformdvARB(ProgramHandle program, int location, int bufSize, double* parameters) => GLPointers._GetnUniformdvARB_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferSampleLocationsfvARB(FramebufferTarget target, uint start, int count, float* v) => GLPointers._FramebufferSampleLocationsfvARB_fnptr((uint)target, start, count, v);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferSampleLocationsfvARB(FramebufferHandle framebuffer, uint start, int count, float* v) => GLPointers._NamedFramebufferSampleLocationsfvARB_fnptr((int)framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_ARB_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvaluateDepthValuesARB() => GLPointers._EvaluateDepthValuesARB_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_sample_shading]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MinSampleShadingARB(float value) => GLPointers._MinSampleShadingARB_fnptr(value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Generate sampler object names. </summary>
            /// <param name="n"> Specifies the number of sampler object names to generate. </param>
            /// <param name="samplers"> Specifies an array in which the generated sampler object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml" /></remarks>
            public static void GenSamplers(int count, SamplerHandle* samplers) => GLPointers._GenSamplers_fnptr(count, (int*)samplers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Delete named sampler objects. </summary>
            /// <param name="n"> Specifies the number of sampler objects to be deleted. </param>
            /// <param name="samplers"> Specifies an array of sampler objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml" /></remarks>
            public static void DeleteSamplers(int count, SamplerHandle* samplers) => GLPointers._DeleteSamplers_fnptr(count, (int*)samplers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Determine if a name corresponds to a sampler object. </summary>
            /// <param name="id"> Specifies a value that may be the name of a sampler object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSampler.xhtml" /></remarks>
            public static bool IsSampler(SamplerHandle sampler) => GLPointers._IsSampler_fnptr((int)sampler) != 0;
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Bind a named sampler to a texturing target. </summary>
            /// <param name="unit"> Specifies the index of the texture unit to which the sampler is bound. </param>
            /// <param name="sampler"> Specifies the name of a sampler. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindSampler.xhtml" /></remarks>
            public static void BindSampler(uint unit, SamplerHandle sampler) => GLPointers._BindSampler_fnptr(unit, (int)sampler);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameteri(SamplerHandle sampler, SamplerParameterI pname, int param) => GLPointers._SamplerParameteri_fnptr((int)sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameteriv(SamplerHandle sampler, SamplerParameterI pname, int* param) => GLPointers._SamplerParameteriv_fnptr((int)sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="param"> For the scalar commands, specifies the value of pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterf(SamplerHandle sampler, SamplerParameterF pname, float param) => GLPointers._SamplerParameterf_fnptr((int)sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterfv(SamplerHandle sampler, SamplerParameterF pname, float* param) => GLPointers._SamplerParameterfv_fnptr((int)sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterIiv(SamplerHandle sampler, SamplerParameterI pname, int* param) => GLPointers._SamplerParameterIiv_fnptr((int)sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Set sampler parameters. </summary>
            /// <param name="sampler"> Specifies the sampler object whose parameter to modify. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC. </param>
            /// <param name="parameters"> For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSamplerParameter.xhtml" /></remarks>
            public static void SamplerParameterIuiv(SamplerHandle sampler, SamplerParameterI pname, uint* param) => GLPointers._SamplerParameterIuiv_fnptr((int)sampler, (uint)pname, param);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameteriv(SamplerHandle sampler, SamplerParameterI pname, int* parameters) => GLPointers._GetSamplerParameteriv_fnptr((int)sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterIiv(SamplerHandle sampler, SamplerParameterI pname, int* parameters) => GLPointers._GetSamplerParameterIiv_fnptr((int)sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterfv(SamplerHandle sampler, SamplerParameterF pname, float* parameters) => GLPointers._GetSamplerParameterfv_fnptr((int)sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_sampler_objects]</b> Return sampler parameter values. </summary>
            /// <param name="sampler"> Specifies name of the sampler object from which to retrieve parameters. </param>
            /// <param name="pname"> Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted. </param>
            /// <param name="parameters"> Returns the sampler parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSamplerParameter.xhtml" /></remarks>
            public static void GetSamplerParameterIuiv(SamplerHandle sampler, SamplerParameterI pname, uint* parameters) => GLPointers._GetSamplerParameterIuiv_fnptr((int)sampler, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Bind stages of a program object to a program pipeline. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to which to bind stages from program. </param>
            /// <param name="stages"> Specifies a set of program stages to bind to the program pipeline object. </param>
            /// <param name="program"> Specifies the program object containing the shader executables to use in pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml" /></remarks>
            public static void UseProgramStages(ProgramPipelineHandle pipeline, UseProgramStageMask stages, ProgramHandle program) => GLPointers._UseProgramStages_fnptr((int)pipeline, (uint)stages, (int)program);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Set the active program object for a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the program pipeline object to set the active program object for. </param>
            /// <param name="program"> Specifies the program object to set as the active program pipeline object pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml" /></remarks>
            public static void ActiveShaderProgram(ProgramPipelineHandle pipeline, ProgramHandle program) => GLPointers._ActiveShaderProgram_fnptr((int)pipeline, (int)program);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Create a stand-alone program from an array of null-terminated source code strings. </summary>
            /// <param name="type"> Specifies the type of shader to create. </param>
            /// <param name="count"> Specifies the number of source code strings in the array strings. </param>
            /// <param name="strings"> Specifies the address of an array of pointers to source code strings from which to create the program object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShaderProgram.xhtml" /></remarks>
            public static ProgramHandle CreateShaderProgramv(ShaderType type, int count, byte** strings) => (ProgramHandle) GLPointers._CreateShaderProgramv_fnptr((uint)type, count, strings);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Bind a program pipeline to the current context. </summary>
            /// <param name="pipeline"> Specifies the name of the pipeline object to bind to the context. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml" /></remarks>
            public static void BindProgramPipeline(ProgramPipelineHandle pipeline) => GLPointers._BindProgramPipeline_fnptr((int)pipeline);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Delete program pipeline objects. </summary>
            /// <param name="n"> Specifies the number of program pipeline objects to delete. </param>
            /// <param name="pipelines"> Specifies an array of names of program pipeline objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml" /></remarks>
            public static void DeleteProgramPipelines(int n, ProgramPipelineHandle* pipelines) => GLPointers._DeleteProgramPipelines_fnptr(n, (int*)pipelines);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Reserve program pipeline object names. </summary>
            /// <param name="n"> Specifies the number of program pipeline object names to reserve. </param>
            /// <param name="pipelines"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml" /></remarks>
            public static void GenProgramPipelines(int n, ProgramPipelineHandle* pipelines) => GLPointers._GenProgramPipelines_fnptr(n, (int*)pipelines);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Determine if a name corresponds to a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies a value that may be the name of a program pipeline object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml" /></remarks>
            public static bool IsProgramPipeline(ProgramPipelineHandle pipeline) => GLPointers._IsProgramPipeline_fnptr((int)pipeline) != 0;
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Retrieve properties of a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object whose parameter retrieve. </param>
            /// <param name="pname"> Specifies the name of the parameter to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which will be written the value or values of pname for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipeline.xhtml" /></remarks>
            public static void GetProgramPipelineiv(ProgramPipelineHandle pipeline, PipelineParameterName pname, int* parameters) => GLPointers._GetProgramPipelineiv_fnptr((int)pipeline, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1i(ProgramHandle program, int location, int v0) => GLPointers._ProgramUniform1i_fnptr((int)program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1iv(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform1iv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1f(ProgramHandle program, int location, float v0) => GLPointers._ProgramUniform1f_fnptr((int)program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1fv(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform1fv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1d(ProgramHandle program, int location, double v0) => GLPointers._ProgramUniform1d_fnptr((int)program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1dv(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform1dv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1ui(ProgramHandle program, int location, uint v0) => GLPointers._ProgramUniform1ui_fnptr((int)program, location, v0);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform1uiv(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform1uiv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2i(ProgramHandle program, int location, int v0, int v1) => GLPointers._ProgramUniform2i_fnptr((int)program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2iv(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform2iv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2f(ProgramHandle program, int location, float v0, float v1) => GLPointers._ProgramUniform2f_fnptr((int)program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2fv(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform2fv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2d(ProgramHandle program, int location, double v0, double v1) => GLPointers._ProgramUniform2d_fnptr((int)program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2dv(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform2dv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2ui(ProgramHandle program, int location, uint v0, uint v1) => GLPointers._ProgramUniform2ui_fnptr((int)program, location, v0, v1);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform2uiv(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform2uiv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3i(ProgramHandle program, int location, int v0, int v1, int v2) => GLPointers._ProgramUniform3i_fnptr((int)program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3iv(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform3iv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3f(ProgramHandle program, int location, float v0, float v1, float v2) => GLPointers._ProgramUniform3f_fnptr((int)program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3fv(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform3fv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3d(ProgramHandle program, int location, double v0, double v1, double v2) => GLPointers._ProgramUniform3d_fnptr((int)program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3dv(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform3dv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3ui(ProgramHandle program, int location, uint v0, uint v1, uint v2) => GLPointers._ProgramUniform3ui_fnptr((int)program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform3uiv(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform3uiv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4i(ProgramHandle program, int location, int v0, int v1, int v2, int v3) => GLPointers._ProgramUniform4i_fnptr((int)program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4iv(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform4iv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4f(ProgramHandle program, int location, float v0, float v1, float v2, float v3) => GLPointers._ProgramUniform4f_fnptr((int)program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4fv(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform4fv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4d(ProgramHandle program, int location, double v0, double v1, double v2, double v3) => GLPointers._ProgramUniform4d_fnptr((int)program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4dv(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform4dv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4ui(ProgramHandle program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._ProgramUniform4ui_fnptr((int)program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniform4uiv(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform4uiv_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix2fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix3fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix4fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix2dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix3dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix4dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2x3fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix2x3fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3x2fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix3x2fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix2x4fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix2x4fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4x2fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix4x2fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix3x4fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix3x4fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Specify the value of a uniform variable for a specified program object. </summary>
            /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
            /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
            /// <param name="count"> For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. </param>
            /// <param name="transpose"> For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable. </param>
            /// <param name="value"> For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glProgramUniform.xhtml" /></remarks>
            public static void ProgramUniformMatrix4x3fv(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix4x3fv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x3dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix2x3dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x2dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix3x2dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x4dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix2x4dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x2dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix4x2dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x4dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix3x4dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x3dv(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix4x3dv_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Validate a program pipeline object against current GL state. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object to validate. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml" /></remarks>
            public static void ValidateProgramPipeline(ProgramPipelineHandle pipeline) => GLPointers._ValidateProgramPipeline_fnptr((int)pipeline);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_separate_shader_objects]</b> Retrieve the info log string from a program pipeline object. </summary>
            /// <param name="pipeline"> Specifies the name of a program pipeline object from which to retrieve the info log. </param>
            /// <param name="bufSize"> Specifies the maximum number of characters, including the null terminator, that may be written into infoLog. </param>
            /// <param name="length"> Specifies the address of a variable into which will be written the number of characters written into infoLog. </param>
            /// <param name="infoLog"> Specifies the address of an array of characters into which will be written the info log for pipeline. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml" /></remarks>
            public static void GetProgramPipelineInfoLog(ProgramPipelineHandle pipeline, int bufSize, int* length, byte* infoLog) => GLPointers._GetProgramPipelineInfoLog_fnptr((int)pipeline, bufSize, length, infoLog);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_atomic_counters]</b> Retrieve information about the set of active atomic counter buffers for a program. </summary>
            /// <param name="program"> The name of a program object from which to retrieve information. </param>
            /// <param name="bufferIndex"> Specifies index of an active atomic counter buffer. </param>
            /// <param name="pname"> Specifies which parameter of the atomic counter buffer to retrieve. </param>
            /// <param name="parameters"> Specifies the address of a variable into which to write the retrieved information. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml" /></remarks>
            public static void GetActiveAtomicCounterBufferiv(ProgramHandle program, uint bufferIndex, AtomicCounterBufferPName pname, int* parameters) => GLPointers._GetActiveAtomicCounterBufferiv_fnptr((int)program, bufferIndex, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> Bind a level of a texture to an image unit. </summary>
            /// <param name="unit"> Specifies the index of the image unit to which to bind the texture </param>
            /// <param name="texture"> Specifies the name of the texture to bind to the image unit. </param>
            /// <param name="level"> Specifies the level of the texture that is to be bound. </param>
            /// <param name="layered"> Specifies whether a layered texture binding is to be established. </param>
            /// <param name="layer"> If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise. </param>
            /// <param name="access"> Specifies a token indicating the type of access that will be performed on the image. </param>
            /// <param name="format"> Specifies the format that the elements of the image will be treated as for the purposes of formatted stores. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml" /></remarks>
            public static void BindImageTexture(uint unit, TextureHandle texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format) => GLPointers._BindImageTexture_fnptr(unit, (int)texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, (uint)format);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_shader_image_load_store]</b> Defines a barrier ordering memory transactions. </summary>
            /// <param name="barriers"> Specifies the barriers to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" /></remarks>
            public static void MemoryBarrier(MemoryBarrierMask barriers) => GLPointers._MemoryBarrier_fnptr((uint)barriers);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteObjectARB(GLHandleARB obj) => GLPointers._DeleteObjectARB_fnptr((IntPtr)obj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLHandleARB GetHandleARB(All pname) => (GLHandleARB) GLPointers._GetHandleARB_fnptr((uint)pname);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DetachObjectARB(GLHandleARB containerObj, GLHandleARB attachedObj) => GLPointers._DetachObjectARB_fnptr((IntPtr)containerObj, (IntPtr)attachedObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLHandleARB CreateShaderObjectARB(ShaderType shaderType) => (GLHandleARB) GLPointers._CreateShaderObjectARB_fnptr((uint)shaderType);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShaderSourceARB(GLHandleARB shaderObj, int count, byte** str, int* length) => GLPointers._ShaderSourceARB_fnptr((IntPtr)shaderObj, count, str, length);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompileShaderARB(GLHandleARB shaderObj) => GLPointers._CompileShaderARB_fnptr((IntPtr)shaderObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLHandleARB CreateProgramObjectARB() => (GLHandleARB) GLPointers._CreateProgramObjectARB_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AttachObjectARB(GLHandleARB containerObj, GLHandleARB obj) => GLPointers._AttachObjectARB_fnptr((IntPtr)containerObj, (IntPtr)obj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LinkProgramARB(GLHandleARB programObj) => GLPointers._LinkProgramARB_fnptr((IntPtr)programObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UseProgramObjectARB(GLHandleARB programObj) => GLPointers._UseProgramObjectARB_fnptr((IntPtr)programObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ValidateProgramARB(GLHandleARB programObj) => GLPointers._ValidateProgramARB_fnptr((IntPtr)programObj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1fARB(int location, float v0) => GLPointers._Uniform1fARB_fnptr(location, v0);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2fARB(int location, float v0, float v1) => GLPointers._Uniform2fARB_fnptr(location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3fARB(int location, float v0, float v1, float v2) => GLPointers._Uniform3fARB_fnptr(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4fARB(int location, float v0, float v1, float v2, float v3) => GLPointers._Uniform4fARB_fnptr(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1iARB(int location, int v0) => GLPointers._Uniform1iARB_fnptr(location, v0);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2iARB(int location, int v0, int v1) => GLPointers._Uniform2iARB_fnptr(location, v0, v1);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3iARB(int location, int v0, int v1, int v2) => GLPointers._Uniform3iARB_fnptr(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4iARB(int location, int v0, int v1, int v2, int v3) => GLPointers._Uniform4iARB_fnptr(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1fvARB(int location, int count, float* value) => GLPointers._Uniform1fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2fvARB(int location, int count, float* value) => GLPointers._Uniform2fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3fvARB(int location, int count, float* value) => GLPointers._Uniform3fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4fvARB(int location, int count, float* value) => GLPointers._Uniform4fvARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ivARB(int location, int count, int* value) => GLPointers._Uniform1ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ivARB(int location, int count, int* value) => GLPointers._Uniform2ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ivARB(int location, int count, int* value) => GLPointers._Uniform3ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ivARB(int location, int count, int* value) => GLPointers._Uniform4ivARB_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix2fvARB(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix2fvARB_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix3fvARB(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix3fvARB_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformMatrix4fvARB(int location, int count, bool transpose, float* value) => GLPointers._UniformMatrix4fvARB_fnptr(location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectParameterfvARB(GLHandleARB obj, All pname, float* parameters) => GLPointers._GetObjectParameterfvARB_fnptr((IntPtr)obj, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectParameterivARB(GLHandleARB obj, All pname, int* parameters) => GLPointers._GetObjectParameterivARB_fnptr((IntPtr)obj, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInfoLogARB(GLHandleARB obj, int maxLength, int* length, byte* infoLog) => GLPointers._GetInfoLogARB_fnptr((IntPtr)obj, maxLength, length, infoLog);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetAttachedObjectsARB(GLHandleARB containerObj, int maxCount, int* count, GLHandleARB* obj) => GLPointers._GetAttachedObjectsARB_fnptr((IntPtr)containerObj, maxCount, count, (IntPtr*)obj);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetUniformLocationARB(GLHandleARB programObj, byte* name) => GLPointers._GetUniformLocationARB_fnptr((IntPtr)programObj, name);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetActiveUniformARB(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, UniformType* type, byte* name) => GLPointers._GetActiveUniformARB_fnptr((IntPtr)programObj, index, maxLength, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformfvARB(GLHandleARB programObj, int location, float* parameters) => GLPointers._GetUniformfvARB_fnptr((IntPtr)programObj, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformivARB(GLHandleARB programObj, int location, int* parameters) => GLPointers._GetUniformivARB_fnptr((IntPtr)programObj, location, parameters);
            
            /// <summary> <b>[requires: GL_ARB_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetShaderSourceARB(GLHandleARB obj, int maxLength, int* length, byte* source) => GLPointers._GetShaderSourceARB_fnptr((IntPtr)obj, maxLength, length, source);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_shader_storage_buffer_object]</b> Change an active shader storage block binding. </summary>
            /// <param name="program"> The name of the program containing the block whose binding to change. </param>
            /// <param name="storageBlockIndex"> The index storage block within the program. </param>
            /// <param name="storageBlockBinding"> The index storage block binding to associate with the specified storage block. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml" /></remarks>
            public static void ShaderStorageBlockBinding(ProgramHandle program, uint storageBlockIndex, uint storageBlockBinding) => GLPointers._ShaderStorageBlockBinding_fnptr((int)program, storageBlockIndex, storageBlockBinding);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the location of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml" /></remarks>
            public static int GetSubroutineUniformLocation(ProgramHandle program, ShaderType shadertype, byte* name) => GLPointers._GetSubroutineUniformLocation_fnptr((int)program, (uint)shadertype, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the index of a subroutine uniform of a given shader stage within a program. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="name"> Specifies the name of the subroutine uniform whose index to query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml" /></remarks>
            public static uint GetSubroutineIndex(ProgramHandle program, ShaderType shadertype, byte* name) => GLPointers._GetSubroutineIndex_fnptr((int)program, (uint)shadertype, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query a property of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="pname"> Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH. </param>
            /// <param name="values"> Specifies the address of a into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniform.xhtml" /></remarks>
            public static void GetActiveSubroutineUniformiv(ProgramHandle program, ShaderType shadertype, uint index, SubroutineParameterName pname, int* values) => GLPointers._GetActiveSubroutineUniformiv_fnptr((int)program, (uint)shadertype, index, (uint)pname, values);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query the name of an active shader subroutine uniform. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable into which is written the number of characters copied into name. </param>
            /// <param name="name"> Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml" /></remarks>
            public static void GetActiveSubroutineUniformName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._GetActiveSubroutineUniformName_fnptr((int)program, (uint)shadertype, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Query the name of an active shader subroutine. </summary>
            /// <param name="program"> Specifies the name of the program containing the subroutine. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query the subroutine name. </param>
            /// <param name="index"> Specifies the index of the shader subroutine uniform. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in name. </param>
            /// <param name="length"> Specifies the address of a variable which is to receive the length of the shader subroutine uniform name. </param>
            /// <param name="name"> Specifies the address of an array into which the name of the shader subroutine uniform will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml" /></remarks>
            public static void GetActiveSubroutineName(ProgramHandle program, ShaderType shadertype, uint index, int bufSize, int* length, byte* name) => GLPointers._GetActiveSubroutineName_fnptr((int)program, (uint)shadertype, index, bufSize, length, name);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Load active subroutine uniforms. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="count"> Specifies the number of uniform indices stored in indices. </param>
            /// <param name="indices"> Specifies the address of an array holding the indices to load into the shader subroutine variables. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformSubroutines.xhtml" /></remarks>
            public static void UniformSubroutinesuiv(ShaderType shadertype, int count, uint* indices) => GLPointers._UniformSubroutinesuiv_fnptr((uint)shadertype, count, indices);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve the value of a subroutine uniform of a given shader stage of the current program. </summary>
            /// <param name="shadertype"> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="location"> Specifies the location of the subroutine uniform. </param>
            /// <param name="values"> Specifies the address of a variable to receive the value or values of the subroutine uniform. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformSubroutine.xhtml" /></remarks>
            public static void GetUniformSubroutineuiv(ShaderType shadertype, int location, uint* parameters) => GLPointers._GetUniformSubroutineuiv_fnptr((uint)shadertype, location, parameters);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_shader_subroutine]</b> Retrieve properties of a program object corresponding to a specified shader stage. </summary>
            /// <param name="program"> Specifies the name of the program containing shader stage. </param>
            /// <param name="shadertype"> Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER. </param>
            /// <param name="pname"> Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH. </param>
            /// <param name="values"> Specifies the address of a variable into which the queried value or values will be placed. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramStage.xhtml" /></remarks>
            public static void GetProgramStageiv(ProgramHandle program, ShaderType shadertype, ProgramStagePName pname, int* values) => GLPointers._GetProgramStageiv_fnptr((int)program, (uint)shadertype, (uint)pname, values);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedStringARB(All type, int namelen, byte* name, int stringlen, byte* str) => GLPointers._NamedStringARB_fnptr((uint)type, namelen, name, stringlen, str);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteNamedStringARB(int namelen, byte* name) => GLPointers._DeleteNamedStringARB_fnptr(namelen, name);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompileShaderIncludeARB(ShaderHandle shader, int count, byte** path, int* length) => GLPointers._CompileShaderIncludeARB_fnptr((int)shader, count, path, length);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsNamedStringARB(int namelen, byte* name) => GLPointers._IsNamedStringARB_fnptr(namelen, name) != 0;
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedStringARB(int namelen, byte* name, int bufSize, int* stringlen, byte* str) => GLPointers._GetNamedStringARB_fnptr(namelen, name, bufSize, stringlen, str);
            
            /// <summary> <b>[requires: GL_ARB_shading_language_include]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedStringivARB(int namelen, byte* name, All pname, int* parameters) => GLPointers._GetNamedStringivARB_fnptr(namelen, name, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferPageCommitmentARB(All target, IntPtr offset, nint size, bool commit) => GLPointers._BufferPageCommitmentARB_fnptr((uint)target, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferPageCommitmentEXT(BufferHandle buffer, IntPtr offset, nint size, bool commit) => GLPointers._NamedBufferPageCommitmentEXT_fnptr((int)buffer, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferPageCommitmentARB(BufferHandle buffer, IntPtr offset, nint size, bool commit) => GLPointers._NamedBufferPageCommitmentARB_fnptr((int)buffer, offset, size, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_ARB_sparse_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexPageCommitmentARB(All target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => GLPointers._TexPageCommitmentARB_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Create a new sync object and insert it into the GL command stream. </summary>
            /// <param name="condition"> Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. </param>
            /// <param name="flags"> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFenceSync.xhtml" /></remarks>
            public static GLSync FenceSync(SyncCondition condition, SyncBehaviorFlags flags) => (GLSync) GLPointers._FenceSync_fnptr((uint)condition, (uint)flags);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Determine if a name corresponds to a sync object. </summary>
            /// <param name="sync"> Specifies a value that may be the name of a sync object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsSync.xhtml" /></remarks>
            public static bool IsSync(GLSync sync) => GLPointers._IsSync_fnptr((IntPtr)sync) != 0;
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Delete a sync object. </summary>
            /// <param name="sync"> The sync object to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml" /></remarks>
            public static void DeleteSync(GLSync sync) => GLPointers._DeleteSync_fnptr((IntPtr)sync);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Block and wait for a sync object to become signaled. </summary>
            /// <param name="sync"> The sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT. </param>
            /// <param name="timeout"> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml" /></remarks>
            public static SyncStatus ClientWaitSync(GLSync sync, SyncObjectMask flags, ulong timeout) => (SyncStatus) GLPointers._ClientWaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Instruct the GL server to block until the specified sync object becomes signaled. </summary>
            /// <param name="sync"> Specifies the sync object whose status to wait on. </param>
            /// <param name="flags"> A bitfield controlling the command flushing behavior. flags may be zero. </param>
            /// <param name="timeout"> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glWaitSync.xhtml" /></remarks>
            public static void WaitSync(GLSync sync, SyncBehaviorFlags flags, ulong timeout) => GLPointers._WaitSync_fnptr((IntPtr)sync, (uint)flags, timeout);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="pname"> Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetInteger64v(GetPName pname, long* data) => GLPointers._GetInteger64v_fnptr((uint)pname, data);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_sync]</b> Query the properties of a sync object. </summary>
            /// <param name="sync"> Specifies the sync object whose properties to query. </param>
            /// <param name="pname"> Specifies the parameter whose value to retrieve from the sync object specified in sync. </param>
            /// <param name="bufSize"> Specifies the size of the buffer whose address is given in values. </param>
            /// <param name="length"> Specifies the address of an variable to receive the number of integers placed in values. </param>
            /// <param name="values"> Specifies the address of an array to receive the values of the queried parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetSync.xhtml" /></remarks>
            public static void GetSynciv(GLSync sync, SyncParameterName pname, int count, int* length, int* values) => GLPointers._GetSynciv_fnptr((IntPtr)sync, (uint)pname, count, length, values);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="value"> Specifies the new value for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
            public static void PatchParameteri(PatchParameterName pname, int value) => GLPointers._PatchParameteri_fnptr((uint)pname, value);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_tessellation_shader]</b> Specifies the parameters for patch primitives. </summary>
            /// <param name="pname"> Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted. </param>
            /// <param name="values"> Specifies the address of an array containing the new values for the parameter given by pname. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPatchParameter.xhtml" /></remarks>
            public static void PatchParameterfv(PatchParameterName pname, float* values) => GLPointers._PatchParameterfv_fnptr((uint)pname, values);
            
            /// <summary> <b>[requires: v4.5 | GL_ARB_texture_barrier]</b> Controls the ordering of reads and writes to rendered fragments across drawing commands. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml" /></remarks>
            public static void TextureBarrier() => GLPointers._TextureBarrier_fnptr();
            
            /// <summary> <b>[requires: GL_ARB_texture_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexBufferARB(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer) => GLPointers._TexBufferARB_fnptr((uint)target, (uint)internalformat, (int)buffer);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_buffer_range]</b> Attach a range of a buffer object's data store to a buffer texture object. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexBufferRange. Must be GL_TEXTURE_BUFFER. </param>
            /// <param name="internalformat"> Specifies the internal format of the data in the store belonging to buffer. </param>
            /// <param name="buffer"> Specifies the name of the buffer object whose storage to attach to the active buffer texture. </param>
            /// <param name="offset"> Specifies the offset of the start of the range of the buffer's data store to attach. </param>
            /// <param name="size"> Specifies the size of the range of the buffer's data store to attach. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml" /></remarks>
            public static void TexBufferRange(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._TexBufferRange_fnptr((uint)target, (uint)internalformat, (int)buffer, offset, size);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexImage3DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data) => GLPointers._CompressedTexImage3DARB_fnptr((uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexImage2DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* data) => GLPointers._CompressedTexImage2DARB_fnptr((uint)target, level, (uint)internalformat, width, height, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexImage1DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* data) => GLPointers._CompressedTexImage1DARB_fnptr((uint)target, level, (uint)internalformat, width, border, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexSubImage3DARB(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTexSubImage3DARB_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexSubImage2DARB(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTexSubImage2DARB_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTexSubImage1DARB(TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* data) => GLPointers._CompressedTexSubImage1DARB_fnptr((uint)target, level, xoffset, width, (uint)format, imageSize, data);
            
            /// <summary> <b>[requires: GL_ARB_texture_compression]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCompressedTexImageARB(TextureTarget target, int level, void* img) => GLPointers._GetCompressedTexImageARB_fnptr((uint)target, level, img);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture's image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> The number of samples in the multisample texture's image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture's image, in texels. </param>
            /// <param name="height"> The height of the multisample texture's image, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml" /></remarks>
            public static void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._TexImage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Establish the data storage, format, dimensions, and number of samples of a multisample texture's image. </summary>
            /// <param name="target"> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> The number of samples in the multisample texture's image. </param>
            /// <param name="internalformat"> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format. </param>
            /// <param name="width"> The width of the multisample texture's image, in texels. </param>
            /// <param name="height"> The height of the multisample texture's image, in texels. </param>
            /// <param name="depth">!!missing documentation!!</param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml" /></remarks>
            public static void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._TexImage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Retrieve the location of a sample. </summary>
            /// <param name="pname"> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION. </param>
            /// <param name="index"> Specifies the index of the sample whose position to query. </param>
            /// <param name="val"> Specifies the address of an array to receive the position of the sample. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetMultisample.xhtml" /></remarks>
            public static void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers._GetMultisamplefv_fnptr((uint)pname, index, val);
            
            /// <summary> <b>[requires: v3.2 | GL_ARB_texture_multisample]</b> Set the value of a sub-word of the sample mask. </summary>
            /// <param name="maskNumber"> Specifies which 32-bit sub-word of the sample mask to update. </param>
            /// <param name="mask"> Specifies the new value of the mask sub-word. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml" /></remarks>
            public static void SampleMaski(uint maskNumber, All mask) => GLPointers._SampleMaski_fnptr(maskNumber, (uint)mask);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a one-dimensional texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml" /></remarks>
            public static void TexStorage1D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._TexStorage1D_fnptr((uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml" /></remarks>
            public static void TexStorage2D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._TexStorage2D_fnptr((uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_texture_storage]</b> Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY. </param>
            /// <param name="levels"> Specify the number of texture levels. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in texels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml" /></remarks>
            public static void TexStorage3D(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._TexStorage3D_fnptr((uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> Specify storage for a two-dimensional multisample texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml" /></remarks>
            public static void TexStorage2DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._TexStorage2DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_storage_multisample]</b> Specify storage for a two-dimensional multisample array texture. </summary>
            /// <param name="target"> Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. </param>
            /// <param name="samples"> Specify the number of samples in the texture. </param>
            /// <param name="internalformat"> Specifies the sized internal format to be used to store texture image data. </param>
            /// <param name="width"> Specifies the width of the texture, in texels. </param>
            /// <param name="height"> Specifies the height of the texture, in texels. </param>
            /// <param name="depth"> Specifies the depth of the texture, in layers. </param>
            /// <param name="fixedsamplelocations"> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml" /></remarks>
            public static void TexStorage3DMultisample(TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._TexStorage3DMultisample_fnptr((uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_texture_view]</b> Initialize a texture as a data alias of another texture's data store. </summary>
            /// <param name="texture"> Specifies the texture object to be initialized as a view. </param>
            /// <param name="target"> Specifies the target to be used for the newly initialized texture. </param>
            /// <param name="origtexture"> Specifies the name of a texture object of which to make a view. </param>
            /// <param name="internalformat"> Specifies the internal format for the newly created view. </param>
            /// <param name="minlevel"> Specifies lowest level of detail of the view. </param>
            /// <param name="numlevels"> Specifies the number of levels of detail to include in the view. </param>
            /// <param name="minlayer"> Specifies the index of the first layer to include in the view. </param>
            /// <param name="numlayers"> Specifies the number of layers to include in the view. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTextureView.xhtml" /></remarks>
            public static void TextureView(TextureHandle texture, TextureTarget target, TextureHandle origtexture, SizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => GLPointers._TextureView_fnptr((int)texture, (uint)target, (int)origtexture, (uint)internalformat, minlevel, numlevels, minlayer, numlayers);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.. </summary>
            /// <param name="id"> Specify the name of a query object into which to record the GL time. </param>
            /// <param name="target"> Specify the counter to query. target must be GL_TIMESTAMP. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml" /></remarks>
            public static void QueryCounter(QueryHandle id, QueryCounterTarget target) => GLPointers._QueryCounter_fnptr((int)id, (uint)target);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryObjecti64v(QueryHandle id, QueryObjectParameterName pname, long* parameters) => GLPointers._GetQueryObjecti64v_fnptr((int)id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_timer_query]</b> Return parameters of a query object. </summary>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE. </param>
            /// <param name="parameters"> If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryObject.xhtml" /></remarks>
            public static void GetQueryObjectui64v(QueryHandle id, QueryObjectParameterName pname, ulong* parameters) => GLPointers._GetQueryObjectui64v_fnptr((int)id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Bind a transform feedback object. </summary>
            /// <param name="target"> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK. </param>
            /// <param name="id"> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml" /></remarks>
            public static void BindTransformFeedback(BindTransformFeedbackTarget target, TransformFeedbackHandle id) => GLPointers._BindTransformFeedback_fnptr((uint)target, (int)id);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Delete transform feedback objects. </summary>
            /// <param name="n"> Specifies the number of transform feedback objects to delete. </param>
            /// <param name="ids"> Specifies an array of names of transform feedback objects to delete. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml" /></remarks>
            public static void DeleteTransformFeedbacks(int n, TransformFeedbackHandle* ids) => GLPointers._DeleteTransformFeedbacks_fnptr(n, (int*)ids);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Reserve transform feedback object names. </summary>
            /// <param name="n"> Specifies the number of transform feedback object names to reserve. </param>
            /// <param name="ids"> Specifies an array of into which the reserved names will be written. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml" /></remarks>
            public static void GenTransformFeedbacks(int n, TransformFeedbackHandle* ids) => GLPointers._GenTransformFeedbacks_fnptr(n, (int*)ids);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Determine if a name corresponds to a transform feedback object. </summary>
            /// <param name="id"> Specifies a value that may be the name of a transform feedback object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml" /></remarks>
            public static bool IsTransformFeedback(TransformFeedbackHandle id) => GLPointers._IsTransformFeedback_fnptr((int)id) != 0;
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Pause transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml" /></remarks>
            public static void PauseTransformFeedback() => GLPointers._PauseTransformFeedback_fnptr();
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Resume transform feedback operations. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml" /></remarks>
            public static void ResumeTransformFeedback() => GLPointers._ResumeTransformFeedback_fnptr();
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback2]</b> Render primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml" /></remarks>
            public static void DrawTransformFeedback(PrimitiveType mode, TransformFeedbackHandle id) => GLPointers._DrawTransformFeedback_fnptr((uint)mode, (int)id);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Render primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml" /></remarks>
            public static void DrawTransformFeedbackStream(PrimitiveType mode, TransformFeedbackHandle id, uint stream) => GLPointers._DrawTransformFeedbackStream_fnptr((uint)mode, (int)id, stream);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <param name="id"> Specifies the name of a query object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
            public static void BeginQueryIndexed(QueryTarget target, uint index, QueryHandle id) => GLPointers._BeginQueryIndexed_fnptr((uint)target, index, (int)id);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Delimit the boundaries of a query object on an indexed target. </summary>
            /// <param name="target"> Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. </param>
            /// <param name="index"> Specifies the index of the query target upon which to begin the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml" /></remarks>
            public static void EndQueryIndexed(QueryTarget target, uint index) => GLPointers._EndQueryIndexed_fnptr((uint)target, index);
            
            /// <summary> <b>[requires: v4.0 | GL_ARB_transform_feedback3]</b> Return parameters of an indexed query object target. </summary>
            /// <param name="target"> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP. </param>
            /// <param name="index"> Specifies the index of the query object target. </param>
            /// <param name="pname"> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS. </param>
            /// <param name="parameters"> Returns the requested data. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetQueryIndexed.xhtml" /></remarks>
            public static void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int* parameters) => GLPointers._GetQueryIndexediv_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> Render multiple instances of primitives using a count derived from a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml" /></remarks>
            public static void DrawTransformFeedbackInstanced(PrimitiveType mode, TransformFeedbackHandle id, int instancecount) => GLPointers._DrawTransformFeedbackInstanced_fnptr((uint)mode, (int)id, instancecount);
            
            /// <summary> <b>[requires: v4.2 | GL_ARB_transform_feedback_instanced]</b> Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object. </summary>
            /// <param name="mode"> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted. </param>
            /// <param name="id"> Specifies the name of a transform feedback object from which to retrieve a primitive count. </param>
            /// <param name="stream"> Specifies the index of the transform feedback stream from which to retrieve a primitive count. </param>
            /// <param name="instancecount"> Specifies the number of instances of the geometry to render. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml" /></remarks>
            public static void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, TransformFeedbackHandle id, uint stream, int instancecount) => GLPointers._DrawTransformFeedbackStreamInstanced_fnptr((uint)mode, (int)id, stream, instancecount);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadTransposeMatrixfARB(float* m) => GLPointers._LoadTransposeMatrixfARB_fnptr(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadTransposeMatrixdARB(double* m) => GLPointers._LoadTransposeMatrixdARB_fnptr(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultTransposeMatrixfARB(float* m) => GLPointers._MultTransposeMatrixfARB_fnptr(m);
            
            /// <summary> <b>[requires: GL_ARB_transpose_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultTransposeMatrixdARB(double* m) => GLPointers._MultTransposeMatrixdARB_fnptr(m);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing uniforms whose indices to query. </param>
            /// <param name="uniformCount"> Specifies the number of uniforms whose indices to query. </param>
            /// <param name="uniformNames"> Specifies the address of an array of pointers to buffers containing the names of the queried uniforms. </param>
            /// <param name="uniformIndices"> Specifies the address of an array that will receive the indices of the uniforms. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml" /></remarks>
            public static void GetUniformIndices(ProgramHandle program, int uniformCount, byte** uniformNames, uint* uniformIndices) => GLPointers._GetUniformIndices_fnptr((int)program, uniformCount, uniformNames, uniformIndices);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Returns information about several active uniform variables for the specified program object. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
            /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.</param>
            /// <param name="pname">Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.</param>
            /// <param name="parameters">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml" /></remarks>
            public static void GetActiveUniformsiv(ProgramHandle program, int uniformCount, uint* uniformIndices, UniformPName pname, int* parameters) => GLPointers._GetActiveUniformsiv_fnptr((int)program, uniformCount, uniformIndices, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Query the name of an active uniform. </summary>
            /// <param name="program"> Specifies the program containing the active uniform index uniformIndex. </param>
            /// <param name="uniformIndex"> Specifies the index of the active uniform whose name to query. </param>
            /// <param name="bufSize"> Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName. </param>
            /// <param name="length"> Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName. </param>
            /// <param name="uniformName"> Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml" /></remarks>
            public static void GetActiveUniformName(ProgramHandle program, uint uniformIndex, int bufSize, int* length, byte* uniformName) => GLPointers._GetActiveUniformName_fnptr((int)program, uniformIndex, bufSize, length, uniformName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the index of a named uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml" /></remarks>
            public static uint GetUniformBlockIndex(ProgramHandle program, byte* uniformBlockName) => GLPointers._GetUniformBlockIndex_fnptr((int)program, uniformBlockName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Query information about an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="pname"> Specifies the name of the parameter to query. </param>
            /// <param name="parameters"> Specifies the address of a variable to receive the result of the query. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlock.xhtml" /></remarks>
            public static void GetActiveUniformBlockiv(ProgramHandle program, uint uniformBlockIndex, UniformBlockPName pname, int* parameters) => GLPointers._GetActiveUniformBlockiv_fnptr((int)program, uniformBlockIndex, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Retrieve the name of an active uniform block. </summary>
            /// <param name="program"> Specifies the name of a program containing the uniform block. </param>
            /// <param name="uniformBlockIndex"> Specifies the index of the uniform block within program. </param>
            /// <param name="bufSize"> Specifies the size of the buffer addressed by uniformBlockName. </param>
            /// <param name="length"> Specifies the address of a variable to receive the number of characters that were written to uniformBlockName. </param>
            /// <param name="uniformBlockName"> Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml" /></remarks>
            public static void GetActiveUniformBlockName(ProgramHandle program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) => GLPointers._GetActiveUniformBlockName_fnptr((int)program, uniformBlockIndex, bufSize, length, uniformBlockName);
            
            /// <summary> <b>[requires: v3.1 | GL_ARB_uniform_buffer_object]</b> Assign a binding point to an active uniform block. </summary>
            /// <param name="program"> The name of a program object containing the active uniform block whose binding to assign. </param>
            /// <param name="uniformBlockIndex"> The index of the active uniform block within program whose binding to assign. </param>
            /// <param name="uniformBlockBinding"> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml" /></remarks>
            public static void UniformBlockBinding(ProgramHandle program, uint uniformBlockIndex, uint uniformBlockBinding) => GLPointers._UniformBlockBinding_fnptr((int)program, uniformBlockIndex, uniformBlockBinding);
            
            /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Bind a range within a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <param name="offset"> The starting offset in basic machine units into the buffer object buffer. </param>
            /// <param name="size"> The amount of data in machine units that can be read from the buffer object while used as an indexed target. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml" /></remarks>
            public static void BindBufferRange(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._BindBufferRange_fnptr((uint)target, index, (int)buffer, offset, size);
            
            /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Bind a buffer object to an indexed buffer target. </summary>
            /// <param name="target"> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. </param>
            /// <param name="index"> Specify the index of the binding point within the array specified by target. </param>
            /// <param name="buffer"> The name of a buffer object to bind to the specified binding point. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml" /></remarks>
            public static void BindBufferBase(BufferTargetARB target, uint index, BufferHandle buffer) => GLPointers._BindBufferBase_fnptr((uint)target, index, (int)buffer);
            
            /// <summary> <b>[requires: v3.0 | v3.1 | GL_ARB_uniform_buffer_object]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetIntegeri_v(GetPName target, uint index, int* data) => GLPointers._GetIntegeri_v_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Bind a vertex array object. </summary>
            /// <param name="array"> Specifies the name of the vertex array to bind. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" /></remarks>
            public static void BindVertexArray(VertexArrayHandle array) => GLPointers._BindVertexArray_fnptr((int)array);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Delete vertex array objects. </summary>
            /// <param name="n"> Specifies the number of vertex array objects to be deleted. </param>
            /// <param name="arrays"> Specifies the address of an array containing the n names of the objects to be deleted. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml" /></remarks>
            public static void DeleteVertexArrays(int n, VertexArrayHandle* arrays) => GLPointers._DeleteVertexArrays_fnptr(n, (int*)arrays);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Generate vertex array object names. </summary>
            /// <param name="n"> Specifies the number of vertex array object names to generate. </param>
            /// <param name="arrays"> Specifies an array in which the generated vertex array object names are stored. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" /></remarks>
            public static void GenVertexArrays(int n, VertexArrayHandle* arrays) => GLPointers._GenVertexArrays_fnptr(n, (int*)arrays);
            
            /// <summary> <b>[requires: v3.0 | GL_ARB_vertex_array_object]</b> Determine if a name corresponds to a vertex array object. </summary>
            /// <param name="array"> Specifies a value that may be the name of a vertex array object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml" /></remarks>
            public static bool IsVertexArray(VertexArrayHandle array) => GLPointers._IsVertexArray_fnptr((int)array) != 0;
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL1d(uint index, double x) => GLPointers._VertexAttribL1d_fnptr(index, x);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL2d(uint index, double x, double y) => GLPointers._VertexAttribL2d_fnptr(index, x, y);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL3d(uint index, double x, double y, double z) => GLPointers._VertexAttribL3d_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v0"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v1"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v2"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <param name="v3"> For the scalar commands, specifies the new values to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL4d(uint index, double x, double y, double z, double w) => GLPointers._VertexAttribL4d_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL1dv(uint index, double* v) => GLPointers._VertexAttribL1dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL2dv(uint index, double* v) => GLPointers._VertexAttribL2dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL3dv(uint index, double* v) => GLPointers._VertexAttribL3dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="v"> For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribL4dv(uint index, double* v) => GLPointers._VertexAttribL4dv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Define an array of generic vertex attribute data. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
            /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
            /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
            /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" /></remarks>
            public static void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers._VertexAttribLPointer_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_vertex_attrib_64bit]</b> Return a generic vertex attribute parameter. </summary>
            /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
            /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_LONG, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_BINDING, GL_VERTEX_ATTRIB_RELATIVE_OFFSET or GL_CURRENT_VERTEX_ATTRIB.</param>
            /// <param name="parameters">Returns the requested data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetVertexAttrib.xhtml" /></remarks>
            public static void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double* parameters) => GLPointers._GetVertexAttribLdv_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Bind a buffer to a vertex buffer bind point. </summary>
            /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
            /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding point.</param>
            /// <param name="offset">The offset of the first element of the buffer.</param>
            /// <param name="stride">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml" /></remarks>
            public static void BindVertexBuffer(uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => GLPointers._BindVertexBuffer_fnptr(bindingindex, (int)buffer, offset, stride);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="normalized"> Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED. </param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._VertexAttribFormat_fnptr(attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._VertexAttribIFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Specify the organization of vertex arrays. </summary>
            /// <param name="attribindex">The generic vertex attribute array being described.</param>
            /// <param name="size">The number of values per vertex that are stored in the array.</param>
            /// <param name="type">The type of the data stored in the array.</param>
            /// <param name="relativeoffset">The distance between elements within the buffer.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml" /></remarks>
            public static void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._VertexAttribLFormat_fnptr(attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Associate a vertex attribute and a vertex buffer binding for a vertex array object. </summary>
            /// <param name="attribindex"> The index of the attribute to associate with a vertex buffer binding. </param>
            /// <param name="bindingindex"> The index of the vertex buffer binding with which to associate the generic vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml" /></remarks>
            public static void VertexAttribBinding(uint attribindex, uint bindingindex) => GLPointers._VertexAttribBinding_fnptr(attribindex, bindingindex);
            
            /// <summary> <b>[requires: v4.3 | GL_ARB_vertex_attrib_binding]</b> Modify the rate at which generic vertex attributes    advance. </summary>
            /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
            /// <param name="divisor">The new value for the instance step rate to apply.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml" /></remarks>
            public static void VertexBindingDivisor(uint bindingindex, uint divisor) => GLPointers._VertexBindingDivisor_fnptr(bindingindex, divisor);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightbvARB(int size, sbyte* weights) => GLPointers._WeightbvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightsvARB(int size, short* weights) => GLPointers._WeightsvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightivARB(int size, int* weights) => GLPointers._WeightivARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightfvARB(int size, float* weights) => GLPointers._WeightfvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightdvARB(int size, double* weights) => GLPointers._WeightdvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightubvARB(int size, byte* weights) => GLPointers._WeightubvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightusvARB(int size, ushort* weights) => GLPointers._WeightusvARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightuivARB(int size, uint* weights) => GLPointers._WeightuivARB_fnptr(size, weights);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightPointerARB(int size, WeightPointerTypeARB type, int stride, void* pointer) => GLPointers._WeightPointerARB_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_blend]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexBlendARB(int count) => GLPointers._VertexBlendARB_fnptr(count);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferARB(BufferTargetARB target, BufferHandle buffer) => GLPointers._BindBufferARB_fnptr((uint)target, (int)buffer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteBuffersARB(int n, BufferHandle* buffers) => GLPointers._DeleteBuffersARB_fnptr(n, (int*)buffers);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenBuffersARB(int n, BufferHandle* buffers) => GLPointers._GenBuffersARB_fnptr(n, (int*)buffers);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsBufferARB(BufferHandle buffer) => GLPointers._IsBufferARB_fnptr((int)buffer) != 0;
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferDataARB(BufferTargetARB target, nint size, void* data, BufferUsageARB usage) => GLPointers._BufferDataARB_fnptr((uint)target, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferSubDataARB(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._BufferSubDataARB_fnptr((uint)target, offset, size, data);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBufferSubDataARB(BufferTargetARB target, IntPtr offset, nint size, void* data) => GLPointers._GetBufferSubDataARB_fnptr((uint)target, offset, size, data);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapBufferARB(BufferTargetARB target, BufferAccessARB access) => GLPointers._MapBufferARB_fnptr((uint)target, (uint)access);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool UnmapBufferARB(BufferTargetARB target) => GLPointers._UnmapBufferARB_fnptr((uint)target) != 0;
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBufferParameterivARB(BufferTargetARB target, BufferPNameARB pname, int* parameters) => GLPointers._GetBufferParameterivARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBufferPointervARB(BufferTargetARB target, BufferPointerNameARB pname, void** parameters) => GLPointers._GetBufferPointervARB_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1dARB(uint index, double x) => GLPointers._VertexAttrib1dARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1dvARB(uint index, double* v) => GLPointers._VertexAttrib1dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1fARB(uint index, float x) => GLPointers._VertexAttrib1fARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1fvARB(uint index, float* v) => GLPointers._VertexAttrib1fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1sARB(uint index, short x) => GLPointers._VertexAttrib1sARB_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1svARB(uint index, short* v) => GLPointers._VertexAttrib1svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2dARB(uint index, double x, double y) => GLPointers._VertexAttrib2dARB_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2dvARB(uint index, double* v) => GLPointers._VertexAttrib2dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2fARB(uint index, float x, float y) => GLPointers._VertexAttrib2fARB_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2fvARB(uint index, float* v) => GLPointers._VertexAttrib2fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2sARB(uint index, short x, short y) => GLPointers._VertexAttrib2sARB_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2svARB(uint index, short* v) => GLPointers._VertexAttrib2svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3dARB(uint index, double x, double y, double z) => GLPointers._VertexAttrib3dARB_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3dvARB(uint index, double* v) => GLPointers._VertexAttrib3dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3fARB(uint index, float x, float y, float z) => GLPointers._VertexAttrib3fARB_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3fvARB(uint index, float* v) => GLPointers._VertexAttrib3fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3sARB(uint index, short x, short y, short z) => GLPointers._VertexAttrib3sARB_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3svARB(uint index, short* v) => GLPointers._VertexAttrib3svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NbvARB(uint index, sbyte* v) => GLPointers._VertexAttrib4NbvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NivARB(uint index, int* v) => GLPointers._VertexAttrib4NivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NsvARB(uint index, short* v) => GLPointers._VertexAttrib4NsvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NubARB(uint index, byte x, byte y, byte z, byte w) => GLPointers._VertexAttrib4NubARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NubvARB(uint index, byte* v) => GLPointers._VertexAttrib4NubvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NuivARB(uint index, uint* v) => GLPointers._VertexAttrib4NuivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4NusvARB(uint index, ushort* v) => GLPointers._VertexAttrib4NusvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4bvARB(uint index, sbyte* v) => GLPointers._VertexAttrib4bvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4dARB(uint index, double x, double y, double z, double w) => GLPointers._VertexAttrib4dARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4dvARB(uint index, double* v) => GLPointers._VertexAttrib4dvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4fARB(uint index, float x, float y, float z, float w) => GLPointers._VertexAttrib4fARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4fvARB(uint index, float* v) => GLPointers._VertexAttrib4fvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4ivARB(uint index, int* v) => GLPointers._VertexAttrib4ivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4sARB(uint index, short x, short y, short z, short w) => GLPointers._VertexAttrib4sARB_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4svARB(uint index, short* v) => GLPointers._VertexAttrib4svARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4ubvARB(uint index, byte* v) => GLPointers._VertexAttrib4ubvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4uivARB(uint index, uint* v) => GLPointers._VertexAttrib4uivARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4usvARB(uint index, ushort* v) => GLPointers._VertexAttrib4usvARB_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribPointerARB(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, void* pointer) => GLPointers._VertexAttribPointerARB_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, pointer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVertexAttribArrayARB(uint index) => GLPointers._EnableVertexAttribArrayARB_fnptr(index);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVertexAttribArrayARB(uint index) => GLPointers._DisableVertexAttribArrayARB_fnptr(index);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, double* parameters) => GLPointers._GetVertexAttribdvARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, float* parameters) => GLPointers._GetVertexAttribfvARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, int* parameters) => GLPointers._GetVertexAttribivARB_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ARB_vertex_program | GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribPointervARB(uint index, VertexAttribPointerPropertyARB pname, void** pointer) => GLPointers._GetVertexAttribPointervARB_fnptr(index, (uint)pname, pointer);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindAttribLocationARB(GLHandleARB programObj, uint index, byte* name) => GLPointers._BindAttribLocationARB_fnptr((IntPtr)programObj, index, name);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetActiveAttribARB(GLHandleARB programObj, uint index, int maxLength, int* length, int* size, AttributeType* type, byte* name) => GLPointers._GetActiveAttribARB_fnptr((IntPtr)programObj, index, maxLength, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_ARB_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetAttribLocationARB(GLHandleARB programObj, byte* name) => GLPointers._GetAttribLocationARB_fnptr((IntPtr)programObj, name);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._VertexAttribP1ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._VertexAttribP1uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._VertexAttribP2ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._VertexAttribP2uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._VertexAttribP3ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._VertexAttribP3uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b> Specifies the value of a generic vertex attribute. </summary>
            /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
            /// <param name="type"> For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data. </param>
            /// <param name="normalized"> For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE. </param>
            /// <param name="value"> For the packed commands, specifies the new packed value to be used for the specified vertex attribute. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttrib.xhtml" /></remarks>
            public static void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => GLPointers._VertexAttribP4ui_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v3.3 | GL_ARB_vertex_type_2_10_10_10_rev]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, uint* value) => GLPointers._VertexAttribP4uiv_fnptr(index, (uint)type, (byte)(normalized ? 1 : 0), value);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set multiple viewports. </summary>
            /// <param name="first"> Specify the first viewport to set. </param>
            /// <param name="count"> Specify the number of viewports to set. </param>
            /// <param name="v"> Specify the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportArray.xhtml" /></remarks>
            public static void ViewportArrayv(uint first, int count, float* v) => GLPointers._ViewportArrayv_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="x"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="y"> For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). </param>
            /// <param name="w"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <param name="h"> For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, w and h are set to the dimensions of that window. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
            public static void ViewportIndexedf(uint index, float x, float y, float w, float h) => GLPointers._ViewportIndexedf_fnptr(index, x, y, w, h);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Set a specified viewport. </summary>
            /// <param name="index"> Specify the first viewport to set. </param>
            /// <param name="v"> For glViewportIndexedfv, specifies the address of an array containing the viewport parameters. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewportIndexed.xhtml" /></remarks>
            public static void ViewportIndexedfv(uint index, float* v) => GLPointers._ViewportIndexedfv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for multiple viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose scissor box to modify. </param>
            /// <param name="count"> Specifies the number of scissor boxes to modify. </param>
            /// <param name="v"> Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorArray.xhtml" /></remarks>
            public static void ScissorArrayv(uint first, int count, int* v) => GLPointers._ScissorArrayv_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="left"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="bottom"> Specify the coordinate of the bottom left corner of the scissor box, in pixels. </param>
            /// <param name="width"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <param name="height"> Specify ths dimensions of the scissor box, in pixels. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
            public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) => GLPointers._ScissorIndexed_fnptr(index, left, bottom, width, height);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Define the scissor box for a specific viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose scissor box to modify. </param>
            /// <param name="v"> For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml" /></remarks>
            public static void ScissorIndexedv(uint index, int* v) => GLPointers._ScissorIndexedv_fnptr(index, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports. </summary>
            /// <param name="first"> Specifies the index of the first viewport whose depth range to update. </param>
            /// <param name="count"> Specifies the number of viewports whose depth range to update. </param>
            /// <param name="v"> Specifies the address of an array containing the near and far values for the depth range of each modified viewport. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeArray.xhtml" /></remarks>
            public static void DepthRangeArrayv(uint first, int count, double* v) => GLPointers._DepthRangeArrayv_fnptr(first, count, v);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport. </summary>
            /// <param name="index"> Specifies the index of the viewport whose depth range to update. </param>
            /// <param name="nearVal"> Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0. </param>
            /// <param name="farVal"> Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml" /></remarks>
            public static void DepthRangeIndexed(uint index, double n, double f) => GLPointers._DepthRangeIndexed_fnptr(index, n, f);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetFloati_v(GetPName target, uint index, float* data) => GLPointers._GetFloati_v_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: v4.1 | GL_ARB_viewport_array]</b> Return the value or values of a selected parameter. </summary>
            /// <param name="target"> Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants in the list below are accepted. </param>
            /// <param name="index"> Specifies the index of the particular element being queried. </param>
            /// <param name="data"> Returns the value or values of the specified parameter. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGet.xhtml" /></remarks>
            public static void GetDoublei_v(GetPName target, uint index, double* data) => GLPointers._GetDoublei_v_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_ARB_viewport_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangeArraydvNV(uint first, int count, double* v) => GLPointers._DepthRangeArraydvNV_fnptr(first, count, v);
            
            /// <summary> <b>[requires: GL_ARB_viewport_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangeIndexeddNV(uint index, double n, double f) => GLPointers._DepthRangeIndexeddNV_fnptr(index, n, f);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2dARB(double x, double y) => GLPointers._WindowPos2dARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2dvARB(double* v) => GLPointers._WindowPos2dvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2fARB(float x, float y) => GLPointers._WindowPos2fARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2fvARB(float* v) => GLPointers._WindowPos2fvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2iARB(int x, int y) => GLPointers._WindowPos2iARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2ivARB(int* v) => GLPointers._WindowPos2ivARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2sARB(short x, short y) => GLPointers._WindowPos2sARB_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2svARB(short* v) => GLPointers._WindowPos2svARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3dARB(double x, double y, double z) => GLPointers._WindowPos3dARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3dvARB(double* v) => GLPointers._WindowPos3dvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3fARB(float x, float y, float z) => GLPointers._WindowPos3fARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3fvARB(float* v) => GLPointers._WindowPos3fvARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3iARB(int x, int y, int z) => GLPointers._WindowPos3iARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3ivARB(int* v) => GLPointers._WindowPos3ivARB_fnptr(v);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3sARB(short x, short y, short z) => GLPointers._WindowPos3sARB_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_ARB_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3svARB(short* v) => GLPointers._WindowPos3svARB_fnptr(v);
            
        }
        public static unsafe partial class ATI
        {
            /// <summary> <b>[requires: GL_ATI_draw_buffers]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawBuffersATI(int n, DrawBufferMode* bufs) => GLPointers._DrawBuffersATI_fnptr(n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_ATI_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ElementPointerATI(ElementPointerTypeATI type, void* pointer) => GLPointers._ElementPointerATI_fnptr((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_ATI_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawElementArrayATI(PrimitiveType mode, int count) => GLPointers._DrawElementArrayATI_fnptr((uint)mode, count);
            
            /// <summary> <b>[requires: GL_ATI_element_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawRangeElementArrayATI(PrimitiveType mode, uint start, uint end, int count) => GLPointers._DrawRangeElementArrayATI_fnptr((uint)mode, start, end, count);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexBumpParameterivATI(TexBumpParameterATI pname, int* param) => GLPointers._TexBumpParameterivATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexBumpParameterfvATI(TexBumpParameterATI pname, float* param) => GLPointers._TexBumpParameterfvATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, int* param) => GLPointers._GetTexBumpParameterivATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_envmap_bumpmap]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, float* param) => GLPointers._GetTexBumpParameterfvATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenFragmentShadersATI(uint range) => GLPointers._GenFragmentShadersATI_fnptr(range);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindFragmentShaderATI(uint id) => GLPointers._BindFragmentShaderATI_fnptr(id);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteFragmentShaderATI(uint id) => GLPointers._DeleteFragmentShaderATI_fnptr(id);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginFragmentShaderATI() => GLPointers._BeginFragmentShaderATI_fnptr();
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndFragmentShaderATI() => GLPointers._EndFragmentShaderATI_fnptr();
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PassTexCoordATI(uint dst, uint coord, SwizzleOpATI swizzle) => GLPointers._PassTexCoordATI_fnptr(dst, coord, (uint)swizzle);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleMapATI(uint dst, uint interp, SwizzleOpATI swizzle) => GLPointers._SampleMapATI_fnptr(dst, interp, (uint)swizzle);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorFragmentOp1ATI(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) => GLPointers._ColorFragmentOp1ATI_fnptr((uint)op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorFragmentOp2ATI(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) => GLPointers._ColorFragmentOp2ATI_fnptr((uint)op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorFragmentOp3ATI(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) => GLPointers._ColorFragmentOp3ATI_fnptr((uint)op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaFragmentOp1ATI(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) => GLPointers._AlphaFragmentOp1ATI_fnptr((uint)op, dst, dstMod, arg1, arg1Rep, arg1Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaFragmentOp2ATI(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) => GLPointers._AlphaFragmentOp2ATI_fnptr((uint)op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaFragmentOp3ATI(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) => GLPointers._AlphaFragmentOp3ATI_fnptr((uint)op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
            
            /// <summary> <b>[requires: GL_ATI_fragment_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetFragmentShaderConstantATI(uint dst, float* value) => GLPointers._SetFragmentShaderConstantATI_fnptr(dst, value);
            
            /// <summary> <b>[requires: GL_ATI_map_object_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapObjectBufferATI(BufferHandle buffer) => GLPointers._MapObjectBufferATI_fnptr((int)buffer);
            
            /// <summary> <b>[requires: GL_ATI_map_object_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UnmapObjectBufferATI(BufferHandle buffer) => GLPointers._UnmapObjectBufferATI_fnptr((int)buffer);
            
            /// <summary> <b>[requires: GL_ATI_pn_triangles]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PNTrianglesiATI(PNTrianglesPNameATI pname, int param) => GLPointers._PNTrianglesiATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_pn_triangles]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PNTrianglesfATI(PNTrianglesPNameATI pname, float param) => GLPointers._PNTrianglesfATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_separate_stencil]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilOpSeparateATI(StencilFaceDirection face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => GLPointers._StencilOpSeparateATI_fnptr((uint)face, (uint)sfail, (uint)dpfail, (uint)dppass);
            
            /// <summary> <b>[requires: GL_ATI_separate_stencil]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilFuncSeparateATI(StencilFunction frontfunc, StencilFunction backfunc, int reference, uint mask) => GLPointers._StencilFuncSeparateATI_fnptr((uint)frontfunc, (uint)backfunc, reference, mask);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint NewObjectBufferATI(int size, void* pointer, ArrayObjectUsageATI usage) => GLPointers._NewObjectBufferATI_fnptr(size, pointer, (uint)usage);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsObjectBufferATI(BufferHandle buffer) => GLPointers._IsObjectBufferATI_fnptr((int)buffer) != 0;
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UpdateObjectBufferATI(BufferHandle buffer, uint offset, int size, void* pointer, PreserveModeATI preserve) => GLPointers._UpdateObjectBufferATI_fnptr((int)buffer, offset, size, pointer, (uint)preserve);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectBufferfvATI(BufferHandle buffer, ArrayObjectPNameATI pname, float* parameters) => GLPointers._GetObjectBufferfvATI_fnptr((int)buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectBufferivATI(BufferHandle buffer, ArrayObjectPNameATI pname, int* parameters) => GLPointers._GetObjectBufferivATI_fnptr((int)buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FreeObjectBufferATI(BufferHandle buffer) => GLPointers._FreeObjectBufferATI_fnptr((int)buffer);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ArrayObjectATI(EnableCap array, int size, ScalarType type, int stride, BufferHandle buffer, uint offset) => GLPointers._ArrayObjectATI_fnptr((uint)array, size, (uint)type, stride, (int)buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetArrayObjectfvATI(EnableCap array, ArrayObjectPNameATI pname, float* parameters) => GLPointers._GetArrayObjectfvATI_fnptr((uint)array, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetArrayObjectivATI(EnableCap array, ArrayObjectPNameATI pname, int* parameters) => GLPointers._GetArrayObjectivATI_fnptr((uint)array, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantArrayObjectATI(uint id, ScalarType type, int stride, BufferHandle buffer, uint offset) => GLPointers._VariantArrayObjectATI_fnptr(id, (uint)type, stride, (int)buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantArrayObjectfvATI(uint id, ArrayObjectPNameATI pname, float* parameters) => GLPointers._GetVariantArrayObjectfvATI_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantArrayObjectivATI(uint id, ArrayObjectPNameATI pname, int* parameters) => GLPointers._GetVariantArrayObjectivATI_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribArrayObjectATI(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, BufferHandle buffer, uint offset) => GLPointers._VertexAttribArrayObjectATI_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, (int)buffer, offset);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, float* parameters) => GLPointers._GetVertexAttribArrayObjectfvATI_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_attrib_array_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, int* parameters) => GLPointers._GetVertexAttribArrayObjectivATI_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1sATI(VertexStreamATI stream, short x) => GLPointers._VertexStream1sATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1svATI(VertexStreamATI stream, short* coords) => GLPointers._VertexStream1svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1iATI(VertexStreamATI stream, int x) => GLPointers._VertexStream1iATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1ivATI(VertexStreamATI stream, int* coords) => GLPointers._VertexStream1ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1fATI(VertexStreamATI stream, float x) => GLPointers._VertexStream1fATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1fvATI(VertexStreamATI stream, float* coords) => GLPointers._VertexStream1fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1dATI(VertexStreamATI stream, double x) => GLPointers._VertexStream1dATI_fnptr((uint)stream, x);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream1dvATI(VertexStreamATI stream, double* coords) => GLPointers._VertexStream1dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2sATI(VertexStreamATI stream, short x, short y) => GLPointers._VertexStream2sATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2svATI(VertexStreamATI stream, short* coords) => GLPointers._VertexStream2svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2iATI(VertexStreamATI stream, int x, int y) => GLPointers._VertexStream2iATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2ivATI(VertexStreamATI stream, int* coords) => GLPointers._VertexStream2ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2fATI(VertexStreamATI stream, float x, float y) => GLPointers._VertexStream2fATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2fvATI(VertexStreamATI stream, float* coords) => GLPointers._VertexStream2fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2dATI(VertexStreamATI stream, double x, double y) => GLPointers._VertexStream2dATI_fnptr((uint)stream, x, y);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream2dvATI(VertexStreamATI stream, double* coords) => GLPointers._VertexStream2dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3sATI(VertexStreamATI stream, short x, short y, short z) => GLPointers._VertexStream3sATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3svATI(VertexStreamATI stream, short* coords) => GLPointers._VertexStream3svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3iATI(VertexStreamATI stream, int x, int y, int z) => GLPointers._VertexStream3iATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3ivATI(VertexStreamATI stream, int* coords) => GLPointers._VertexStream3ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3fATI(VertexStreamATI stream, float x, float y, float z) => GLPointers._VertexStream3fATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3fvATI(VertexStreamATI stream, float* coords) => GLPointers._VertexStream3fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3dATI(VertexStreamATI stream, double x, double y, double z) => GLPointers._VertexStream3dATI_fnptr((uint)stream, x, y, z);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream3dvATI(VertexStreamATI stream, double* coords) => GLPointers._VertexStream3dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4sATI(VertexStreamATI stream, short x, short y, short z, short w) => GLPointers._VertexStream4sATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4svATI(VertexStreamATI stream, short* coords) => GLPointers._VertexStream4svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4iATI(VertexStreamATI stream, int x, int y, int z, int w) => GLPointers._VertexStream4iATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4ivATI(VertexStreamATI stream, int* coords) => GLPointers._VertexStream4ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4fATI(VertexStreamATI stream, float x, float y, float z, float w) => GLPointers._VertexStream4fATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4fvATI(VertexStreamATI stream, float* coords) => GLPointers._VertexStream4fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4dATI(VertexStreamATI stream, double x, double y, double z, double w) => GLPointers._VertexStream4dATI_fnptr((uint)stream, x, y, z, w);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexStream4dvATI(VertexStreamATI stream, double* coords) => GLPointers._VertexStream4dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3bATI(VertexStreamATI stream, sbyte nx, sbyte ny, sbyte nz) => GLPointers._NormalStream3bATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3bvATI(VertexStreamATI stream, sbyte* coords) => GLPointers._NormalStream3bvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3sATI(VertexStreamATI stream, short nx, short ny, short nz) => GLPointers._NormalStream3sATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3svATI(VertexStreamATI stream, short* coords) => GLPointers._NormalStream3svATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3iATI(VertexStreamATI stream, int nx, int ny, int nz) => GLPointers._NormalStream3iATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3ivATI(VertexStreamATI stream, int* coords) => GLPointers._NormalStream3ivATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3fATI(VertexStreamATI stream, float nx, float ny, float nz) => GLPointers._NormalStream3fATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3fvATI(VertexStreamATI stream, float* coords) => GLPointers._NormalStream3fvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3dATI(VertexStreamATI stream, double nx, double ny, double nz) => GLPointers._NormalStream3dATI_fnptr((uint)stream, nx, ny, nz);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalStream3dvATI(VertexStreamATI stream, double* coords) => GLPointers._NormalStream3dvATI_fnptr((uint)stream, coords);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClientActiveVertexStreamATI(VertexStreamATI stream) => GLPointers._ClientActiveVertexStreamATI_fnptr((uint)stream);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexBlendEnviATI(VertexStreamATI pname, int param) => GLPointers._VertexBlendEnviATI_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_ATI_vertex_streams]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexBlendEnvfATI(VertexStreamATI pname, float param) => GLPointers._VertexBlendEnvfATI_fnptr((uint)pname, param);
            
        }
        public static unsafe partial class EXT
        {
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EGLImageTargetTexStorageEXT(All target, void* image, int* attrib_list) => GLPointers._EGLImageTargetTexStorageEXT_fnptr((uint)target, image, attrib_list);
            
            /// <summary> <b>[requires: GL_EXT_EGL_image_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EGLImageTargetTextureStorageEXT(TextureHandle texture, void* image, int* attrib_list) => GLPointers._EGLImageTargetTextureStorageEXT_fnptr((int)texture, image, attrib_list);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformBufferEXT(ProgramHandle program, int location, BufferHandle buffer) => GLPointers._UniformBufferEXT_fnptr((int)program, location, (int)buffer);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetUniformBufferSizeEXT(ProgramHandle program, int location) => GLPointers._GetUniformBufferSizeEXT_fnptr((int)program, location);
            
            /// <summary> <b>[requires: GL_EXT_bindable_uniform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr GetUniformOffsetEXT(ProgramHandle program, int location) => GLPointers._GetUniformOffsetEXT_fnptr((int)program, location);
            
            /// <summary> <b>[requires: GL_EXT_blend_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendColorEXT(float red, float green, float blue, float alpha) => GLPointers._BlendColorEXT_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_equation_separate]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationSeparateEXT(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => GLPointers._BlendEquationSeparateEXT_fnptr((uint)modeRGB, (uint)modeAlpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_func_separate]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncSeparateEXT(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers._BlendFuncSeparateEXT_fnptr((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
            
            /// <summary> <b>[requires: GL_EXT_blend_minmax]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendEquationEXT(BlendEquationModeEXT mode) => GLPointers._BlendEquationEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_color_subtable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorSubTableEXT(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, void* data) => GLPointers._ColorSubTableEXT_fnptr((uint)target, start, count, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_color_subtable]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyColorSubTableEXT(ColorTableTarget target, int start, int x, int y, int width) => GLPointers._CopyColorSubTableEXT_fnptr((uint)target, start, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LockArraysEXT(int first, int count) => GLPointers._LockArraysEXT_fnptr(first, count);
            
            /// <summary> <b>[requires: GL_EXT_compiled_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UnlockArraysEXT() => GLPointers._UnlockArraysEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* image) => GLPointers._ConvolutionFilter1DEXT_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* image) => GLPointers._ConvolutionFilter2DEXT_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterfEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float parameters) => GLPointers._ConvolutionParameterfEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float* parameters) => GLPointers._ConvolutionParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameteriEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int parameters) => GLPointers._ConvolutionParameteriEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int* parameters) => GLPointers._ConvolutionParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width) => GLPointers._CopyConvolutionFilter1DEXT_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width, int height) => GLPointers._CopyConvolutionFilter2DEXT_fnptr((uint)target, (uint)internalformat, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetConvolutionFilterEXT(ConvolutionTargetEXT target, PixelFormat format, PixelType type, void* image) => GLPointers._GetConvolutionFilterEXT_fnptr((uint)target, (uint)format, (uint)type, image);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float* parameters) => GLPointers._GetConvolutionParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int* parameters) => GLPointers._GetConvolutionParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetSeparableFilterEXT(SeparableTargetEXT target, PixelFormat format, PixelType type, void* row, void* column, void* span) => GLPointers._GetSeparableFilterEXT_fnptr((uint)target, (uint)format, (uint)type, row, column, span);
            
            /// <summary> <b>[requires: GL_EXT_convolution]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SeparableFilter2DEXT(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, void* row, void* column) => GLPointers._SeparableFilter2DEXT_fnptr((uint)target, (uint)internalformat, width, height, (uint)format, (uint)type, row, column);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3bEXT(sbyte tx, sbyte ty, sbyte tz) => GLPointers._Tangent3bEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3bvEXT(sbyte* v) => GLPointers._Tangent3bvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3dEXT(double tx, double ty, double tz) => GLPointers._Tangent3dEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3dvEXT(double* v) => GLPointers._Tangent3dvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3fEXT(float tx, float ty, float tz) => GLPointers._Tangent3fEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3fvEXT(float* v) => GLPointers._Tangent3fvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3iEXT(int tx, int ty, int tz) => GLPointers._Tangent3iEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3ivEXT(int* v) => GLPointers._Tangent3ivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3sEXT(short tx, short ty, short tz) => GLPointers._Tangent3sEXT_fnptr(tx, ty, tz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Tangent3svEXT(short* v) => GLPointers._Tangent3svEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3bEXT(sbyte bx, sbyte by, sbyte bz) => GLPointers._Binormal3bEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3bvEXT(sbyte* v) => GLPointers._Binormal3bvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3dEXT(double bx, double by, double bz) => GLPointers._Binormal3dEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3dvEXT(double* v) => GLPointers._Binormal3dvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3fEXT(float bx, float by, float bz) => GLPointers._Binormal3fEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3fvEXT(float* v) => GLPointers._Binormal3fvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3iEXT(int bx, int by, int bz) => GLPointers._Binormal3iEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3ivEXT(int* v) => GLPointers._Binormal3ivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3sEXT(short bx, short by, short bz) => GLPointers._Binormal3sEXT_fnptr(bx, by, bz);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Binormal3svEXT(short* v) => GLPointers._Binormal3svEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TangentPointerEXT(TangentPointerTypeEXT type, int stride, void* pointer) => GLPointers._TangentPointerEXT_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_coordinate_frame]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BinormalPointerEXT(BinormalPointerTypeEXT type, int stride, void* pointer) => GLPointers._BinormalPointerEXT_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexImage1DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._CopyTexImage1DEXT_fnptr((uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexImage2DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._CopyTexImage2DEXT_fnptr((uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexSubImage1DEXT(TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._CopyTexSubImage1DEXT_fnptr((uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._CopyTexSubImage2DEXT_fnptr((uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_copy_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._CopyTexSubImage3DEXT_fnptr((uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_cull_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CullParameterdvEXT(CullParameterEXT pname, double* parameters) => GLPointers._CullParameterdvEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_cull_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CullParameterfvEXT(CullParameterEXT pname, float* parameters) => GLPointers._CullParameterfvEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_debug_label]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LabelObjectEXT(All type, uint obj, int length, byte* label) => GLPointers._LabelObjectEXT_fnptr((uint)type, obj, length, label);
            
            /// <summary> <b>[requires: GL_EXT_debug_label]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectLabelEXT(All type, uint obj, int bufSize, int* length, byte* label) => GLPointers._GetObjectLabelEXT_fnptr((uint)type, obj, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void InsertEventMarkerEXT(int length, byte* marker) => GLPointers._InsertEventMarkerEXT_fnptr(length, marker);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PushGroupMarkerEXT(int length, byte* marker) => GLPointers._PushGroupMarkerEXT_fnptr(length, marker);
            
            /// <summary> <b>[requires: GL_EXT_debug_marker]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PopGroupMarkerEXT() => GLPointers._PopGroupMarkerEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_depth_bounds_test]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthBoundsEXT(double zmin, double zmax) => GLPointers._DepthBoundsEXT_fnptr(zmin, zmax);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadfEXT(MatrixMode mode, float* m) => GLPointers._MatrixLoadfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoaddEXT(MatrixMode mode, double* m) => GLPointers._MatrixLoaddEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultfEXT(MatrixMode mode, float* m) => GLPointers._MatrixMultfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultdEXT(MatrixMode mode, double* m) => GLPointers._MatrixMultdEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadIdentityEXT(MatrixMode mode) => GLPointers._MatrixLoadIdentityEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => GLPointers._MatrixRotatefEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => GLPointers._MatrixRotatedEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._MatrixScalefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => GLPointers._MatrixScaledEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._MatrixTranslatefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => GLPointers._MatrixTranslatedEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._MatrixFrustumEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._MatrixOrthoEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixPopEXT(MatrixMode mode) => GLPointers._MatrixPopEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixPushEXT(MatrixMode mode) => GLPointers._MatrixPushEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClientAttribDefaultEXT(ClientAttribMask mask) => GLPointers._ClientAttribDefaultEXT_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PushClientAttribDefaultEXT(ClientAttribMask mask) => GLPointers._PushClientAttribDefaultEXT_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterfEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, float param) => GLPointers._TextureParameterfEXT_fnptr((int)texture, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterfvEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers._TextureParameterfvEXT_fnptr((int)texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameteriEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, int param) => GLPointers._TextureParameteriEXT_fnptr((int)texture, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._TextureParameterivEXT_fnptr((int)texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage1DEXT(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureImage1DEXT_fnptr((int)texture, (uint)target, level, internalformat, width, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage2DEXT(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureImage2DEXT_fnptr((int)texture, (uint)target, level, internalformat, width, height, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureSubImage1DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureSubImage1DEXT_fnptr((int)texture, (uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureSubImage2DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureSubImage2DEXT_fnptr((int)texture, (uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureImage1DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._CopyTextureImage1DEXT_fnptr((int)texture, (uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureImage2DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._CopyTextureImage2DEXT_fnptr((int)texture, (uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureSubImage1DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._CopyTextureSubImage1DEXT_fnptr((int)texture, (uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureSubImage2DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._CopyTextureSubImage2DEXT_fnptr((int)texture, (uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureImageEXT(TextureHandle texture, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers._GetTextureImageEXT_fnptr((int)texture, (uint)target, level, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureParameterfvEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers._GetTextureParameterfvEXT_fnptr((int)texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureParameterivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._GetTextureParameterivEXT_fnptr((int)texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureLevelParameterfvEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers._GetTextureLevelParameterfvEXT_fnptr((int)texture, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureLevelParameterivEXT(TextureHandle texture, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._GetTextureLevelParameterivEXT_fnptr((int)texture, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage3DEXT(TextureHandle texture, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureImage3DEXT_fnptr((int)texture, (uint)target, level, internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureSubImage3DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._TextureSubImage3DEXT_fnptr((int)texture, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyTextureSubImage3DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._CopyTextureSubImage3DEXT_fnptr((int)texture, (uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindMultiTextureEXT(TextureUnit texunit, TextureTarget target, TextureHandle texture) => GLPointers._BindMultiTextureEXT_fnptr((uint)texunit, (uint)target, (int)texture);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoordPointerEXT(TextureUnit texunit, int size, TexCoordPointerType type, int stride, void* pointer) => GLPointers._MultiTexCoordPointerEXT_fnptr((uint)texunit, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexEnvfEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float param) => GLPointers._MultiTexEnvfEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._MultiTexEnvfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexEnviEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers._MultiTexEnviEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._MultiTexEnvivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGendEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double param) => GLPointers._MultiTexGendEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._MultiTexGendvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGenfEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float param) => GLPointers._MultiTexGenfEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._MultiTexGenfvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGeniEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers._MultiTexGeniEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._MultiTexGenivEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float* parameters) => GLPointers._GetMultiTexEnvfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._GetMultiTexEnvivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double* parameters) => GLPointers._GetMultiTexGendvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float* parameters) => GLPointers._GetMultiTexGenfvEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._GetMultiTexGenivEXT_fnptr((uint)texunit, (uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameteriEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int param) => GLPointers._MultiTexParameteriEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._MultiTexParameterivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterfEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float param) => GLPointers._MultiTexParameterfEXT_fnptr((uint)texunit, (uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float* parameters) => GLPointers._MultiTexParameterfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._MultiTexImage1DEXT_fnptr((uint)texunit, (uint)target, level, internalformat, width, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._MultiTexImage2DEXT_fnptr((uint)texunit, (uint)target, level, internalformat, width, height, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._MultiTexSubImage1DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._MultiTexSubImage2DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => GLPointers._CopyMultiTexImage1DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, x, y, width, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => GLPointers._CopyMultiTexImage2DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, x, y, width, height, border);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int x, int y, int width) => GLPointers._CopyMultiTexSubImage1DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, x, y, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => GLPointers._CopyMultiTexSubImage2DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, void* pixels) => GLPointers._GetMultiTexImageEXT_fnptr((uint)texunit, (uint)target, level, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, float* parameters) => GLPointers._GetMultiTexParameterfvEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._GetMultiTexParameterivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, float* parameters) => GLPointers._GetMultiTexLevelParameterfvEXT_fnptr((uint)texunit, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._GetMultiTexLevelParameterivEXT_fnptr((uint)texunit, (uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._MultiTexImage3DEXT_fnptr((uint)texunit, (uint)target, level, internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._MultiTexSubImage3DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => GLPointers._CopyMultiTexSubImage3DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, x, y, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableClientStateIndexedEXT(EnableCap array, uint index) => GLPointers._EnableClientStateIndexedEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableClientStateIndexedEXT(EnableCap array, uint index) => GLPointers._DisableClientStateIndexedEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFloatIndexedvEXT(GetPName target, uint index, float* data) => GLPointers._GetFloatIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetDoubleIndexedvEXT(GetPName target, uint index, double* data) => GLPointers._GetDoubleIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPointerIndexedvEXT(All target, uint index, void** data) => GLPointers._GetPointerIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableIndexedEXT(EnableCap target, uint index) => GLPointers._EnableIndexedEXT_fnptr((uint)target, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableIndexedEXT(EnableCap target, uint index) => GLPointers._DisableIndexedEXT_fnptr((uint)target, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsEnabledIndexedEXT(EnableCap target, uint index) => GLPointers._IsEnabledIndexedEXT_fnptr((uint)target, index) != 0;
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetIntegerIndexedvEXT(GetPName target, uint index, int* data) => GLPointers._GetIntegerIndexedvEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBooleanIndexedvEXT(BufferTargetARB target, uint index, bool* data) => GLPointers._GetBooleanIndexedvEXT_fnptr((uint)target, index, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureImage3DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => GLPointers._CompressedTextureImage3DEXT_fnptr((int)texture, (uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureImage2DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => GLPointers._CompressedTextureImage2DEXT_fnptr((int)texture, (uint)target, level, (uint)internalformat, width, height, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureImage1DEXT(TextureHandle texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => GLPointers._CompressedTextureImage1DEXT_fnptr((int)texture, (uint)target, level, (uint)internalformat, width, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureSubImage3DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => GLPointers._CompressedTextureSubImage3DEXT_fnptr((int)texture, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureSubImage2DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => GLPointers._CompressedTextureSubImage2DEXT_fnptr((int)texture, (uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedTextureSubImage1DEXT(TextureHandle texture, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => GLPointers._CompressedTextureSubImage1DEXT_fnptr((int)texture, (uint)target, level, xoffset, width, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCompressedTextureImageEXT(TextureHandle texture, TextureTarget target, int lod, void* img) => GLPointers._GetCompressedTextureImageEXT_fnptr((int)texture, (uint)target, lod, img);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits) => GLPointers._CompressedMultiTexImage3DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, width, height, depth, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, void* bits) => GLPointers._CompressedMultiTexImage2DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, width, height, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, void* bits) => GLPointers._CompressedMultiTexImage1DEXT_fnptr((uint)texunit, (uint)target, level, (uint)internalformat, width, border, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, InternalFormat format, int imageSize, void* bits) => GLPointers._CompressedMultiTexSubImage3DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, InternalFormat format, int imageSize, void* bits) => GLPointers._CompressedMultiTexSubImage2DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, yoffset, width, height, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompressedMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, InternalFormat format, int imageSize, void* bits) => GLPointers._CompressedMultiTexSubImage1DEXT_fnptr((uint)texunit, (uint)target, level, xoffset, width, (uint)format, imageSize, bits);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCompressedMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int lod, void* img) => GLPointers._GetCompressedMultiTexImageEXT_fnptr((uint)texunit, (uint)target, lod, img);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTransposefEXT(MatrixMode mode, float* m) => GLPointers._MatrixLoadTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTransposedEXT(MatrixMode mode, double* m) => GLPointers._MatrixLoadTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTransposefEXT(MatrixMode mode, float* m) => GLPointers._MatrixMultTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTransposedEXT(MatrixMode mode, double* m) => GLPointers._MatrixMultTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferDataEXT(BufferHandle buffer, nint size, void* data, VertexBufferObjectUsage usage) => GLPointers._NamedBufferDataEXT_fnptr((int)buffer, size, data, (uint)usage);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferSubDataEXT(BufferHandle buffer, IntPtr offset, nint size, void* data) => GLPointers._NamedBufferSubDataEXT_fnptr((int)buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapNamedBufferEXT(BufferHandle buffer, BufferAccessARB access) => GLPointers._MapNamedBufferEXT_fnptr((int)buffer, (uint)access);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool UnmapNamedBufferEXT(BufferHandle buffer) => GLPointers._UnmapNamedBufferEXT_fnptr((int)buffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedBufferParameterivEXT(BufferHandle buffer, BufferPNameARB pname, int* parameters) => GLPointers._GetNamedBufferParameterivEXT_fnptr((int)buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedBufferPointervEXT(BufferHandle buffer, BufferPointerNameARB pname, void** parameters) => GLPointers._GetNamedBufferPointervEXT_fnptr((int)buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedBufferSubDataEXT(BufferHandle buffer, IntPtr offset, nint size, void* data) => GLPointers._GetNamedBufferSubDataEXT_fnptr((int)buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1fEXT(ProgramHandle program, int location, float v0) => GLPointers._ProgramUniform1fEXT_fnptr((int)program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2fEXT(ProgramHandle program, int location, float v0, float v1) => GLPointers._ProgramUniform2fEXT_fnptr((int)program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3fEXT(ProgramHandle program, int location, float v0, float v1, float v2) => GLPointers._ProgramUniform3fEXT_fnptr((int)program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4fEXT(ProgramHandle program, int location, float v0, float v1, float v2, float v3) => GLPointers._ProgramUniform4fEXT_fnptr((int)program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1iEXT(ProgramHandle program, int location, int v0) => GLPointers._ProgramUniform1iEXT_fnptr((int)program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2iEXT(ProgramHandle program, int location, int v0, int v1) => GLPointers._ProgramUniform2iEXT_fnptr((int)program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3iEXT(ProgramHandle program, int location, int v0, int v1, int v2) => GLPointers._ProgramUniform3iEXT_fnptr((int)program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4iEXT(ProgramHandle program, int location, int v0, int v1, int v2, int v3) => GLPointers._ProgramUniform4iEXT_fnptr((int)program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1fvEXT(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform1fvEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2fvEXT(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform2fvEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3fvEXT(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform3fvEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4fvEXT(ProgramHandle program, int location, int count, float* value) => GLPointers._ProgramUniform4fvEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ivEXT(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform1ivEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ivEXT(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform2ivEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ivEXT(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform3ivEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ivEXT(ProgramHandle program, int location, int count, int* value) => GLPointers._ProgramUniform4ivEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2fvEXT(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix2fvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3fvEXT(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix3fvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4fvEXT(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix4fvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x3fvEXT(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix2x3fvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x2fvEXT(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix3x2fvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x4fvEXT(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix2x4fvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x2fvEXT(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix4x2fvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x4fvEXT(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix3x4fvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x3fvEXT(ProgramHandle program, int location, int count, bool transpose, float* value) => GLPointers._ProgramUniformMatrix4x3fvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureBufferEXT(TextureHandle texture, TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer) => GLPointers._TextureBufferEXT_fnptr((int)texture, (uint)target, (uint)internalformat, (int)buffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexBufferEXT(TextureUnit texunit, TextureTarget target, InternalFormat internalformat, BufferHandle buffer) => GLPointers._MultiTexBufferEXT_fnptr((uint)texunit, (uint)target, (uint)internalformat, (int)buffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterIivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._TextureParameterIivEXT_fnptr((int)texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureParameterIuivEXT(TextureHandle texture, TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._TextureParameterIuivEXT_fnptr((int)texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureParameterIivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._GetTextureParameterIivEXT_fnptr((int)texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTextureParameterIuivEXT(TextureHandle texture, TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._GetTextureParameterIuivEXT_fnptr((int)texture, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._MultiTexParameterIivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._MultiTexParameterIuivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._GetMultiTexParameterIivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._GetMultiTexParameterIuivEXT_fnptr((uint)texunit, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1uiEXT(ProgramHandle program, int location, uint v0) => GLPointers._ProgramUniform1uiEXT_fnptr((int)program, location, v0);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2uiEXT(ProgramHandle program, int location, uint v0, uint v1) => GLPointers._ProgramUniform2uiEXT_fnptr((int)program, location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3uiEXT(ProgramHandle program, int location, uint v0, uint v1, uint v2) => GLPointers._ProgramUniform3uiEXT_fnptr((int)program, location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4uiEXT(ProgramHandle program, int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._ProgramUniform4uiEXT_fnptr((int)program, location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1uivEXT(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform1uivEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2uivEXT(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform2uivEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3uivEXT(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform3uivEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4uivEXT(ProgramHandle program, int location, int count, uint* value) => GLPointers._ProgramUniform4uivEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameters4fvEXT(ProgramHandle program, ProgramTarget target, uint index, int count, float* parameters) => GLPointers._NamedProgramLocalParameters4fvEXT_fnptr((int)program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameterI4iEXT(ProgramHandle program, ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers._NamedProgramLocalParameterI4iEXT_fnptr((int)program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameterI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, int* parameters) => GLPointers._NamedProgramLocalParameterI4ivEXT_fnptr((int)program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParametersI4ivEXT(ProgramHandle program, ProgramTarget target, uint index, int count, int* parameters) => GLPointers._NamedProgramLocalParametersI4ivEXT_fnptr((int)program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameterI4uiEXT(ProgramHandle program, ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers._NamedProgramLocalParameterI4uiEXT_fnptr((int)program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameterI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, uint* parameters) => GLPointers._NamedProgramLocalParameterI4uivEXT_fnptr((int)program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParametersI4uivEXT(ProgramHandle program, ProgramTarget target, uint index, int count, uint* parameters) => GLPointers._NamedProgramLocalParametersI4uivEXT_fnptr((int)program, (uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramLocalParameterIivEXT(ProgramHandle program, ProgramTarget target, uint index, int* parameters) => GLPointers._GetNamedProgramLocalParameterIivEXT_fnptr((int)program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramLocalParameterIuivEXT(ProgramHandle program, ProgramTarget target, uint index, uint* parameters) => GLPointers._GetNamedProgramLocalParameterIuivEXT_fnptr((int)program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableClientStateiEXT(EnableCap array, uint index) => GLPointers._EnableClientStateiEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableClientStateiEXT(EnableCap array, uint index) => GLPointers._DisableClientStateiEXT_fnptr((uint)array, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFloati_vEXT(GetPName pname, uint index, float* parameters) => GLPointers._GetFloati_vEXT_fnptr((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetDoublei_vEXT(GetPName pname, uint index, double* parameters) => GLPointers._GetDoublei_vEXT_fnptr((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPointeri_vEXT(All pname, uint index, void** parameters) => GLPointers._GetPointeri_vEXT_fnptr((uint)pname, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramStringEXT(ProgramHandle program, ProgramTarget target, ProgramFormat format, int len, void* str) => GLPointers._NamedProgramStringEXT_fnptr((int)program, (uint)target, (uint)format, len, str);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameter4dEXT(ProgramHandle program, ProgramTarget target, uint index, double x, double y, double z, double w) => GLPointers._NamedProgramLocalParameter4dEXT_fnptr((int)program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameter4dvEXT(ProgramHandle program, ProgramTarget target, uint index, double* parameters) => GLPointers._NamedProgramLocalParameter4dvEXT_fnptr((int)program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameter4fEXT(ProgramHandle program, ProgramTarget target, uint index, float x, float y, float z, float w) => GLPointers._NamedProgramLocalParameter4fEXT_fnptr((int)program, (uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedProgramLocalParameter4fvEXT(ProgramHandle program, ProgramTarget target, uint index, float* parameters) => GLPointers._NamedProgramLocalParameter4fvEXT_fnptr((int)program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramLocalParameterdvEXT(ProgramHandle program, ProgramTarget target, uint index, double* parameters) => GLPointers._GetNamedProgramLocalParameterdvEXT_fnptr((int)program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramLocalParameterfvEXT(ProgramHandle program, ProgramTarget target, uint index, float* parameters) => GLPointers._GetNamedProgramLocalParameterfvEXT_fnptr((int)program, (uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramivEXT(ProgramHandle program, ProgramTarget target, ProgramPropertyARB pname, int* parameters) => GLPointers._GetNamedProgramivEXT_fnptr((int)program, (uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedProgramStringEXT(ProgramHandle program, ProgramTarget target, ProgramStringProperty pname, void* str) => GLPointers._GetNamedProgramStringEXT_fnptr((int)program, (uint)target, (uint)pname, str);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedRenderbufferStorageEXT(RenderbufferHandle renderbuffer, InternalFormat internalformat, int width, int height) => GLPointers._NamedRenderbufferStorageEXT_fnptr((int)renderbuffer, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedRenderbufferParameterivEXT(RenderbufferHandle renderbuffer, RenderbufferParameterName pname, int* parameters) => GLPointers._GetNamedRenderbufferParameterivEXT_fnptr((int)renderbuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedRenderbufferStorageMultisampleEXT(RenderbufferHandle renderbuffer, int samples, InternalFormat internalformat, int width, int height) => GLPointers._NamedRenderbufferStorageMultisampleEXT_fnptr((int)renderbuffer, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedRenderbufferStorageMultisampleCoverageEXT(RenderbufferHandle renderbuffer, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => GLPointers._NamedRenderbufferStorageMultisampleCoverageEXT_fnptr((int)renderbuffer, coverageSamples, colorSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static FramebufferStatus CheckNamedFramebufferStatusEXT(FramebufferHandle framebuffer, FramebufferTarget target) => (FramebufferStatus) GLPointers._CheckNamedFramebufferStatusEXT_fnptr((int)framebuffer, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTexture1DEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => GLPointers._NamedFramebufferTexture1DEXT_fnptr((int)framebuffer, (uint)attachment, (uint)textarget, (int)texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTexture2DEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => GLPointers._NamedFramebufferTexture2DEXT_fnptr((int)framebuffer, (uint)attachment, (uint)textarget, (int)texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTexture3DEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset) => GLPointers._NamedFramebufferTexture3DEXT_fnptr((int)framebuffer, (uint)attachment, (uint)textarget, (int)texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferRenderbufferEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => GLPointers._NamedFramebufferRenderbufferEXT_fnptr((int)framebuffer, (uint)attachment, (uint)renderbuffertarget, (int)renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedFramebufferAttachmentParameterivEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._GetNamedFramebufferAttachmentParameterivEXT_fnptr((int)framebuffer, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenerateTextureMipmapEXT(TextureHandle texture, TextureTarget target) => GLPointers._GenerateTextureMipmapEXT_fnptr((int)texture, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenerateMultiTexMipmapEXT(TextureUnit texunit, TextureTarget target) => GLPointers._GenerateMultiTexMipmapEXT_fnptr((uint)texunit, (uint)target);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferDrawBufferEXT(FramebufferHandle framebuffer, DrawBufferMode mode) => GLPointers._FramebufferDrawBufferEXT_fnptr((int)framebuffer, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferDrawBuffersEXT(FramebufferHandle framebuffer, int n, DrawBufferMode* bufs) => GLPointers._FramebufferDrawBuffersEXT_fnptr((int)framebuffer, n, (uint*)bufs);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferReadBufferEXT(FramebufferHandle framebuffer, ReadBufferMode mode) => GLPointers._FramebufferReadBufferEXT_fnptr((int)framebuffer, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* parameters) => GLPointers._GetFramebufferParameterivEXT_fnptr((int)framebuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedCopyBufferSubDataEXT(BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._NamedCopyBufferSubDataEXT_fnptr((int)readBuffer, (int)writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTextureEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level) => GLPointers._NamedFramebufferTextureEXT_fnptr((int)framebuffer, (uint)attachment, (int)texture, level);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTextureLayerEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => GLPointers._NamedFramebufferTextureLayerEXT_fnptr((int)framebuffer, (uint)attachment, (int)texture, level, layer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferTextureFaceEXT(FramebufferHandle framebuffer, FramebufferAttachment attachment, TextureHandle texture, int level, TextureTarget face) => GLPointers._NamedFramebufferTextureFaceEXT_fnptr((int)framebuffer, (uint)attachment, (int)texture, level, (uint)face);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureRenderbufferEXT(TextureHandle texture, TextureTarget target, RenderbufferHandle renderbuffer) => GLPointers._TextureRenderbufferEXT_fnptr((int)texture, (uint)target, (int)renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexRenderbufferEXT(TextureUnit texunit, TextureTarget target, RenderbufferHandle renderbuffer) => GLPointers._MultiTexRenderbufferEXT_fnptr((uint)texunit, (uint)target, (int)renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int size, VertexPointerType type, int stride, IntPtr offset) => GLPointers._VertexArrayVertexOffsetEXT_fnptr((int)vaobj, (int)buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayColorOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int size, ColorPointerType type, int stride, IntPtr offset) => GLPointers._VertexArrayColorOffsetEXT_fnptr((int)vaobj, (int)buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayEdgeFlagOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int stride, IntPtr offset) => GLPointers._VertexArrayEdgeFlagOffsetEXT_fnptr((int)vaobj, (int)buffer, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayIndexOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, IndexPointerType type, int stride, IntPtr offset) => GLPointers._VertexArrayIndexOffsetEXT_fnptr((int)vaobj, (int)buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayNormalOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, NormalPointerType type, int stride, IntPtr offset) => GLPointers._VertexArrayNormalOffsetEXT_fnptr((int)vaobj, (int)buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayTexCoordOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int size, TexCoordPointerType type, int stride, IntPtr offset) => GLPointers._VertexArrayTexCoordOffsetEXT_fnptr((int)vaobj, (int)buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayMultiTexCoordOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, All texunit, int size, TexCoordPointerType type, int stride, IntPtr offset) => GLPointers._VertexArrayMultiTexCoordOffsetEXT_fnptr((int)vaobj, (int)buffer, (uint)texunit, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayFogCoordOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, FogCoordinatePointerType type, int stride, IntPtr offset) => GLPointers._VertexArrayFogCoordOffsetEXT_fnptr((int)vaobj, (int)buffer, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArraySecondaryColorOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, int size, ColorPointerType type, int stride, IntPtr offset) => GLPointers._VertexArraySecondaryColorOffsetEXT_fnptr((int)vaobj, (int)buffer, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr offset) => GLPointers._VertexArrayVertexAttribOffsetEXT_fnptr((int)vaobj, (int)buffer, index, size, (uint)type, (byte)(normalized ? 1 : 0), stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribIOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribType type, int stride, IntPtr offset) => GLPointers._VertexArrayVertexAttribIOffsetEXT_fnptr((int)vaobj, (int)buffer, index, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVertexArrayEXT(VertexArrayHandle vaobj, EnableCap array) => GLPointers._EnableVertexArrayEXT_fnptr((int)vaobj, (uint)array);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVertexArrayEXT(VertexArrayHandle vaobj, EnableCap array) => GLPointers._DisableVertexArrayEXT_fnptr((int)vaobj, (uint)array);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVertexArrayAttribEXT(VertexArrayHandle vaobj, uint index) => GLPointers._EnableVertexArrayAttribEXT_fnptr((int)vaobj, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVertexArrayAttribEXT(VertexArrayHandle vaobj, uint index) => GLPointers._DisableVertexArrayAttribEXT_fnptr((int)vaobj, index);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexArrayIntegervEXT(VertexArrayHandle vaobj, VertexArrayPName pname, int* param) => GLPointers._GetVertexArrayIntegervEXT_fnptr((int)vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexArrayPointervEXT(VertexArrayHandle vaobj, VertexArrayPName pname, void** param) => GLPointers._GetVertexArrayPointervEXT_fnptr((int)vaobj, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexArrayIntegeri_vEXT(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, int* param) => GLPointers._GetVertexArrayIntegeri_vEXT_fnptr((int)vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexArrayPointeri_vEXT(VertexArrayHandle vaobj, uint index, VertexArrayPName pname, void** param) => GLPointers._GetVertexArrayPointeri_vEXT_fnptr((int)vaobj, index, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapNamedBufferRangeEXT(BufferHandle buffer, IntPtr offset, nint length, MapBufferAccessMask access) => GLPointers._MapNamedBufferRangeEXT_fnptr((int)buffer, offset, length, (uint)access);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushMappedNamedBufferRangeEXT(BufferHandle buffer, IntPtr offset, nint length) => GLPointers._FlushMappedNamedBufferRangeEXT_fnptr((int)buffer, offset, length);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferStorageEXT(BufferHandle buffer, nint size, void* data, BufferStorageMask flags) => GLPointers._NamedBufferStorageEXT_fnptr((int)buffer, size, data, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearNamedBufferDataEXT(BufferHandle buffer, SizedInternalFormat internalformat, PixelFormat format, PixelType type, void* data) => GLPointers._ClearNamedBufferDataEXT_fnptr((int)buffer, (uint)internalformat, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearNamedBufferSubDataEXT(BufferHandle buffer, SizedInternalFormat internalformat, nint offset, nint size, PixelFormat format, PixelType type, void* data) => GLPointers._ClearNamedBufferSubDataEXT_fnptr((int)buffer, (uint)internalformat, offset, size, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferParameteriEXT(FramebufferHandle framebuffer, FramebufferParameterName pname, int param) => GLPointers._NamedFramebufferParameteriEXT_fnptr((int)framebuffer, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedFramebufferParameterivEXT(FramebufferHandle framebuffer, GetFramebufferParameter pname, int* parameters) => GLPointers._GetNamedFramebufferParameterivEXT_fnptr((int)framebuffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1dEXT(ProgramHandle program, int location, double x) => GLPointers._ProgramUniform1dEXT_fnptr((int)program, location, x);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2dEXT(ProgramHandle program, int location, double x, double y) => GLPointers._ProgramUniform2dEXT_fnptr((int)program, location, x, y);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3dEXT(ProgramHandle program, int location, double x, double y, double z) => GLPointers._ProgramUniform3dEXT_fnptr((int)program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4dEXT(ProgramHandle program, int location, double x, double y, double z, double w) => GLPointers._ProgramUniform4dEXT_fnptr((int)program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1dvEXT(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform1dvEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2dvEXT(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform2dvEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3dvEXT(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform3dvEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4dvEXT(ProgramHandle program, int location, int count, double* value) => GLPointers._ProgramUniform4dvEXT_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2dvEXT(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix2dvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3dvEXT(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix3dvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4dvEXT(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix4dvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x3dvEXT(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix2x3dvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix2x4dvEXT(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix2x4dvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x2dvEXT(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix3x2dvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix3x4dvEXT(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix3x4dvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x2dvEXT(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix4x2dvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformMatrix4x3dvEXT(ProgramHandle program, int location, int count, bool transpose, double* value) => GLPointers._ProgramUniformMatrix4x3dvEXT_fnptr((int)program, location, count, (byte)(transpose ? 1 : 0), value);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureBufferRangeEXT(TextureHandle texture, TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._TextureBufferRangeEXT_fnptr((int)texture, (uint)target, (uint)internalformat, (int)buffer, offset, size);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage1DEXT(TextureHandle texture, All target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._TextureStorage1DEXT_fnptr((int)texture, (uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage2DEXT(TextureHandle texture, All target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._TextureStorage2DEXT_fnptr((int)texture, (uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage3DEXT(TextureHandle texture, All target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._TextureStorage3DEXT_fnptr((int)texture, (uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage2DMultisampleEXT(TextureHandle texture, TextureTarget target, int samples, SizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations) => GLPointers._TextureStorage2DMultisampleEXT_fnptr((int)texture, (uint)target, samples, (uint)internalformat, width, height, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorage3DMultisampleEXT(TextureHandle texture, All target, int samples, SizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => GLPointers._TextureStorage3DMultisampleEXT_fnptr((int)texture, (uint)target, samples, (uint)internalformat, width, height, depth, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayBindVertexBufferEXT(VertexArrayHandle vaobj, uint bindingindex, BufferHandle buffer, IntPtr offset, int stride) => GLPointers._VertexArrayBindVertexBufferEXT_fnptr((int)vaobj, bindingindex, (int)buffer, offset, stride);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribFormatEXT(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => GLPointers._VertexArrayVertexAttribFormatEXT_fnptr((int)vaobj, attribindex, size, (uint)type, (byte)(normalized ? 1 : 0), relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribIFormatEXT(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => GLPointers._VertexArrayVertexAttribIFormatEXT_fnptr((int)vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribLFormatEXT(VertexArrayHandle vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => GLPointers._VertexArrayVertexAttribLFormatEXT_fnptr((int)vaobj, attribindex, size, (uint)type, relativeoffset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribBindingEXT(VertexArrayHandle vaobj, uint attribindex, uint bindingindex) => GLPointers._VertexArrayVertexAttribBindingEXT_fnptr((int)vaobj, attribindex, bindingindex);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexBindingDivisorEXT(VertexArrayHandle vaobj, uint bindingindex, uint divisor) => GLPointers._VertexArrayVertexBindingDivisorEXT_fnptr((int)vaobj, bindingindex, divisor);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribLOffsetEXT(VertexArrayHandle vaobj, BufferHandle buffer, uint index, int size, VertexAttribLType type, int stride, IntPtr offset) => GLPointers._VertexArrayVertexAttribLOffsetEXT_fnptr((int)vaobj, (int)buffer, index, size, (uint)type, stride, offset);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexturePageCommitmentEXT(TextureHandle texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => GLPointers._TexturePageCommitmentEXT_fnptr((int)texture, level, xoffset, yoffset, zoffset, width, height, depth, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayVertexAttribDivisorEXT(VertexArrayHandle vaobj, uint index, uint divisor) => GLPointers._VertexArrayVertexAttribDivisorEXT_fnptr((int)vaobj, index, divisor);
            
            /// <summary> <b>[requires: GL_EXT_draw_buffers2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorMaskIndexedEXT(uint index, bool r, bool g, bool b, bool a) => GLPointers._ColorMaskIndexedEXT_fnptr(index, (byte)(r ? 1 : 0), (byte)(g ? 1 : 0), (byte)(b ? 1 : 0), (byte)(a ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_draw_instanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawArraysInstancedEXT(PrimitiveType mode, int start, int count, int primcount) => GLPointers._DrawArraysInstancedEXT_fnptr((uint)mode, start, count, primcount);
            
            /// <summary> <b>[requires: GL_EXT_draw_instanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawElementsInstancedEXT(PrimitiveType mode, int count, DrawElementsType type, void* indices, int primcount) => GLPointers._DrawElementsInstancedEXT_fnptr((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_EXT_draw_range_elements]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawRangeElementsEXT(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, void* indices) => GLPointers._DrawRangeElementsEXT_fnptr((uint)mode, start, end, count, (uint)type, indices);
            
            /// <summary> <b>[requires: GL_EXT_external_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferStorageExternalEXT(All target, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => GLPointers._BufferStorageExternalEXT_fnptr((uint)target, offset, size, clientBuffer, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_external_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferStorageExternalEXT(BufferHandle buffer, IntPtr offset, nint size, void* clientBuffer, BufferStorageMask flags) => GLPointers._NamedBufferStorageExternalEXT_fnptr((int)buffer, offset, size, clientBuffer, (uint)flags);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordfEXT(float coord) => GLPointers._FogCoordfEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordfvEXT(float* coord) => GLPointers._FogCoordfvEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoorddEXT(double coord) => GLPointers._FogCoorddEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoorddvEXT(double* coord) => GLPointers._FogCoorddvEXT_fnptr(coord);
            
            /// <summary> <b>[requires: GL_EXT_fog_coord]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordPointerEXT(FogPointerTypeEXT type, int stride, void* pointer) => GLPointers._FogCoordPointerEXT_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_blit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, BlitFramebufferFilter filter) => GLPointers._BlitFramebufferEXT_fnptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderbufferStorageMultisampleEXT(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => GLPointers._RenderbufferStorageMultisampleEXT_fnptr((uint)target, samples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsRenderbufferEXT(RenderbufferHandle renderbuffer) => GLPointers._IsRenderbufferEXT_fnptr((int)renderbuffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindRenderbufferEXT(RenderbufferTarget target, RenderbufferHandle renderbuffer) => GLPointers._BindRenderbufferEXT_fnptr((uint)target, (int)renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteRenderbuffersEXT(int n, RenderbufferHandle* renderbuffers) => GLPointers._DeleteRenderbuffersEXT_fnptr(n, (int*)renderbuffers);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenRenderbuffersEXT(int n, RenderbufferHandle* renderbuffers) => GLPointers._GenRenderbuffersEXT_fnptr(n, (int*)renderbuffers);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderbufferStorageEXT(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => GLPointers._RenderbufferStorageEXT_fnptr((uint)target, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, int* parameters) => GLPointers._GetRenderbufferParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsFramebufferEXT(FramebufferHandle framebuffer) => GLPointers._IsFramebufferEXT_fnptr((int)framebuffer) != 0;
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindFramebufferEXT(FramebufferTarget target, FramebufferHandle framebuffer) => GLPointers._BindFramebufferEXT_fnptr((uint)target, (int)framebuffer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteFramebuffersEXT(int n, FramebufferHandle* framebuffers) => GLPointers._DeleteFramebuffersEXT_fnptr(n, (int*)framebuffers);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenFramebuffersEXT(int n, FramebufferHandle* framebuffers) => GLPointers._GenFramebuffersEXT_fnptr(n, (int*)framebuffers);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static FramebufferStatus CheckFramebufferStatusEXT(FramebufferTarget target) => (FramebufferStatus) GLPointers._CheckFramebufferStatusEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTexture1DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => GLPointers._FramebufferTexture1DEXT_fnptr((uint)target, (uint)attachment, (uint)textarget, (int)texture, level);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTexture2DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level) => GLPointers._FramebufferTexture2DEXT_fnptr((uint)target, (uint)attachment, (uint)textarget, (int)texture, level);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTexture3DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, TextureHandle texture, int level, int zoffset) => GLPointers._FramebufferTexture3DEXT_fnptr((uint)target, (uint)attachment, (uint)textarget, (int)texture, level, zoffset);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferRenderbufferEXT(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, RenderbufferHandle renderbuffer) => GLPointers._FramebufferRenderbufferEXT_fnptr((uint)target, (uint)attachment, (uint)renderbuffertarget, (int)renderbuffer);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._GetFramebufferAttachmentParameterivEXT_fnptr((uint)target, (uint)attachment, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_framebuffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenerateMipmapEXT(TextureTarget target) => GLPointers._GenerateMipmapEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_geometry_shader4 | GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameteriEXT(ProgramHandle program, ProgramParameterPName pname, int value) => GLPointers._ProgramParameteriEXT_fnptr((int)program, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, int count, float* parameters) => GLPointers._ProgramEnvParameters4fvEXT_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_program_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, int count, float* parameters) => GLPointers._ProgramLocalParameters4fvEXT_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformuivEXT(ProgramHandle program, int location, uint* parameters) => GLPointers._GetUniformuivEXT_fnptr((int)program, location, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindFragDataLocationEXT(ProgramHandle program, uint color, byte* name) => GLPointers._BindFragDataLocationEXT_fnptr((int)program, color, name);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetFragDataLocationEXT(ProgramHandle program, byte* name) => GLPointers._GetFragDataLocationEXT_fnptr((int)program, name);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1uiEXT(int location, uint v0) => GLPointers._Uniform1uiEXT_fnptr(location, v0);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2uiEXT(int location, uint v0, uint v1) => GLPointers._Uniform2uiEXT_fnptr(location, v0, v1);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3uiEXT(int location, uint v0, uint v1, uint v2) => GLPointers._Uniform3uiEXT_fnptr(location, v0, v1, v2);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4uiEXT(int location, uint v0, uint v1, uint v2, uint v3) => GLPointers._Uniform4uiEXT_fnptr(location, v0, v1, v2, v3);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1uivEXT(int location, int count, uint* value) => GLPointers._Uniform1uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2uivEXT(int location, int count, uint* value) => GLPointers._Uniform2uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3uivEXT(int location, int count, uint* value) => GLPointers._Uniform3uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4uivEXT(int location, int count, uint* value) => GLPointers._Uniform4uivEXT_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1iEXT(uint index, int x) => GLPointers._VertexAttribI1iEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2iEXT(uint index, int x, int y) => GLPointers._VertexAttribI2iEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3iEXT(uint index, int x, int y, int z) => GLPointers._VertexAttribI3iEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => GLPointers._VertexAttribI4iEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1uiEXT(uint index, uint x) => GLPointers._VertexAttribI1uiEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2uiEXT(uint index, uint x, uint y) => GLPointers._VertexAttribI2uiEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => GLPointers._VertexAttribI3uiEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => GLPointers._VertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1ivEXT(uint index, int* v) => GLPointers._VertexAttribI1ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2ivEXT(uint index, int* v) => GLPointers._VertexAttribI2ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3ivEXT(uint index, int* v) => GLPointers._VertexAttribI3ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4ivEXT(uint index, int* v) => GLPointers._VertexAttribI4ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1uivEXT(uint index, uint* v) => GLPointers._VertexAttribI1uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2uivEXT(uint index, uint* v) => GLPointers._VertexAttribI2uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3uivEXT(uint index, uint* v) => GLPointers._VertexAttribI3uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4uivEXT(uint index, uint* v) => GLPointers._VertexAttribI4uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4bvEXT(uint index, sbyte* v) => GLPointers._VertexAttribI4bvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4svEXT(uint index, short* v) => GLPointers._VertexAttribI4svEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4ubvEXT(uint index, byte* v) => GLPointers._VertexAttribI4ubvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4usvEXT(uint index, ushort* v) => GLPointers._VertexAttribI4usvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers._VertexAttribIPointerEXT_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int* parameters) => GLPointers._GetVertexAttribIivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers._GetVertexAttribIuivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetHistogramEXT(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._GetHistogramEXT_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float* parameters) => GLPointers._GetHistogramParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers._GetHistogramParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMinmaxEXT(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, void* values) => GLPointers._GetMinmaxEXT_fnptr((uint)target, (byte)(reset ? 1 : 0), (uint)format, (uint)type, values);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float* parameters) => GLPointers._GetMinmaxParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int* parameters) => GLPointers._GetMinmaxParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void HistogramEXT(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink) => GLPointers._HistogramEXT_fnptr((uint)target, width, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MinmaxEXT(MinmaxTargetEXT target, InternalFormat internalformat, bool sink) => GLPointers._MinmaxEXT_fnptr((uint)target, (uint)internalformat, (byte)(sink ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResetHistogramEXT(HistogramTargetEXT target) => GLPointers._ResetHistogramEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_histogram]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResetMinmaxEXT(MinmaxTargetEXT target) => GLPointers._ResetMinmaxEXT_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_EXT_index_func]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexFuncEXT(IndexFunctionEXT func, float reference) => GLPointers._IndexFuncEXT_fnptr((uint)func, reference);
            
            /// <summary> <b>[requires: GL_EXT_index_material]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexMaterialEXT(MaterialFace face, IndexMaterialParameterEXT mode) => GLPointers._IndexMaterialEXT_fnptr((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_light_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ApplyTextureEXT(LightTextureModeEXT mode) => GLPointers._ApplyTextureEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_light_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureLightEXT(LightTexturePNameEXT pname) => GLPointers._TextureLightEXT_fnptr((uint)pname);
            
            /// <summary> <b>[requires: GL_EXT_light_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureMaterialEXT(MaterialFace face, MaterialParameter mode) => GLPointers._TextureMaterialEXT_fnptr((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUnsignedBytevEXT(GetPName pname, byte* data) => GLPointers._GetUnsignedBytevEXT_fnptr((uint)pname, data);
            
            /// <summary> <b>[requires: GL_EXT_memory_object | GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUnsignedBytei_vEXT(All target, uint index, byte* data) => GLPointers._GetUnsignedBytei_vEXT_fnptr((uint)target, index, data);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteMemoryObjectsEXT(int n, uint* memoryObjects) => GLPointers._DeleteMemoryObjectsEXT_fnptr(n, memoryObjects);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsMemoryObjectEXT(uint memoryObject) => GLPointers._IsMemoryObjectEXT_fnptr(memoryObject) != 0;
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreateMemoryObjectsEXT(int n, uint* memoryObjects) => GLPointers._CreateMemoryObjectsEXT_fnptr(n, memoryObjects);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => GLPointers._MemoryObjectParameterivEXT_fnptr(memoryObject, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int* parameters) => GLPointers._GetMemoryObjectParameterivEXT_fnptr(memoryObject, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem2DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => GLPointers._TexStorageMem2DEXT_fnptr((uint)target, levels, (uint)internalFormat, width, height, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem2DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._TexStorageMem2DMultisampleEXT_fnptr((uint)target, samples, (uint)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem3DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => GLPointers._TexStorageMem3DEXT_fnptr((uint)target, levels, (uint)internalFormat, width, height, depth, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem3DMultisampleEXT(TextureTarget target, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._TexStorageMem3DMultisampleEXT_fnptr((uint)target, samples, (uint)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferStorageMemEXT(BufferTargetARB target, nint size, uint memory, ulong offset) => GLPointers._BufferStorageMemEXT_fnptr((uint)target, size, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem2DEXT(TextureHandle texture, int levels, SizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset) => GLPointers._TextureStorageMem2DEXT_fnptr((int)texture, levels, (uint)internalFormat, width, height, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem2DMultisampleEXT(TextureHandle texture, int samples, SizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._TextureStorageMem2DMultisampleEXT_fnptr((int)texture, samples, (uint)internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem3DEXT(TextureHandle texture, int levels, SizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset) => GLPointers._TextureStorageMem3DEXT_fnptr((int)texture, levels, (uint)internalFormat, width, height, depth, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem3DMultisampleEXT(TextureHandle texture, int samples, SizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) => GLPointers._TextureStorageMem3DMultisampleEXT_fnptr((int)texture, samples, (uint)internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0), memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferStorageMemEXT(BufferHandle buffer, nint size, uint memory, ulong offset) => GLPointers._NamedBufferStorageMemEXT_fnptr((int)buffer, size, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorageMem1DEXT(TextureTarget target, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => GLPointers._TexStorageMem1DEXT_fnptr((uint)target, levels, (uint)internalFormat, width, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureStorageMem1DEXT(TextureHandle texture, int levels, SizedInternalFormat internalFormat, int width, uint memory, ulong offset) => GLPointers._TextureStorageMem1DEXT_fnptr((int)texture, levels, (uint)internalFormat, width, memory, offset);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_fd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportMemoryFdEXT(uint memory, ulong size, ExternalHandleType handleType, int fd) => GLPointers._ImportMemoryFdEXT_fnptr(memory, size, (uint)handleType, fd);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_win32]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportMemoryWin32HandleEXT(uint memory, ulong size, ExternalHandleType handleType, void* handle) => GLPointers._ImportMemoryWin32HandleEXT_fnptr(memory, size, (uint)handleType, handle);
            
            /// <summary> <b>[requires: GL_EXT_memory_object_win32]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportMemoryWin32NameEXT(uint memory, ulong size, ExternalHandleType handleType, void* name) => GLPointers._ImportMemoryWin32NameEXT_fnptr(memory, size, (uint)handleType, name);
            
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysEXT(PrimitiveType mode, int* first, int* count, int primcount) => GLPointers._MultiDrawArraysEXT_fnptr((uint)mode, first, count, primcount);
            
            /// <summary> <b>[requires: GL_EXT_multi_draw_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsEXT(PrimitiveType mode, int* count, DrawElementsType type, void** indices, int primcount) => GLPointers._MultiDrawElementsEXT_fnptr((uint)mode, count, (uint)type, indices, primcount);
            
            /// <summary> <b>[requires: GL_EXT_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleMaskEXT(float value, bool invert) => GLPointers._SampleMaskEXT_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SamplePatternEXT(SamplePatternEXT pattern) => GLPointers._SamplePatternEXT_fnptr((uint)pattern);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorTableEXT(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, void* table) => GLPointers._ColorTableEXT_fnptr((uint)target, (uint)internalFormat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableEXT(ColorTableTarget target, PixelFormat format, PixelType type, void* data) => GLPointers._GetColorTableEXT_fnptr((uint)target, (uint)format, (uint)type, data);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableParameterivEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, int* parameters) => GLPointers._GetColorTableParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_paletted_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableParameterfvEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, float* parameters) => GLPointers._GetColorTableParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransformParameteriEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int param) => GLPointers._PixelTransformParameteriEXT_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransformParameterfEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float param) => GLPointers._PixelTransformParameterfEXT_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int* parameters) => GLPointers._PixelTransformParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float* parameters) => GLPointers._PixelTransformParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelTransformParameterivEXT(All target, All pname, int* parameters) => GLPointers._GetPixelTransformParameterivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_pixel_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelTransformParameterfvEXT(All target, All pname, float* parameters) => GLPointers._GetPixelTransformParameterfvEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfEXT(PointParameterNameARB pname, float param) => GLPointers._PointParameterfEXT_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_EXT_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfvEXT(PointParameterNameARB pname, float* parameters) => GLPointers._PointParameterfvEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_polygon_offset]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PolygonOffsetEXT(float factor, float bias) => GLPointers._PolygonOffsetEXT_fnptr(factor, bias);
            
            /// <summary> <b>[requires: GL_EXT_polygon_offset_clamp]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PolygonOffsetClampEXT(float factor, float units, float clamp) => GLPointers._PolygonOffsetClampEXT_fnptr(factor, units, clamp);
            
            /// <summary> <b>[requires: GL_EXT_provoking_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProvokingVertexEXT(VertexProvokingMode mode) => GLPointers._ProvokingVertexEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterSamplesEXT(uint samples, bool fixedsamplelocations) => GLPointers._RasterSamplesEXT_fnptr(samples, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenSemaphoresEXT(int n, uint* semaphores) => GLPointers._GenSemaphoresEXT_fnptr(n, semaphores);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteSemaphoresEXT(int n, uint* semaphores) => GLPointers._DeleteSemaphoresEXT_fnptr(n, semaphores);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsSemaphoreEXT(uint semaphore) => GLPointers._IsSemaphoreEXT_fnptr(semaphore) != 0;
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => GLPointers._SemaphoreParameterui64vEXT_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetSemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, ulong* parameters) => GLPointers._GetSemaphoreParameterui64vEXT_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, BufferHandle* buffers, uint numTextureBarriers, TextureHandle* textures, TextureLayout* srcLayouts) => GLPointers._WaitSemaphoreEXT_fnptr(semaphore, numBufferBarriers, (int*)buffers, numTextureBarriers, (int*)textures, (uint*)srcLayouts);
            
            /// <summary> <b>[requires: GL_EXT_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, BufferHandle* buffers, uint numTextureBarriers, TextureHandle* textures, TextureLayout* dstLayouts) => GLPointers._SignalSemaphoreEXT_fnptr(semaphore, numBufferBarriers, (int*)buffers, numTextureBarriers, (int*)textures, (uint*)dstLayouts);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_fd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportSemaphoreFdEXT(uint semaphore, ExternalHandleType handleType, int fd) => GLPointers._ImportSemaphoreFdEXT_fnptr(semaphore, (uint)handleType, fd);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_win32]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportSemaphoreWin32HandleEXT(uint semaphore, ExternalHandleType handleType, void* handle) => GLPointers._ImportSemaphoreWin32HandleEXT_fnptr(semaphore, (uint)handleType, handle);
            
            /// <summary> <b>[requires: GL_EXT_semaphore_win32]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImportSemaphoreWin32NameEXT(uint semaphore, ExternalHandleType handleType, void* name) => GLPointers._ImportSemaphoreWin32NameEXT_fnptr(semaphore, (uint)handleType, name);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3bEXT(sbyte red, sbyte green, sbyte blue) => GLPointers._SecondaryColor3bEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3bvEXT(sbyte* v) => GLPointers._SecondaryColor3bvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3dEXT(double red, double green, double blue) => GLPointers._SecondaryColor3dEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3dvEXT(double* v) => GLPointers._SecondaryColor3dvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3fEXT(float red, float green, float blue) => GLPointers._SecondaryColor3fEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3fvEXT(float* v) => GLPointers._SecondaryColor3fvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3iEXT(int red, int green, int blue) => GLPointers._SecondaryColor3iEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3ivEXT(int* v) => GLPointers._SecondaryColor3ivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3sEXT(short red, short green, short blue) => GLPointers._SecondaryColor3sEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3svEXT(short* v) => GLPointers._SecondaryColor3svEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3ubEXT(byte red, byte green, byte blue) => GLPointers._SecondaryColor3ubEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3ubvEXT(byte* v) => GLPointers._SecondaryColor3ubvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3uiEXT(uint red, uint green, uint blue) => GLPointers._SecondaryColor3uiEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3uivEXT(uint* v) => GLPointers._SecondaryColor3uivEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3usEXT(ushort red, ushort green, ushort blue) => GLPointers._SecondaryColor3usEXT_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3usvEXT(ushort* v) => GLPointers._SecondaryColor3usvEXT_fnptr(v);
            
            /// <summary> <b>[requires: GL_EXT_secondary_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColorPointerEXT(int size, ColorPointerType type, int stride, void* pointer) => GLPointers._SecondaryColorPointerEXT_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UseShaderProgramEXT(All type, ProgramHandle program) => GLPointers._UseShaderProgramEXT_fnptr((uint)type, (int)program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveProgramEXT(ProgramHandle program) => GLPointers._ActiveProgramEXT_fnptr((int)program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ProgramHandle CreateShaderProgramEXT(ShaderType type, byte* str) => (ProgramHandle) GLPointers._CreateShaderProgramEXT_fnptr((uint)type, str);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveShaderProgramEXT(ProgramPipelineHandle pipeline, ProgramHandle program) => GLPointers._ActiveShaderProgramEXT_fnptr((int)pipeline, (int)program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindProgramPipelineEXT(ProgramPipelineHandle pipeline) => GLPointers._BindProgramPipelineEXT_fnptr((int)pipeline);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ProgramHandle CreateShaderProgramvEXT(ShaderType type, int count, byte** strings) => (ProgramHandle) GLPointers._CreateShaderProgramvEXT_fnptr((uint)type, count, strings);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteProgramPipelinesEXT(int n, ProgramPipelineHandle* pipelines) => GLPointers._DeleteProgramPipelinesEXT_fnptr(n, (int*)pipelines);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenProgramPipelinesEXT(int n, ProgramPipelineHandle* pipelines) => GLPointers._GenProgramPipelinesEXT_fnptr(n, (int*)pipelines);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramPipelineInfoLogEXT(ProgramPipelineHandle pipeline, int bufSize, int* length, byte* infoLog) => GLPointers._GetProgramPipelineInfoLogEXT_fnptr((int)pipeline, bufSize, length, infoLog);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramPipelineivEXT(ProgramPipelineHandle pipeline, PipelineParameterName pname, int* parameters) => GLPointers._GetProgramPipelineivEXT_fnptr((int)pipeline, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsProgramPipelineEXT(ProgramPipelineHandle pipeline) => GLPointers._IsProgramPipelineEXT_fnptr((int)pipeline) != 0;
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UseProgramStagesEXT(ProgramPipelineHandle pipeline, UseProgramStageMask stages, ProgramHandle program) => GLPointers._UseProgramStagesEXT_fnptr((int)pipeline, (uint)stages, (int)program);
            
            /// <summary> <b>[requires: GL_EXT_separate_shader_objects]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ValidateProgramPipelineEXT(ProgramPipelineHandle pipeline) => GLPointers._ValidateProgramPipelineEXT_fnptr((int)pipeline);
            
            /// <summary> <b>[requires: GL_EXT_shader_framebuffer_fetch_non_coherent]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferFetchBarrierEXT() => GLPointers._FramebufferFetchBarrierEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindImageTextureEXT(uint index, TextureHandle texture, int level, bool layered, int layer, BufferAccessARB access, int format) => GLPointers._BindImageTextureEXT_fnptr(index, (int)texture, level, (byte)(layered ? 1 : 0), layer, (uint)access, format);
            
            /// <summary> <b>[requires: GL_EXT_shader_image_load_store]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MemoryBarrierEXT(MemoryBarrierMask barriers) => GLPointers._MemoryBarrierEXT_fnptr((uint)barriers);
            
            /// <summary> <b>[requires: GL_EXT_stencil_clear_tag]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilClearTagEXT(int stencilTagBits, uint stencilClearTag) => GLPointers._StencilClearTagEXT_fnptr(stencilTagBits, stencilClearTag);
            
            /// <summary> <b>[requires: GL_EXT_stencil_two_side]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveStencilFaceEXT(StencilFaceDirection face) => GLPointers._ActiveStencilFaceEXT_fnptr((uint)face);
            
            /// <summary> <b>[requires: GL_EXT_subtexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexSubImage1DEXT(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexSubImage1DEXT_fnptr((uint)target, level, xoffset, width, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_subtexture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexSubImage2DEXT_fnptr((uint)target, level, xoffset, yoffset, width, height, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture3D]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexImage3DEXT(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexImage3DEXT_fnptr((uint)target, level, (uint)internalformat, width, height, depth, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture3D]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexSubImage3DEXT_fnptr((uint)target, level, xoffset, yoffset, zoffset, width, height, depth, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => GLPointers._FramebufferTextureLayerEXT_fnptr((uint)target, (uint)attachment, (int)texture, level, layer);
            
            /// <summary> <b>[requires: GL_EXT_texture_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexBufferEXT(TextureTarget target, SizedInternalFormat internalformat, BufferHandle buffer) => GLPointers._TexBufferEXT_fnptr((uint)target, (uint)internalformat, (int)buffer);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, int* parameters) => GLPointers._TexParameterIivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, uint* parameters) => GLPointers._TexParameterIuivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._GetTexParameterIivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, uint* parameters) => GLPointers._GetTexParameterIuivEXT_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearColorIiEXT(int red, int green, int blue, int alpha) => GLPointers._ClearColorIiEXT_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_texture_integer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearColorIuiEXT(uint red, uint green, uint blue, uint alpha) => GLPointers._ClearColorIuiEXT_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool AreTexturesResidentEXT(int n, TextureHandle* textures, bool* residences) => GLPointers._AreTexturesResidentEXT_fnptr(n, (int*)textures, (byte*)residences) != 0;
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindTextureEXT(TextureTarget target, TextureHandle texture) => GLPointers._BindTextureEXT_fnptr((uint)target, (int)texture);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteTexturesEXT(int n, TextureHandle* textures) => GLPointers._DeleteTexturesEXT_fnptr(n, (int*)textures);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenTexturesEXT(int n, TextureHandle* textures) => GLPointers._GenTexturesEXT_fnptr(n, (int*)textures);
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsTextureEXT(TextureHandle texture) => GLPointers._IsTextureEXT_fnptr((int)texture) != 0;
            
            /// <summary> <b>[requires: GL_EXT_texture_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrioritizeTexturesEXT(int n, TextureHandle* textures, float* priorities) => GLPointers._PrioritizeTexturesEXT_fnptr(n, (int*)textures, priorities);
            
            /// <summary> <b>[requires: GL_EXT_texture_perturb_normal]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureNormalEXT(TextureNormalModeEXT mode) => GLPointers._TextureNormalEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorage1DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width) => GLPointers._TexStorage1DEXT_fnptr((uint)target, levels, (uint)internalformat, width);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorage2DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height) => GLPointers._TexStorage2DEXT_fnptr((uint)target, levels, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_EXT_texture_storage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexStorage3DEXT(TextureTarget target, int levels, SizedInternalFormat internalformat, int width, int height, int depth) => GLPointers._TexStorage3DEXT_fnptr((uint)target, levels, (uint)internalformat, width, height, depth);
            
            /// <summary> <b>[requires: GL_EXT_timer_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryObjecti64vEXT(QueryHandle id, QueryObjectParameterName pname, long* parameters) => GLPointers._GetQueryObjecti64vEXT_fnptr((int)id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_timer_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetQueryObjectui64vEXT(QueryHandle id, QueryObjectParameterName pname, ulong* parameters) => GLPointers._GetQueryObjectui64vEXT_fnptr((int)id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginTransformFeedbackEXT(PrimitiveType primitiveMode) => GLPointers._BeginTransformFeedbackEXT_fnptr((uint)primitiveMode);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndTransformFeedbackEXT() => GLPointers._EndTransformFeedbackEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferRangeEXT(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._BindBufferRangeEXT_fnptr((uint)target, index, (int)buffer, offset, size);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferOffsetEXT(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset) => GLPointers._BindBufferOffsetEXT_fnptr((uint)target, index, (int)buffer, offset);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferBaseEXT(BufferTargetARB target, uint index, BufferHandle buffer) => GLPointers._BindBufferBaseEXT_fnptr((uint)target, index, (int)buffer);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformFeedbackVaryingsEXT(ProgramHandle program, int count, byte** varyings, All bufferMode) => GLPointers._TransformFeedbackVaryingsEXT_fnptr((int)program, count, varyings, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_EXT_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTransformFeedbackVaryingEXT(ProgramHandle program, uint index, int bufSize, int* length, int* size, AttributeType* type, byte* name) => GLPointers._GetTransformFeedbackVaryingEXT_fnptr((int)program, index, bufSize, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ArrayElementEXT(int i) => GLPointers._ArrayElementEXT_fnptr(i);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorPointerEXT(int size, ColorPointerType type, int stride, int count, void* pointer) => GLPointers._ColorPointerEXT_fnptr(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawArraysEXT(PrimitiveType mode, int first, int count) => GLPointers._DrawArraysEXT_fnptr((uint)mode, first, count);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EdgeFlagPointerEXT(int stride, int count, bool* pointer) => GLPointers._EdgeFlagPointerEXT_fnptr(stride, count, (byte*)pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPointervEXT(GetPointervPName pname, void** parameters) => GLPointers._GetPointervEXT_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexPointerEXT(IndexPointerType type, int stride, int count, void* pointer) => GLPointers._IndexPointerEXT_fnptr((uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalPointerEXT(NormalPointerType type, int stride, int count, void* pointer) => GLPointers._NormalPointerEXT_fnptr((uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordPointerEXT(int size, TexCoordPointerType type, int stride, int count, void* pointer) => GLPointers._TexCoordPointerEXT_fnptr(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexPointerEXT(int size, VertexPointerType type, int stride, int count, void* pointer) => GLPointers._VertexPointerEXT_fnptr(size, (uint)type, stride, count, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1dEXT(uint index, double x) => GLPointers._VertexAttribL1dEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2dEXT(uint index, double x, double y) => GLPointers._VertexAttribL2dEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3dEXT(uint index, double x, double y, double z) => GLPointers._VertexAttribL3dEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4dEXT(uint index, double x, double y, double z, double w) => GLPointers._VertexAttribL4dEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1dvEXT(uint index, double* v) => GLPointers._VertexAttribL1dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2dvEXT(uint index, double* v) => GLPointers._VertexAttribL2dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3dvEXT(uint index, double* v) => GLPointers._VertexAttribL3dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4dvEXT(uint index, double* v) => GLPointers._VertexAttribL4dvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribLPointerEXT(uint index, int size, VertexAttribLType type, int stride, void* pointer) => GLPointers._VertexAttribLPointerEXT_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_vertex_attrib_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, double* parameters) => GLPointers._GetVertexAttribLdvEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginVertexShaderEXT() => GLPointers._BeginVertexShaderEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndVertexShaderEXT() => GLPointers._EndVertexShaderEXT_fnptr();
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindVertexShaderEXT(uint id) => GLPointers._BindVertexShaderEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenVertexShadersEXT(uint range) => GLPointers._GenVertexShadersEXT_fnptr(range);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteVertexShaderEXT(uint id) => GLPointers._DeleteVertexShaderEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShaderOp1EXT(VertexShaderOpEXT op, uint res, uint arg1) => GLPointers._ShaderOp1EXT_fnptr((uint)op, res, arg1);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShaderOp2EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2) => GLPointers._ShaderOp2EXT_fnptr((uint)op, res, arg1, arg2);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShaderOp3EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2, uint arg3) => GLPointers._ShaderOp3EXT_fnptr((uint)op, res, arg1, arg2, arg3);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SwizzleEXT(uint res, uint input, VertexShaderCoordOutEXT outX, VertexShaderCoordOutEXT outY, VertexShaderCoordOutEXT outZ, VertexShaderCoordOutEXT outW) => GLPointers._SwizzleEXT_fnptr(res, input, (uint)outX, (uint)outY, (uint)outZ, (uint)outW);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WriteMaskEXT(uint res, uint input, VertexShaderWriteMaskEXT outX, VertexShaderWriteMaskEXT outY, VertexShaderWriteMaskEXT outZ, VertexShaderWriteMaskEXT outW) => GLPointers._WriteMaskEXT_fnptr(res, input, (uint)outX, (uint)outY, (uint)outZ, (uint)outW);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void InsertComponentEXT(uint res, uint src, uint num) => GLPointers._InsertComponentEXT_fnptr(res, src, num);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ExtractComponentEXT(uint res, uint src, uint num) => GLPointers._ExtractComponentEXT_fnptr(res, src, num);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenSymbolsEXT(DataTypeEXT datatype, VertexShaderStorageTypeEXT storagetype, ParameterRangeEXT range, uint components) => GLPointers._GenSymbolsEXT_fnptr((uint)datatype, (uint)storagetype, (uint)range, components);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetInvariantEXT(uint id, ScalarType type, void* addr) => GLPointers._SetInvariantEXT_fnptr(id, (uint)type, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetLocalConstantEXT(uint id, ScalarType type, void* addr) => GLPointers._SetLocalConstantEXT_fnptr(id, (uint)type, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantbvEXT(uint id, sbyte* addr) => GLPointers._VariantbvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantsvEXT(uint id, short* addr) => GLPointers._VariantsvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantivEXT(uint id, int* addr) => GLPointers._VariantivEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantfvEXT(uint id, float* addr) => GLPointers._VariantfvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantdvEXT(uint id, double* addr) => GLPointers._VariantdvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantubvEXT(uint id, byte* addr) => GLPointers._VariantubvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantusvEXT(uint id, ushort* addr) => GLPointers._VariantusvEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantuivEXT(uint id, uint* addr) => GLPointers._VariantuivEXT_fnptr(id, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VariantPointerEXT(uint id, ScalarType type, uint stride, void* addr) => GLPointers._VariantPointerEXT_fnptr(id, (uint)type, stride, addr);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EnableVariantClientStateEXT(uint id) => GLPointers._EnableVariantClientStateEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DisableVariantClientStateEXT(uint id) => GLPointers._DisableVariantClientStateEXT_fnptr(id);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindLightParameterEXT(LightName light, LightParameter value) => GLPointers._BindLightParameterEXT_fnptr((uint)light, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindMaterialParameterEXT(MaterialFace face, MaterialParameter value) => GLPointers._BindMaterialParameterEXT_fnptr((uint)face, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindTexGenParameterEXT(TextureUnit unit, TextureCoordName coord, TextureGenParameter value) => GLPointers._BindTexGenParameterEXT_fnptr((uint)unit, (uint)coord, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindTextureUnitParameterEXT(TextureUnit unit, VertexShaderTextureUnitParameter value) => GLPointers._BindTextureUnitParameterEXT_fnptr((uint)unit, (uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint BindParameterEXT(VertexShaderParameterEXT value) => GLPointers._BindParameterEXT_fnptr((uint)value);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsVariantEnabledEXT(uint id, VariantCapEXT cap) => GLPointers._IsVariantEnabledEXT_fnptr(id, (uint)cap) != 0;
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, bool* data) => GLPointers._GetVariantBooleanvEXT_fnptr(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => GLPointers._GetVariantIntegervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => GLPointers._GetVariantFloatvEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVariantPointervEXT(uint id, GetVariantValueEXT value, void** data) => GLPointers._GetVariantPointervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, bool* data) => GLPointers._GetInvariantBooleanvEXT_fnptr(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => GLPointers._GetInvariantIntegervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => GLPointers._GetInvariantFloatvEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, bool* data) => GLPointers._GetLocalConstantBooleanvEXT_fnptr(id, (uint)value, (byte*)data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, int* data) => GLPointers._GetLocalConstantIntegervEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, float* data) => GLPointers._GetLocalConstantFloatvEXT_fnptr(id, (uint)value, data);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeightfEXT(float weight) => GLPointers._VertexWeightfEXT_fnptr(weight);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeightfvEXT(float* weight) => GLPointers._VertexWeightfvEXT_fnptr(weight);
            
            /// <summary> <b>[requires: GL_EXT_vertex_weighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeightPointerEXT(int size, VertexWeightPointerTypeEXT type, int stride, void* pointer) => GLPointers._VertexWeightPointerEXT_fnptr(size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool AcquireKeyedMutexWin32EXT(uint memory, ulong key, uint timeout) => GLPointers._AcquireKeyedMutexWin32EXT_fnptr(memory, key, timeout) != 0;
            
            /// <summary> <b>[requires: GL_EXT_win32_keyed_mutex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool ReleaseKeyedMutexWin32EXT(uint memory, ulong key) => GLPointers._ReleaseKeyedMutexWin32EXT_fnptr(memory, key) != 0;
            
            /// <summary> <b>[requires: GL_EXT_window_rectangles]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowRectanglesEXT(All mode, int count, int* box) => GLPointers._WindowRectanglesEXT_fnptr((uint)mode, count, box);
            
            /// <summary> <b>[requires: GL_EXT_x11_sync_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GLSync ImportSyncEXT(All external_sync_type, IntPtr external_sync, All flags) => (GLSync) GLPointers._ImportSyncEXT_fnptr((uint)external_sync_type, external_sync, (uint)flags);
            
        }
        public static unsafe partial class NV
        {
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreateSemaphoresNV(int n, uint* semaphores) => GLPointers._CreateSemaphoresNV_fnptr(n, semaphores);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, int* parameters) => GLPointers._SemaphoreParameterivNV_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_timeline_semaphore]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetSemaphoreParameterivNV(uint semaphore, SemaphoreParameterName pname, int* parameters) => GLPointers._GetSemaphoreParameterivNV_fnptr(semaphore, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_alpha_to_coverage_dither_control]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaToCoverageDitherControlNV(All mode) => GLPointers._AlphaToCoverageDitherControlNV_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysIndirectBindlessNV(PrimitiveType mode, void* indirect, int drawCount, int stride, int vertexBufferCount) => GLPointers._MultiDrawArraysIndirectBindlessNV_fnptr((uint)mode, indirect, drawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsIndirectBindlessNV(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int stride, int vertexBufferCount) => GLPointers._MultiDrawElementsIndirectBindlessNV_fnptr((uint)mode, (uint)type, indirect, drawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawArraysIndirectBindlessCountNV(PrimitiveType mode, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => GLPointers._MultiDrawArraysIndirectBindlessCountNV_fnptr((uint)mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_multi_draw_indirect_count]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawElementsIndirectBindlessCountNV(PrimitiveType mode, DrawElementsType type, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => GLPointers._MultiDrawElementsIndirectBindlessCountNV_fnptr((uint)mode, (uint)type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetTextureHandleNV(TextureHandle texture) => GLPointers._GetTextureHandleNV_fnptr((int)texture);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetTextureSamplerHandleNV(TextureHandle texture, SamplerHandle sampler) => GLPointers._GetTextureSamplerHandleNV_fnptr((int)texture, (int)sampler);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeTextureHandleResidentNV(ulong handle) => GLPointers._MakeTextureHandleResidentNV_fnptr(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeTextureHandleNonResidentNV(ulong handle) => GLPointers._MakeTextureHandleNonResidentNV_fnptr(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ulong GetImageHandleNV(TextureHandle texture, int level, bool layered, int layer, PixelFormat format) => GLPointers._GetImageHandleNV_fnptr((int)texture, level, (byte)(layered ? 1 : 0), layer, (uint)format);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeImageHandleResidentNV(ulong handle, All access) => GLPointers._MakeImageHandleResidentNV_fnptr(handle, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeImageHandleNonResidentNV(ulong handle) => GLPointers._MakeImageHandleNonResidentNV_fnptr(handle);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformHandleui64NV(int location, ulong value) => GLPointers._UniformHandleui64NV_fnptr(location, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UniformHandleui64vNV(int location, int count, ulong* value) => GLPointers._UniformHandleui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformHandleui64NV(ProgramHandle program, int location, ulong value) => GLPointers._ProgramUniformHandleui64NV_fnptr((int)program, location, value);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformHandleui64vNV(ProgramHandle program, int location, int count, ulong* values) => GLPointers._ProgramUniformHandleui64vNV_fnptr((int)program, location, count, values);
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsTextureHandleResidentNV(ulong handle) => GLPointers._IsTextureHandleResidentNV_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_NV_bindless_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsImageHandleResidentNV(ulong handle) => GLPointers._IsImageHandleResidentNV_fnptr(handle) != 0;
            
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendParameteriNV(All pname, int value) => GLPointers._BlendParameteriNV_fnptr((uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_blend_equation_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendBarrierNV() => GLPointers._BlendBarrierNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_clip_space_w_scaling]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ViewportPositionWScaleNV(uint index, float xcoeff, float ycoeff) => GLPointers._ViewportPositionWScaleNV_fnptr(index, xcoeff, ycoeff);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreateStatesNV(int n, uint* states) => GLPointers._CreateStatesNV_fnptr(n, states);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteStatesNV(int n, uint* states) => GLPointers._DeleteStatesNV_fnptr(n, states);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsStateNV(uint state) => GLPointers._IsStateNV_fnptr(state) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StateCaptureNV(uint state, All mode) => GLPointers._StateCaptureNV_fnptr(state, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GetCommandHeaderNV(All tokenID, uint size) => GLPointers._GetCommandHeaderNV_fnptr((uint)tokenID, size);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static ushort GetStageIndexNV(ShaderType shadertype) => GLPointers._GetStageIndexNV_fnptr((uint)shadertype);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawCommandsNV(All primitiveMode, uint buffer, IntPtr* indirects, int* sizes, uint count) => GLPointers._DrawCommandsNV_fnptr((uint)primitiveMode, buffer, indirects, sizes, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawCommandsAddressNV(All primitiveMode, ulong* indirects, int* sizes, uint count) => GLPointers._DrawCommandsAddressNV_fnptr((uint)primitiveMode, indirects, sizes, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawCommandsStatesNV(BufferHandle buffer, IntPtr* indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers._DrawCommandsStatesNV_fnptr((int)buffer, indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers._DrawCommandsStatesAddressNV_fnptr(indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreateCommandListsNV(int n, uint* lists) => GLPointers._CreateCommandListsNV_fnptr(n, lists);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteCommandListsNV(int n, uint* lists) => GLPointers._DeleteCommandListsNV_fnptr(n, lists);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsCommandListNV(uint list) => GLPointers._IsCommandListNV_fnptr(list) != 0;
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count) => GLPointers._ListDrawCommandsStatesClientNV_fnptr(list, segment, indirects, sizes, states, fbos, count);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CommandListSegmentsNV(uint list, uint segments) => GLPointers._CommandListSegmentsNV_fnptr(list, segments);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CompileCommandListNV(uint list) => GLPointers._CompileCommandListNV_fnptr(list);
            
            /// <summary> <b>[requires: GL_NV_command_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CallCommandListNV(uint list) => GLPointers._CallCommandListNV_fnptr(list);
            
            /// <summary> <b>[requires: GL_NV_conditional_render]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginConditionalRenderNV(uint id, ConditionalRenderMode mode) => GLPointers._BeginConditionalRenderNV_fnptr(id, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_conditional_render]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndConditionalRenderNV() => GLPointers._EndConditionalRenderNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_conservative_raster]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SubpixelPrecisionBiasNV(uint xbits, uint ybits) => GLPointers._SubpixelPrecisionBiasNV_fnptr(xbits, ybits);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster_dilate]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConservativeRasterParameterfNV(All pname, float value) => GLPointers._ConservativeRasterParameterfNV_fnptr((uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_conservative_raster_pre_snap_triangles]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConservativeRasterParameteriNV(All pname, int param) => GLPointers._ConservativeRasterParameteriNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_copy_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyImageSubDataNV(uint srcName, CopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => GLPointers._CopyImageSubDataNV_fnptr(srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangedNV(double zNear, double zFar) => GLPointers._DepthRangedNV_fnptr(zNear, zFar);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearDepthdNV(double depth) => GLPointers._ClearDepthdNV_fnptr(depth);
            
            /// <summary> <b>[requires: GL_NV_depth_buffer_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthBoundsdNV(double zmin, double zmax) => GLPointers._DepthBoundsdNV_fnptr(zmin, zmax);
            
            /// <summary> <b>[requires: GL_NV_draw_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawTextureNV(TextureHandle texture, SamplerHandle sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => GLPointers._DrawTextureNV_fnptr((int)texture, (int)sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawVkImageNV(ulong vkImage, SamplerHandle sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => GLPointers._DrawVkImageNV_fnptr(vkImage, (int)sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr GetVkProcAddrNV(byte* name) => GLPointers._GetVkProcAddrNV_fnptr(name);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WaitVkSemaphoreNV(ulong vkSemaphore) => GLPointers._WaitVkSemaphoreNV_fnptr(vkSemaphore);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SignalVkSemaphoreNV(ulong vkSemaphore) => GLPointers._SignalVkSemaphoreNV_fnptr(vkSemaphore);
            
            /// <summary> <b>[requires: GL_NV_draw_vulkan_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SignalVkFenceNV(ulong vkFence) => GLPointers._SignalVkFenceNV_fnptr(vkFence);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, bool packed, void* points) => GLPointers._MapControlPointsNV_fnptr((uint)target, index, (uint)type, ustride, vstride, uorder, vorder, (byte)(packed ? 1 : 0), points);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, int* parameters) => GLPointers._MapParameterivNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float* parameters) => GLPointers._MapParameterfvNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, bool packed, void* points) => GLPointers._GetMapControlPointsNV_fnptr((uint)target, index, (uint)type, ustride, vstride, (byte)(packed ? 1 : 0), points);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, int* parameters) => GLPointers._GetMapParameterivNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float* parameters) => GLPointers._GetMapParameterfvNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, int* parameters) => GLPointers._GetMapAttribParameterivNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, float* parameters) => GLPointers._GetMapAttribParameterfvNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_evaluators]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalMapsNV(EvalTargetNV target, EvalMapsModeNV mode) => GLPointers._EvalMapsNV_fnptr((uint)target, (uint)mode);
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, float* val) => GLPointers._GetMultisamplefvNV_fnptr((uint)pname, index, val);
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleMaskIndexedNV(uint index, SampleMaskNV mask) => GLPointers._SampleMaskIndexedNV_fnptr(index, (uint)mask);
            
            /// <summary> <b>[requires: GL_NV_explicit_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexRenderbufferNV(TextureTarget target, RenderbufferHandle renderbuffer) => GLPointers._TexRenderbufferNV_fnptr((uint)target, (int)renderbuffer);
            
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteFencesNV(int n, uint* fences) => GLPointers._DeleteFencesNV_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenFencesNV(int n, uint* fences) => GLPointers._GenFencesNV_fnptr(n, fences);
            
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsFenceNV(uint fence) => GLPointers._IsFenceNV_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool TestFenceNV(uint fence) => GLPointers._TestFenceNV_fnptr(fence) != 0;
            
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFenceivNV(uint fence, FenceParameterNameNV pname, int* parameters) => GLPointers._GetFenceivNV_fnptr(fence, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinishFenceNV(uint fence) => GLPointers._FinishFenceNV_fnptr(fence);
            
            /// <summary> <b>[requires: GL_NV_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SetFenceNV(uint fence, FenceConditionNV condition) => GLPointers._SetFenceNV_fnptr(fence, (uint)condition);
            
            /// <summary> <b>[requires: GL_NV_fragment_coverage_to_color]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentCoverageColorNV(uint color) => GLPointers._FragmentCoverageColorNV_fnptr(color);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramNamedParameter4fNV(ProgramHandle id, int len, byte* name, float x, float y, float z, float w) => GLPointers._ProgramNamedParameter4fNV_fnptr((int)id, len, name, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramNamedParameter4fvNV(ProgramHandle id, int len, byte* name, float* v) => GLPointers._ProgramNamedParameter4fvNV_fnptr((int)id, len, name, v);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramNamedParameter4dNV(ProgramHandle id, int len, byte* name, double x, double y, double z, double w) => GLPointers._ProgramNamedParameter4dNV_fnptr((int)id, len, name, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramNamedParameter4dvNV(ProgramHandle id, int len, byte* name, double* v) => GLPointers._ProgramNamedParameter4dvNV_fnptr((int)id, len, name, v);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramNamedParameterfvNV(ProgramHandle id, int len, byte* name, float* parameters) => GLPointers._GetProgramNamedParameterfvNV_fnptr((int)id, len, name, parameters);
            
            /// <summary> <b>[requires: GL_NV_fragment_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramNamedParameterdvNV(ProgramHandle id, int len, byte* name, double* parameters) => GLPointers._GetProgramNamedParameterdvNV_fnptr((int)id, len, name, parameters);
            
            /// <summary> <b>[requires: GL_EXT_raster_multisample | GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterSamplesEXT(uint samples, bool fixedsamplelocations) => GLPointers._RasterSamplesEXT_fnptr(samples, (byte)(fixedsamplelocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverageModulationTableNV(int n, float* v) => GLPointers._CoverageModulationTableNV_fnptr(n, v);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCoverageModulationTableNV(int bufSize, float* v) => GLPointers._GetCoverageModulationTableNV_fnptr(bufSize, v);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_mixed_samples]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverageModulationNV(All components) => GLPointers._CoverageModulationNV_fnptr((uint)components);
            
            /// <summary> <b>[requires: GL_NV_framebuffer_multisample_coverage]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderbufferStorageMultisampleCoverageNV(RenderbufferTarget target, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => GLPointers._RenderbufferStorageMultisampleCoverageNV_fnptr((uint)target, coverageSamples, colorSamples, (uint)internalformat, width, height);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramVertexLimitNV(ProgramTarget target, int limit) => GLPointers._ProgramVertexLimitNV_fnptr((uint)target, limit);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level) => GLPointers._FramebufferTextureEXT_fnptr((uint)target, (uint)attachment, (int)texture, level);
            
            /// <summary> <b>[requires: GL_EXT_texture_array | GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int layer) => GLPointers._FramebufferTextureLayerEXT_fnptr((uint)target, (uint)attachment, (int)texture, level, layer);
            
            /// <summary> <b>[requires: GL_NV_geometry_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureFaceEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, TextureTarget face) => GLPointers._FramebufferTextureFaceEXT_fnptr((uint)target, (uint)attachment, (int)texture, level, (uint)face);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers._ProgramLocalParameterI4iNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, int* parameters) => GLPointers._ProgramLocalParameterI4ivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, int count, int* parameters) => GLPointers._ProgramLocalParametersI4ivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers._ProgramLocalParameterI4uiNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers._ProgramLocalParameterI4uivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, int count, uint* parameters) => GLPointers._ProgramLocalParametersI4uivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => GLPointers._ProgramEnvParameterI4iNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, int* parameters) => GLPointers._ProgramEnvParameterI4ivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, int count, int* parameters) => GLPointers._ProgramEnvParametersI4ivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => GLPointers._ProgramEnvParameterI4uiNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers._ProgramEnvParameterI4uivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, int count, uint* parameters) => GLPointers._ProgramEnvParametersI4uivNV_fnptr((uint)target, index, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, int* parameters) => GLPointers._GetProgramLocalParameterIivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers._GetProgramLocalParameterIuivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, int* parameters) => GLPointers._GetProgramEnvParameterIivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, uint* parameters) => GLPointers._GetProgramEnvParameterIuivNV_fnptr((uint)target, index, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramSubroutineParametersuivNV(All target, int count, uint* parameters) => GLPointers._ProgramSubroutineParametersuivNV_fnptr((uint)target, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_program5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramSubroutineParameteruivNV(All target, uint index, uint* param) => GLPointers._GetProgramSubroutineParameteruivNV_fnptr((uint)target, index, param);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64NV(int location, long x) => GLPointers._Uniform1i64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64NV(int location, long x, long y) => GLPointers._Uniform2i64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64NV(int location, long x, long y, long z) => GLPointers._Uniform3i64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64NV(int location, long x, long y, long z, long w) => GLPointers._Uniform4i64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1i64vNV(int location, int count, long* value) => GLPointers._Uniform1i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2i64vNV(int location, int count, long* value) => GLPointers._Uniform2i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3i64vNV(int location, int count, long* value) => GLPointers._Uniform3i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4i64vNV(int location, int count, long* value) => GLPointers._Uniform4i64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64NV(int location, ulong x) => GLPointers._Uniform1ui64NV_fnptr(location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64NV(int location, ulong x, ulong y) => GLPointers._Uniform2ui64NV_fnptr(location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z) => GLPointers._Uniform3ui64NV_fnptr(location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._Uniform4ui64NV_fnptr(location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform1ui64vNV(int location, int count, ulong* value) => GLPointers._Uniform1ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform2ui64vNV(int location, int count, ulong* value) => GLPointers._Uniform2ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform3ui64vNV(int location, int count, ulong* value) => GLPointers._Uniform3ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniform4ui64vNV(int location, int count, ulong* value) => GLPointers._Uniform4ui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformi64vNV(ProgramHandle program, int location, long* parameters) => GLPointers._GetUniformi64vNV_fnptr((int)program, location, parameters);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64NV(ProgramHandle program, int location, long x) => GLPointers._ProgramUniform1i64NV_fnptr((int)program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64NV(ProgramHandle program, int location, long x, long y) => GLPointers._ProgramUniform2i64NV_fnptr((int)program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64NV(ProgramHandle program, int location, long x, long y, long z) => GLPointers._ProgramUniform3i64NV_fnptr((int)program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64NV(ProgramHandle program, int location, long x, long y, long z, long w) => GLPointers._ProgramUniform4i64NV_fnptr((int)program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1i64vNV(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform1i64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2i64vNV(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform2i64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3i64vNV(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform3i64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4i64vNV(ProgramHandle program, int location, int count, long* value) => GLPointers._ProgramUniform4i64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64NV(ProgramHandle program, int location, ulong x) => GLPointers._ProgramUniform1ui64NV_fnptr((int)program, location, x);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64NV(ProgramHandle program, int location, ulong x, ulong y) => GLPointers._ProgramUniform2ui64NV_fnptr((int)program, location, x, y);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64NV(ProgramHandle program, int location, ulong x, ulong y, ulong z) => GLPointers._ProgramUniform3ui64NV_fnptr((int)program, location, x, y, z);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64NV(ProgramHandle program, int location, ulong x, ulong y, ulong z, ulong w) => GLPointers._ProgramUniform4ui64NV_fnptr((int)program, location, x, y, z, w);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform1ui64vNV(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform1ui64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform2ui64vNV(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform2ui64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform3ui64vNV(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform3ui64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_gpu_shader5]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniform4ui64vNV(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniform4ui64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2hNV(Half x, Half y) => GLPointers._Vertex2hNV_fnptr((ushort)x, (ushort)y);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2hvNV(Half* v) => GLPointers._Vertex2hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3hNV(Half x, Half y, Half z) => GLPointers._Vertex3hNV_fnptr((ushort)x, (ushort)y, (ushort)z);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3hvNV(Half* v) => GLPointers._Vertex3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4hNV(Half x, Half y, Half z, Half w) => GLPointers._Vertex4hNV_fnptr((ushort)x, (ushort)y, (ushort)z, (ushort)w);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4hvNV(Half* v) => GLPointers._Vertex4hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3hNV(Half nx, Half ny, Half nz) => GLPointers._Normal3hNV_fnptr((ushort)nx, (ushort)ny, (ushort)nz);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3hvNV(Half* v) => GLPointers._Normal3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3hNV(Half red, Half green, Half blue) => GLPointers._Color3hNV_fnptr((ushort)red, (ushort)green, (ushort)blue);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3hvNV(Half* v) => GLPointers._Color3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4hNV(Half red, Half green, Half blue, Half alpha) => GLPointers._Color4hNV_fnptr((ushort)red, (ushort)green, (ushort)blue, (ushort)alpha);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4hvNV(Half* v) => GLPointers._Color4hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1hNV(Half s) => GLPointers._TexCoord1hNV_fnptr((ushort)s);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1hvNV(Half* v) => GLPointers._TexCoord1hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2hNV(Half s, Half t) => GLPointers._TexCoord2hNV_fnptr((ushort)s, (ushort)t);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2hvNV(Half* v) => GLPointers._TexCoord2hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3hNV(Half s, Half t, Half r) => GLPointers._TexCoord3hNV_fnptr((ushort)s, (ushort)t, (ushort)r);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3hvNV(Half* v) => GLPointers._TexCoord3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4hNV(Half s, Half t, Half r, Half q) => GLPointers._TexCoord4hNV_fnptr((ushort)s, (ushort)t, (ushort)r, (ushort)q);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4hvNV(Half* v) => GLPointers._TexCoord4hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1hNV(TextureUnit target, Half s) => GLPointers._MultiTexCoord1hNV_fnptr((uint)target, (ushort)s);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1hvNV(TextureUnit target, Half* v) => GLPointers._MultiTexCoord1hvNV_fnptr((uint)target, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2hNV(TextureUnit target, Half s, Half t) => GLPointers._MultiTexCoord2hNV_fnptr((uint)target, (ushort)s, (ushort)t);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2hvNV(TextureUnit target, Half* v) => GLPointers._MultiTexCoord2hvNV_fnptr((uint)target, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3hNV(TextureUnit target, Half s, Half t, Half r) => GLPointers._MultiTexCoord3hNV_fnptr((uint)target, (ushort)s, (ushort)t, (ushort)r);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3hvNV(TextureUnit target, Half* v) => GLPointers._MultiTexCoord3hvNV_fnptr((uint)target, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4hNV(TextureUnit target, Half s, Half t, Half r, Half q) => GLPointers._MultiTexCoord4hNV_fnptr((uint)target, (ushort)s, (ushort)t, (ushort)r, (ushort)q);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4hvNV(TextureUnit target, Half* v) => GLPointers._MultiTexCoord4hvNV_fnptr((uint)target, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordhNV(Half fog) => GLPointers._FogCoordhNV_fnptr((ushort)fog);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordhvNV(Half* fog) => GLPointers._FogCoordhvNV_fnptr((ushort*)fog);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3hNV(Half red, Half green, Half blue) => GLPointers._SecondaryColor3hNV_fnptr((ushort)red, (ushort)green, (ushort)blue);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColor3hvNV(Half* v) => GLPointers._SecondaryColor3hvNV_fnptr((ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeighthNV(Half weight) => GLPointers._VertexWeighthNV_fnptr((ushort)weight);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexWeighthvNV(Half* weight) => GLPointers._VertexWeighthvNV_fnptr((ushort*)weight);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1hNV(uint index, Half x) => GLPointers._VertexAttrib1hNV_fnptr(index, (ushort)x);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1hvNV(uint index, Half* v) => GLPointers._VertexAttrib1hvNV_fnptr(index, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2hNV(uint index, Half x, Half y) => GLPointers._VertexAttrib2hNV_fnptr(index, (ushort)x, (ushort)y);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2hvNV(uint index, Half* v) => GLPointers._VertexAttrib2hvNV_fnptr(index, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3hNV(uint index, Half x, Half y, Half z) => GLPointers._VertexAttrib3hNV_fnptr(index, (ushort)x, (ushort)y, (ushort)z);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3hvNV(uint index, Half* v) => GLPointers._VertexAttrib3hvNV_fnptr(index, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4hNV(uint index, Half x, Half y, Half z, Half w) => GLPointers._VertexAttrib4hNV_fnptr(index, (ushort)x, (ushort)y, (ushort)z, (ushort)w);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4hvNV(uint index, Half* v) => GLPointers._VertexAttrib4hvNV_fnptr(index, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs1hvNV(uint index, int n, Half* v) => GLPointers._VertexAttribs1hvNV_fnptr(index, n, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs2hvNV(uint index, int n, Half* v) => GLPointers._VertexAttribs2hvNV_fnptr(index, n, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs3hvNV(uint index, int n, Half* v) => GLPointers._VertexAttribs3hvNV_fnptr(index, n, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_half_float]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4hvNV(uint index, int n, Half* v) => GLPointers._VertexAttribs4hvNV_fnptr(index, n, (ushort*)v);
            
            /// <summary> <b>[requires: GL_NV_internalformat_sample_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, int* parameters) => GLPointers._GetInternalformatSampleivNV_fnptr((uint)target, (uint)internalformat, samples, (uint)pname, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RenderGpuMaskNV(All mask) => GLPointers._RenderGpuMaskNV_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastBufferSubDataNV(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, void* data) => GLPointers._MulticastBufferSubDataNV_fnptr((uint)gpuMask, (int)buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastCopyBufferSubDataNV(uint readGpu, All writeGpuMask, BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size) => GLPointers._MulticastCopyBufferSubDataNV_fnptr(readGpu, (uint)writeGpuMask, (int)readBuffer, (int)writeBuffer, readOffset, writeOffset, size);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastCopyImageSubDataNV(uint srcGpu, All dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => GLPointers._MulticastCopyImageSubDataNV_fnptr(srcGpu, (uint)dstGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, ClearBufferMask mask, All filter) => GLPointers._MulticastBlitFramebufferNV_fnptr(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, (uint)filter);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastFramebufferSampleLocationsfvNV(uint gpu, FramebufferHandle framebuffer, uint start, int count, float* v) => GLPointers._MulticastFramebufferSampleLocationsfvNV_fnptr(gpu, (int)framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastBarrierNV() => GLPointers._MulticastBarrierNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastWaitSyncNV(uint signalGpu, All waitGpuMask) => GLPointers._MulticastWaitSyncNV_fnptr(signalGpu, (uint)waitGpuMask);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastGetQueryObjectivNV(uint gpu, uint id, All pname, int* parameters) => GLPointers._MulticastGetQueryObjectivNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastGetQueryObjectuivNV(uint gpu, uint id, All pname, uint* parameters) => GLPointers._MulticastGetQueryObjectuivNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastGetQueryObjecti64vNV(uint gpu, uint id, All pname, long* parameters) => GLPointers._MulticastGetQueryObjecti64vNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastGetQueryObjectui64vNV(uint gpu, uint id, All pname, ulong* parameters) => GLPointers._MulticastGetQueryObjectui64vNV_fnptr(gpu, id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMemoryObjectDetachedResourcesuivNV(uint memory, All pname, int first, int count, uint* parameters) => GLPointers._GetMemoryObjectDetachedResourcesuivNV_fnptr(memory, (uint)pname, first, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResetMemoryObjectParameterNV(uint memory, All pname) => GLPointers._ResetMemoryObjectParameterNV_fnptr(memory, (uint)pname);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexAttachMemoryNV(TextureTarget target, uint memory, ulong offset) => GLPointers._TexAttachMemoryNV_fnptr((uint)target, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferAttachMemoryNV(BufferTargetARB target, uint memory, ulong offset) => GLPointers._BufferAttachMemoryNV_fnptr((uint)target, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureAttachMemoryNV(TextureHandle texture, uint memory, ulong offset) => GLPointers._TextureAttachMemoryNV_fnptr((int)texture, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_attachment]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferAttachMemoryNV(BufferHandle buffer, uint memory, ulong offset) => GLPointers._NamedBufferAttachMemoryNV_fnptr((int)buffer, memory, offset);
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferPageCommitmentMemNV(BufferStorageTarget target, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit) => GLPointers._BufferPageCommitmentMemNV_fnptr((uint)target, offset, size, memory, memOffset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexPageCommitmentMemNV(TextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit) => GLPointers._TexPageCommitmentMemNV_fnptr((uint)target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedBufferPageCommitmentMemNV(BufferHandle buffer, IntPtr offset, nint size, uint memory, ulong memOffset, bool commit) => GLPointers._NamedBufferPageCommitmentMemNV_fnptr((int)buffer, offset, size, memory, memOffset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_memory_object_sparse]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexturePageCommitmentMemNV(TextureHandle texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, bool commit) => GLPointers._TexturePageCommitmentMemNV_fnptr((int)texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, (byte)(commit ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawMeshTasksNV(uint first, uint count) => GLPointers._DrawMeshTasksNV_fnptr(first, count);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawMeshTasksIndirectNV(IntPtr indirect) => GLPointers._DrawMeshTasksIndirectNV_fnptr(indirect);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawMeshTasksIndirectNV(IntPtr indirect, int drawcount, int stride) => GLPointers._MultiDrawMeshTasksIndirectNV_fnptr(indirect, drawcount, stride);
            
            /// <summary> <b>[requires: GL_NV_mesh_shader]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiDrawMeshTasksIndirectCountNV(IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => GLPointers._MultiDrawMeshTasksIndirectCountNV_fnptr(indirect, drawcount, maxdrawcount, stride);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenOcclusionQueriesNV(int n, uint* ids) => GLPointers._GenOcclusionQueriesNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteOcclusionQueriesNV(int n, uint* ids) => GLPointers._DeleteOcclusionQueriesNV_fnptr(n, ids);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsOcclusionQueryNV(uint id) => GLPointers._IsOcclusionQueryNV_fnptr(id) != 0;
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginOcclusionQueryNV(uint id) => GLPointers._BeginOcclusionQueryNV_fnptr(id);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndOcclusionQueryNV() => GLPointers._EndOcclusionQueryNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, int* parameters) => GLPointers._GetOcclusionQueryivNV_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_occlusion_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, uint* parameters) => GLPointers._GetOcclusionQueryuivNV_fnptr(id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, float* parameters) => GLPointers._ProgramBufferParametersfvNV_fnptr((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, int* parameters) => GLPointers._ProgramBufferParametersIivNV_fnptr((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_parameter_buffer_object]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, uint* parameters) => GLPointers._ProgramBufferParametersIuivNV_fnptr((uint)target, bindingIndex, wordIndex, count, parameters);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenPathsNV(int range) => GLPointers._GenPathsNV_fnptr(range);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeletePathsNV(uint path, int range) => GLPointers._DeletePathsNV_fnptr(path, range);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsPathNV(uint path) => GLPointers._IsPathNV_fnptr(path) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathCommandsNV(uint path, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => GLPointers._PathCommandsNV_fnptr(path, numCommands, commands, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathCoordsNV(uint path, int numCoords, PathCoordType coordType, void* coords) => GLPointers._PathCoordsNV_fnptr(path, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, byte* commands, int numCoords, PathCoordType coordType, void* coords) => GLPointers._PathSubCommandsNV_fnptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathSubCoordsNV(uint path, int coordStart, int numCoords, PathCoordType coordType, void* coords) => GLPointers._PathSubCoordsNV_fnptr(path, coordStart, numCoords, (uint)coordType, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathStringNV(uint path, PathStringFormat format, int length, void* pathString) => GLPointers._PathStringNV_fnptr(path, (uint)format, length, pathString);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathGlyphsNV(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, int numGlyphs, PathElementType type, void* charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => GLPointers._PathGlyphsNV_fnptr(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, numGlyphs, (uint)type, charcodes, (uint)handleMissingGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathGlyphRangeNV(uint firstPathName, PathFontTarget fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => GLPointers._PathGlyphRangeNV_fnptr(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, firstGlyph, numGlyphs, (uint)handleMissingGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WeightPathsNV(uint resultPath, int numPaths, uint* paths, float* weights) => GLPointers._WeightPathsNV_fnptr(resultPath, numPaths, paths, weights);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyPathNV(uint resultPath, uint srcPath) => GLPointers._CopyPathNV_fnptr(resultPath, srcPath);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void InterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight) => GLPointers._InterpolatePathsNV_fnptr(resultPath, pathA, pathB, weight);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, float* transformValues) => GLPointers._TransformPathNV_fnptr(resultPath, srcPath, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathParameterivNV(uint path, PathParameter pname, int* value) => GLPointers._PathParameterivNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathParameteriNV(uint path, PathParameter pname, int value) => GLPointers._PathParameteriNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathParameterfvNV(uint path, PathParameter pname, float* value) => GLPointers._PathParameterfvNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathParameterfNV(uint path, PathParameter pname, float value) => GLPointers._PathParameterfNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathDashArrayNV(uint path, int dashCount, float* dashArray) => GLPointers._PathDashArrayNV_fnptr(path, dashCount, dashArray);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathStencilFuncNV(StencilFunction func, int reference, uint mask) => GLPointers._PathStencilFuncNV_fnptr((uint)func, reference, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathStencilDepthOffsetNV(float factor, float units) => GLPointers._PathStencilDepthOffsetNV_fnptr(factor, units);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilFillPathNV(uint path, PathFillMode fillMode, uint mask) => GLPointers._StencilFillPathNV_fnptr(path, (uint)fillMode, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilStrokePathNV(uint path, int reference, uint mask) => GLPointers._StencilStrokePathNV_fnptr(path, reference, mask);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float* transformValues) => GLPointers._StencilFillPathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)fillMode, mask, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float* transformValues) => GLPointers._StencilStrokePathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, reference, mask, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PathCoverDepthFuncNV(DepthFunction func) => GLPointers._PathCoverDepthFuncNV_fnptr((uint)func);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverFillPathNV(uint path, PathCoverMode coverMode) => GLPointers._CoverFillPathNV_fnptr(path, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverStrokePathNV(uint path, PathCoverMode coverMode) => GLPointers._CoverStrokePathNV_fnptr(path, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._CoverFillPathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, void* paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float* transformValues) => GLPointers._CoverStrokePathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathParameterivNV(uint path, PathParameter pname, int* value) => GLPointers._GetPathParameterivNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathParameterfvNV(uint path, PathParameter pname, float* value) => GLPointers._GetPathParameterfvNV_fnptr(path, (uint)pname, value);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathCommandsNV(uint path, byte* commands) => GLPointers._GetPathCommandsNV_fnptr(path, commands);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathCoordsNV(uint path, float* coords) => GLPointers._GetPathCoordsNV_fnptr(path, coords);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathDashArrayNV(uint path, float* dashArray) => GLPointers._GetPathDashArrayNV_fnptr(path, dashArray);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathMetricsNV(PathMetricMask metricQueryMask, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics) => GLPointers._GetPathMetricsNV_fnptr((uint)metricQueryMask, numPaths, (uint)pathNameType, paths, pathBase, stride, metrics);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathMetricRangeNV(PathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics) => GLPointers._GetPathMetricRangeNV_fnptr((uint)metricQueryMask, firstPathName, numPaths, stride, metrics);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float* returnedSpacing) => GLPointers._GetPathSpacingNV_fnptr((uint)pathListMode, numPaths, (uint)pathNameType, paths, pathBase, advanceScale, kerningScale, (uint)transformType, returnedSpacing);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsPointInFillPathNV(uint path, uint mask, float x, float y) => GLPointers._IsPointInFillPathNV_fnptr(path, mask, x, y) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsPointInStrokePathNV(uint path, float x, float y) => GLPointers._IsPointInStrokePathNV_fnptr(path, x, y) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static float GetPathLengthNV(uint path, int startSegment, int numSegments) => GLPointers._GetPathLengthNV_fnptr(path, startSegment, numSegments);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY) => GLPointers._PointAlongPathNV_fnptr(path, startSegment, numSegments, distance, x, y, tangentX, tangentY) != 0;
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoad3x2fNV(All matrixMode, float* m) => GLPointers._MatrixLoad3x2fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoad3x3fNV(All matrixMode, float* m) => GLPointers._MatrixLoad3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTranspose3x3fNV(All matrixMode, float* m) => GLPointers._MatrixLoadTranspose3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMult3x2fNV(All matrixMode, float* m) => GLPointers._MatrixMult3x2fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMult3x3fNV(All matrixMode, float* m) => GLPointers._MatrixMult3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTranspose3x3fNV(All matrixMode, float* m) => GLPointers._MatrixMultTranspose3x3fNV_fnptr((uint)matrixMode, m);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilThenCoverFillPathNV(uint path, All fillMode, uint mask, All coverMode) => GLPointers._StencilThenCoverFillPathNV_fnptr(path, (uint)fillMode, mask, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilThenCoverStrokePathNV(uint path, int reference, uint mask, All coverMode) => GLPointers._StencilThenCoverStrokePathNV_fnptr(path, reference, mask, (uint)coverMode);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilThenCoverFillPathInstancedNV(int numPaths, All pathNameType, void* paths, uint pathBase, All fillMode, uint mask, All coverMode, All transformType, float* transformValues) => GLPointers._StencilThenCoverFillPathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, (uint)fillMode, mask, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StencilThenCoverStrokePathInstancedNV(int numPaths, All pathNameType, void* paths, uint pathBase, int reference, uint mask, All coverMode, All transformType, float* transformValues) => GLPointers._StencilThenCoverStrokePathInstancedNV_fnptr(numPaths, (uint)pathNameType, paths, pathBase, reference, mask, (uint)coverMode, (uint)transformType, transformValues);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All PathGlyphIndexRangeNV(All fontTarget, void* fontName, PathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount) => (All) GLPointers._PathGlyphIndexRangeNV_fnptr((uint)fontTarget, fontName, (uint)fontStyle, pathParameterTemplate, emScale, baseAndCount);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All PathGlyphIndexArrayNV(uint firstPathName, All fontTarget, void* fontName, PathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => (All) GLPointers._PathGlyphIndexArrayNV_fnptr(firstPathName, (uint)fontTarget, fontName, (uint)fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All PathMemoryGlyphIndexArrayNV(uint firstPathName, All fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => (All) GLPointers._PathMemoryGlyphIndexArrayNV_fnptr(firstPathName, (uint)fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramPathFragmentInputGenNV(ProgramHandle program, int location, All genMode, int components, float* coeffs) => GLPointers._ProgramPathFragmentInputGenNV_fnptr((int)program, location, (uint)genMode, components, coeffs);
            
            /// <summary> <b>[requires: GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramResourcefvNV(ProgramHandle program, ProgramInterface programInterface, uint index, int propCount, All* props, int count, int* length, float* parameters) => GLPointers._GetProgramResourcefvNV_fnptr((int)program, (uint)programInterface, index, propCount, (uint*)props, count, length, parameters);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._MatrixFrustumEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadIdentityEXT(MatrixMode mode) => GLPointers._MatrixLoadIdentityEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTransposefEXT(MatrixMode mode, float* m) => GLPointers._MatrixLoadTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadTransposedEXT(MatrixMode mode, double* m) => GLPointers._MatrixLoadTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoadfEXT(MatrixMode mode, float* m) => GLPointers._MatrixLoadfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixLoaddEXT(MatrixMode mode, double* m) => GLPointers._MatrixLoaddEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTransposefEXT(MatrixMode mode, float* m) => GLPointers._MatrixMultTransposefEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultTransposedEXT(MatrixMode mode, double* m) => GLPointers._MatrixMultTransposedEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultfEXT(MatrixMode mode, float* m) => GLPointers._MatrixMultfEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixMultdEXT(MatrixMode mode, double* m) => GLPointers._MatrixMultdEXT_fnptr((uint)mode, m);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => GLPointers._MatrixOrthoEXT_fnptr((uint)mode, left, right, bottom, top, zNear, zFar);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixPopEXT(MatrixMode mode) => GLPointers._MatrixPopEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixPushEXT(MatrixMode mode) => GLPointers._MatrixPushEXT_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => GLPointers._MatrixRotatefEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => GLPointers._MatrixRotatedEXT_fnptr((uint)mode, angle, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._MatrixScalefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => GLPointers._MatrixScaledEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => GLPointers._MatrixTranslatefEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_direct_state_access | GL_NV_path_rendering]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => GLPointers._MatrixTranslatedEXT_fnptr((uint)mode, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_pixel_data_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelDataRangeNV(PixelDataRangeTargetNV target, int length, void* pointer) => GLPointers._PixelDataRangeNV_fnptr((uint)target, length, pointer);
            
            /// <summary> <b>[requires: GL_NV_pixel_data_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushPixelDataRangeNV(PixelDataRangeTargetNV target) => GLPointers._FlushPixelDataRangeNV_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_NV_point_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameteriNV(PointParameterNameARB pname, int param) => GLPointers._PointParameteriNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_point_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterivNV(PointParameterNameARB pname, int* parameters) => GLPointers._PointParameterivNV_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PresentFrameKeyedNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, uint key0, All target1, uint fill1, uint key1) => GLPointers._PresentFrameKeyedNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, (uint)type, (uint)target0, fill0, key0, (uint)target1, fill1, key1);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PresentFrameDualFillNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, All type, All target0, uint fill0, All target1, uint fill1, All target2, uint fill2, All target3, uint fill3) => GLPointers._PresentFrameDualFillNV_fnptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, (uint)type, (uint)target0, fill0, (uint)target1, fill1, (uint)target2, fill2, (uint)target3, fill3);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoivNV(uint video_slot, All pname, int* parameters) => GLPointers._GetVideoivNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideouivNV(uint video_slot, All pname, uint* parameters) => GLPointers._GetVideouivNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoi64vNV(uint video_slot, All pname, long* parameters) => GLPointers._GetVideoi64vNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_present_video]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoui64vNV(uint video_slot, All pname, ulong* parameters) => GLPointers._GetVideoui64vNV_fnptr(video_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_primitive_restart]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrimitiveRestartNV() => GLPointers._PrimitiveRestartNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_primitive_restart]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrimitiveRestartIndexNV(uint index) => GLPointers._PrimitiveRestartIndexNV_fnptr(index);
            
            /// <summary> <b>[requires: GL_NV_query_resource]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int QueryResourceNV(All queryType, int tagId, uint count, int* buffer) => GLPointers._QueryResourceNV_fnptr((uint)queryType, tagId, count, buffer);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenQueryResourceTagNV(int n, int* tagIds) => GLPointers._GenQueryResourceTagNV_fnptr(n, tagIds);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteQueryResourceTagNV(int n, int* tagIds) => GLPointers._DeleteQueryResourceTagNV_fnptr(n, tagIds);
            
            /// <summary> <b>[requires: GL_NV_query_resource_tag]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void QueryResourceTagNV(int tagId, byte* tagString) => GLPointers._QueryResourceTagNV_fnptr(tagId, tagString);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerParameterfvNV(CombinerParameterNV pname, float* parameters) => GLPointers._CombinerParameterfvNV_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerParameterfNV(CombinerParameterNV pname, float param) => GLPointers._CombinerParameterfNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerParameterivNV(CombinerParameterNV pname, int* parameters) => GLPointers._CombinerParameterivNV_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerParameteriNV(CombinerParameterNV pname, int param) => GLPointers._CombinerParameteriNV_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerInputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => GLPointers._CombinerInputNV_fnptr((uint)stage, (uint)portion, (uint)variable, (uint)input, (uint)mapping, (uint)componentUsage);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerOutputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerRegisterNV abOutput, CombinerRegisterNV cdOutput, CombinerRegisterNV sumOutput, CombinerScaleNV scale, CombinerBiasNV bias, bool abDotProduct, bool cdDotProduct, bool muxSum) => GLPointers._CombinerOutputNV_fnptr((uint)stage, (uint)portion, (uint)abOutput, (uint)cdOutput, (uint)sumOutput, (uint)scale, (uint)bias, (byte)(abDotProduct ? 1 : 0), (byte)(cdDotProduct ? 1 : 0), (byte)(muxSum ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinalCombinerInputNV(CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => GLPointers._FinalCombinerInputNV_fnptr((uint)variable, (uint)input, (uint)mapping, (uint)componentUsage);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => GLPointers._GetCombinerInputParameterfvNV_fnptr((uint)stage, (uint)portion, (uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => GLPointers._GetCombinerInputParameterivNV_fnptr((uint)stage, (uint)portion, (uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, float* parameters) => GLPointers._GetCombinerOutputParameterfvNV_fnptr((uint)stage, (uint)portion, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, int* parameters) => GLPointers._GetCombinerOutputParameterivNV_fnptr((uint)stage, (uint)portion, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, float* parameters) => GLPointers._GetFinalCombinerInputParameterfvNV_fnptr((uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, int* parameters) => GLPointers._GetFinalCombinerInputParameterivNV_fnptr((uint)variable, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => GLPointers._CombinerStageParameterfvNV_fnptr((uint)stage, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_register_combiners2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float* parameters) => GLPointers._GetCombinerStageParameterfvNV_fnptr((uint)stage, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferSampleLocationsfvNV(FramebufferTarget target, uint start, int count, float* v) => GLPointers._FramebufferSampleLocationsfvNV_fnptr((uint)target, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NamedFramebufferSampleLocationsfvNV(FramebufferHandle framebuffer, uint start, int count, float* v) => GLPointers._NamedFramebufferSampleLocationsfvNV_fnptr((int)framebuffer, start, count, v);
            
            /// <summary> <b>[requires: GL_NV_sample_locations]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResolveDepthValuesNV() => GLPointers._ResolveDepthValuesNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_scissor_exclusive]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ScissorExclusiveNV(int x, int y, int width, int height) => GLPointers._ScissorExclusiveNV_fnptr(x, y, width, height);
            
            /// <summary> <b>[requires: GL_NV_scissor_exclusive]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ScissorExclusiveArrayvNV(uint first, int count, int* v) => GLPointers._ScissorExclusiveArrayvNV_fnptr(first, count, v);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeBufferResidentNV(All target, All access) => GLPointers._MakeBufferResidentNV_fnptr((uint)target, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeBufferNonResidentNV(All target) => GLPointers._MakeBufferNonResidentNV_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsBufferResidentNV(All target) => GLPointers._IsBufferResidentNV_fnptr((uint)target) != 0;
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeNamedBufferResidentNV(BufferHandle buffer, All access) => GLPointers._MakeNamedBufferResidentNV_fnptr((int)buffer, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MakeNamedBufferNonResidentNV(BufferHandle buffer) => GLPointers._MakeNamedBufferNonResidentNV_fnptr((int)buffer);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsNamedBufferResidentNV(BufferHandle buffer) => GLPointers._IsNamedBufferResidentNV_fnptr((int)buffer) != 0;
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetBufferParameterui64vNV(BufferTargetARB target, All pname, ulong* parameters) => GLPointers._GetBufferParameterui64vNV_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNamedBufferParameterui64vNV(BufferHandle buffer, BufferPNameARB pname, ulong* parameters) => GLPointers._GetNamedBufferParameterui64vNV_fnptr((int)buffer, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetIntegerui64vNV(All value, ulong* result) => GLPointers._GetIntegerui64vNV_fnptr((uint)value, result);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniformui64NV(int location, ulong value) => GLPointers._Uniformui64NV_fnptr(location, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Uniformui64vNV(int location, int count, ulong* value) => GLPointers._Uniformui64vNV_fnptr(location, count, value);
            
            /// <summary> <b>[requires: GL_AMD_gpu_shader_int64 | GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetUniformui64vNV(ProgramHandle program, int location, ulong* parameters) => GLPointers._GetUniformui64vNV_fnptr((int)program, location, parameters);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformui64NV(ProgramHandle program, int location, ulong value) => GLPointers._ProgramUniformui64NV_fnptr((int)program, location, value);
            
            /// <summary> <b>[requires: GL_NV_shader_buffer_load]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramUniformui64vNV(ProgramHandle program, int location, int count, ulong* value) => GLPointers._ProgramUniformui64vNV_fnptr((int)program, location, count, value);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindShadingRateImageNV(TextureHandle texture) => GLPointers._BindShadingRateImageNV_fnptr((int)texture);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, All* rate) => GLPointers._GetShadingRateImagePaletteNV_fnptr(viewport, entry, (uint*)rate);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetShadingRateSampleLocationivNV(All rate, uint samples, uint index, int* location) => GLPointers._GetShadingRateSampleLocationivNV_fnptr((uint)rate, samples, index, location);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShadingRateImageBarrierNV(bool synchronize) => GLPointers._ShadingRateImageBarrierNV_fnptr((byte)(synchronize ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, All* rates) => GLPointers._ShadingRateImagePaletteNV_fnptr(viewport, first, count, (uint*)rates);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShadingRateSampleOrderNV(All order) => GLPointers._ShadingRateSampleOrderNV_fnptr((uint)order);
            
            /// <summary> <b>[requires: GL_NV_shading_rate_image]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ShadingRateSampleOrderCustomNV(All rate, uint samples, int* locations) => GLPointers._ShadingRateSampleOrderCustomNV_fnptr((uint)rate, samples, locations);
            
            /// <summary> <b>[requires: GL_NV_texture_barrier]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureBarrierNV() => GLPointers._TextureBarrierNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexImage2DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers._TexImage2DMultisampleCoverageNV_fnptr((uint)target, coverageSamples, colorSamples, internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexImage3DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers._TexImage3DMultisampleCoverageNV_fnptr((uint)target, coverageSamples, colorSamples, internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage2DMultisampleNV(TextureHandle texture, TextureTarget target, int samples, int internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers._TextureImage2DMultisampleNV_fnptr((int)texture, (uint)target, samples, internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage3DMultisampleNV(TextureHandle texture, TextureTarget target, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers._TextureImage3DMultisampleNV_fnptr((int)texture, (uint)target, samples, internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage2DMultisampleCoverageNV(TextureHandle texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) => GLPointers._TextureImage2DMultisampleCoverageNV_fnptr((int)texture, (uint)target, coverageSamples, colorSamples, internalFormat, width, height, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_texture_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureImage3DMultisampleCoverageNV(TextureHandle texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) => GLPointers._TextureImage3DMultisampleCoverageNV_fnptr((int)texture, (uint)target, coverageSamples, colorSamples, internalFormat, width, height, depth, (byte)(fixedSampleLocations ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginTransformFeedbackNV(PrimitiveType primitiveMode) => GLPointers._BeginTransformFeedbackNV_fnptr((uint)primitiveMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndTransformFeedbackNV() => GLPointers._EndTransformFeedbackNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformFeedbackAttribsNV(int count, int* attribs, All bufferMode) => GLPointers._TransformFeedbackAttribsNV_fnptr(count, attribs, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferRangeNV(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset, nint size) => GLPointers._BindBufferRangeNV_fnptr((uint)target, index, (int)buffer, offset, size);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferOffsetNV(BufferTargetARB target, uint index, BufferHandle buffer, IntPtr offset) => GLPointers._BindBufferOffsetNV_fnptr((uint)target, index, (int)buffer, offset);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindBufferBaseNV(BufferTargetARB target, uint index, BufferHandle buffer) => GLPointers._BindBufferBaseNV_fnptr((uint)target, index, (int)buffer);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformFeedbackVaryingsNV(ProgramHandle program, int count, int* locations, All bufferMode) => GLPointers._TransformFeedbackVaryingsNV_fnptr((int)program, count, locations, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ActiveVaryingNV(ProgramHandle program, byte* name) => GLPointers._ActiveVaryingNV_fnptr((int)program, name);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetVaryingLocationNV(ProgramHandle program, byte* name) => GLPointers._GetVaryingLocationNV_fnptr((int)program, name);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetActiveVaryingNV(ProgramHandle program, uint index, int bufSize, int* length, int* size, All* type, byte* name) => GLPointers._GetActiveVaryingNV_fnptr((int)program, index, bufSize, length, size, (uint*)type, name);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTransformFeedbackVaryingNV(ProgramHandle program, uint index, int* location) => GLPointers._GetTransformFeedbackVaryingNV_fnptr((int)program, index, location);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TransformFeedbackStreamAttribsNV(int count, int* attribs, int nbuffers, int* bufstreams, All bufferMode) => GLPointers._TransformFeedbackStreamAttribsNV_fnptr(count, attribs, nbuffers, bufstreams, (uint)bufferMode);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindTransformFeedbackNV(BufferTargetARB target, TransformFeedbackHandle id) => GLPointers._BindTransformFeedbackNV_fnptr((uint)target, (int)id);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteTransformFeedbacksNV(int n, TransformFeedbackHandle* ids) => GLPointers._DeleteTransformFeedbacksNV_fnptr(n, (int*)ids);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenTransformFeedbacksNV(int n, TransformFeedbackHandle* ids) => GLPointers._GenTransformFeedbacksNV_fnptr(n, (int*)ids);
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsTransformFeedbackNV(TransformFeedbackHandle id) => GLPointers._IsTransformFeedbackNV_fnptr((int)id) != 0;
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PauseTransformFeedbackNV() => GLPointers._PauseTransformFeedbackNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResumeTransformFeedbackNV() => GLPointers._ResumeTransformFeedbackNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_transform_feedback2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawTransformFeedbackNV(PrimitiveType mode, TransformFeedbackHandle id) => GLPointers._DrawTransformFeedbackNV_fnptr((uint)mode, (int)id);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUInitNV(void* vdpDevice, void* getProcAddress) => GLPointers._VDPAUInitNV_fnptr(vdpDevice, getProcAddress);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUFiniNV() => GLPointers._VDPAUFiniNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr VDPAURegisterVideoSurfaceNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => GLPointers._VDPAURegisterVideoSurfaceNV_fnptr(vdpSurface, (uint)target, numTextureNames, textureNames);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr VDPAURegisterOutputSurfaceNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames) => GLPointers._VDPAURegisterOutputSurfaceNV_fnptr(vdpSurface, (uint)target, numTextureNames, textureNames);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool VDPAUIsSurfaceNV(IntPtr surface) => GLPointers._VDPAUIsSurfaceNV_fnptr(surface) != 0;
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUUnregisterSurfaceNV(IntPtr surface) => GLPointers._VDPAUUnregisterSurfaceNV_fnptr(surface);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUGetSurfaceivNV(IntPtr surface, All pname, int count, int* length, int* values) => GLPointers._VDPAUGetSurfaceivNV_fnptr(surface, (uint)pname, count, length, values);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUSurfaceAccessNV(IntPtr surface, All access) => GLPointers._VDPAUSurfaceAccessNV_fnptr(surface, (uint)access);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUMapSurfacesNV(int numSurfaces, IntPtr* surfaces) => GLPointers._VDPAUMapSurfacesNV_fnptr(numSurfaces, surfaces);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VDPAUUnmapSurfacesNV(int numSurface, IntPtr* surfaces) => GLPointers._VDPAUUnmapSurfacesNV_fnptr(numSurface, surfaces);
            
            /// <summary> <b>[requires: GL_NV_vdpau_interop2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(void* vdpSurface, All target, int numTextureNames, uint* textureNames, bool isFrameStructure) => GLPointers._VDPAURegisterVideoSurfaceWithPictureStructureNV_fnptr(vdpSurface, (uint)target, numTextureNames, textureNames, (byte)(isFrameStructure ? 1 : 0));
            
            /// <summary> <b>[requires: GL_NV_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushVertexArrayRangeNV() => GLPointers._FlushVertexArrayRangeNV_fnptr();
            
            /// <summary> <b>[requires: GL_NV_vertex_array_range]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexArrayRangeNV(int length, void* pointer) => GLPointers._VertexArrayRangeNV_fnptr(length, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1i64NV(uint index, long x) => GLPointers._VertexAttribL1i64NV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2i64NV(uint index, long x, long y) => GLPointers._VertexAttribL2i64NV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3i64NV(uint index, long x, long y, long z) => GLPointers._VertexAttribL3i64NV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4i64NV(uint index, long x, long y, long z, long w) => GLPointers._VertexAttribL4i64NV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1i64vNV(uint index, long* v) => GLPointers._VertexAttribL1i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2i64vNV(uint index, long* v) => GLPointers._VertexAttribL2i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3i64vNV(uint index, long* v) => GLPointers._VertexAttribL3i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4i64vNV(uint index, long* v) => GLPointers._VertexAttribL4i64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1ui64NV(uint index, ulong x) => GLPointers._VertexAttribL1ui64NV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2ui64NV(uint index, ulong x, ulong y) => GLPointers._VertexAttribL2ui64NV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3ui64NV(uint index, ulong x, ulong y, ulong z) => GLPointers._VertexAttribL3ui64NV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4ui64NV(uint index, ulong x, ulong y, ulong z, ulong w) => GLPointers._VertexAttribL4ui64NV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL1ui64vNV(uint index, ulong* v) => GLPointers._VertexAttribL1ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL2ui64vNV(uint index, ulong* v) => GLPointers._VertexAttribL2ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL3ui64vNV(uint index, ulong* v) => GLPointers._VertexAttribL3ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribL4ui64vNV(uint index, ulong* v) => GLPointers._VertexAttribL4ui64vNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, long* parameters) => GLPointers._GetVertexAttribLi64vNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, ulong* parameters) => GLPointers._GetVertexAttribLui64vNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_attrib_integer_64bit]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribLFormatNV(uint index, int size, VertexAttribLType type, int stride) => GLPointers._VertexAttribLFormatNV_fnptr(index, size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BufferAddressRangeNV(All pname, uint index, ulong address, nint length) => GLPointers._BufferAddressRangeNV_fnptr((uint)pname, index, address, length);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexFormatNV(int size, VertexPointerType type, int stride) => GLPointers._VertexFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalFormatNV(All type, int stride) => GLPointers._NormalFormatNV_fnptr((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorFormatNV(int size, All type, int stride) => GLPointers._ColorFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexFormatNV(All type, int stride) => GLPointers._IndexFormatNV_fnptr((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordFormatNV(int size, All type, int stride) => GLPointers._TexCoordFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EdgeFlagFormatNV(int stride) => GLPointers._EdgeFlagFormatNV_fnptr(stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColorFormatNV(int size, ColorPointerType type, int stride) => GLPointers._SecondaryColorFormatNV_fnptr(size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordFormatNV(All type, int stride) => GLPointers._FogCoordFormatNV_fnptr((uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribFormatNV(uint index, int size, VertexAttribType type, bool normalized, int stride) => GLPointers._VertexAttribFormatNV_fnptr(index, size, (uint)type, (byte)(normalized ? 1 : 0), stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribIFormatNV(uint index, int size, VertexAttribIType type, int stride) => GLPointers._VertexAttribIFormatNV_fnptr(index, size, (uint)type, stride);
            
            /// <summary> <b>[requires: GL_NV_vertex_buffer_unified_memory]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetIntegerui64i_vNV(All value, uint index, ulong* result) => GLPointers._GetIntegerui64i_vNV_fnptr((uint)value, index, result);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool AreProgramsResidentNV(int n, ProgramHandle* programs, bool* residences) => GLPointers._AreProgramsResidentNV_fnptr(n, (int*)programs, (byte*)residences) != 0;
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindProgramNV(VertexAttribEnumNV target, ProgramHandle id) => GLPointers._BindProgramNV_fnptr((uint)target, (int)id);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteProgramsNV(int n, ProgramHandle* programs) => GLPointers._DeleteProgramsNV_fnptr(n, (int*)programs);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ExecuteProgramNV(VertexAttribEnumNV target, uint id, float* parameters) => GLPointers._ExecuteProgramNV_fnptr((uint)target, id, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GenProgramsNV(int n, ProgramHandle* programs) => GLPointers._GenProgramsNV_fnptr(n, (int*)programs);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, double* parameters) => GLPointers._GetProgramParameterdvNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, float* parameters) => GLPointers._GetProgramParameterfvNV_fnptr((uint)target, index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramivNV(ProgramHandle id, VertexAttribEnumNV pname, int* parameters) => GLPointers._GetProgramivNV_fnptr((int)id, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetProgramStringNV(ProgramHandle id, VertexAttribEnumNV pname, byte* program) => GLPointers._GetProgramStringNV_fnptr((int)id, (uint)pname, program);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTrackMatrixivNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, int* parameters) => GLPointers._GetTrackMatrixivNV_fnptr((uint)target, address, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribdvNV(uint index, VertexAttribEnumNV pname, double* parameters) => GLPointers._GetVertexAttribdvNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribfvNV(uint index, VertexAttribEnumNV pname, float* parameters) => GLPointers._GetVertexAttribfvNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribivNV(uint index, VertexAttribEnumNV pname, int* parameters) => GLPointers._GetVertexAttribivNV_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribPointervNV(uint index, VertexAttribEnumNV pname, void** pointer) => GLPointers._GetVertexAttribPointervNV_fnptr(index, (uint)pname, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsProgramNV(ProgramHandle id) => GLPointers._IsProgramNV_fnptr((int)id) != 0;
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadProgramNV(VertexAttribEnumNV target, uint id, int len, byte* program) => GLPointers._LoadProgramNV_fnptr((uint)target, id, len, program);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameter4dNV(VertexAttribEnumNV target, uint index, double x, double y, double z, double w) => GLPointers._ProgramParameter4dNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, double* v) => GLPointers._ProgramParameter4dvNV_fnptr((uint)target, index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameter4fNV(VertexAttribEnumNV target, uint index, float x, float y, float z, float w) => GLPointers._ProgramParameter4fNV_fnptr((uint)target, index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, float* v) => GLPointers._ProgramParameter4fvNV_fnptr((uint)target, index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, int count, double* v) => GLPointers._ProgramParameters4dvNV_fnptr((uint)target, index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, int count, float* v) => GLPointers._ProgramParameters4fvNV_fnptr((uint)target, index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RequestResidentProgramsNV(int n, ProgramHandle* programs) => GLPointers._RequestResidentProgramsNV_fnptr(n, (int*)programs);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TrackMatrixNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV matrix, VertexAttribEnumNV transform) => GLPointers._TrackMatrixNV_fnptr((uint)target, address, (uint)matrix, (uint)transform);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribPointerNV(uint index, int fsize, VertexAttribEnumNV type, int stride, void* pointer) => GLPointers._VertexAttribPointerNV_fnptr(index, fsize, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1dNV(uint index, double x) => GLPointers._VertexAttrib1dNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1dvNV(uint index, double* v) => GLPointers._VertexAttrib1dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1fNV(uint index, float x) => GLPointers._VertexAttrib1fNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1fvNV(uint index, float* v) => GLPointers._VertexAttrib1fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1sNV(uint index, short x) => GLPointers._VertexAttrib1sNV_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib1svNV(uint index, short* v) => GLPointers._VertexAttrib1svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2dNV(uint index, double x, double y) => GLPointers._VertexAttrib2dNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2dvNV(uint index, double* v) => GLPointers._VertexAttrib2dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2fNV(uint index, float x, float y) => GLPointers._VertexAttrib2fNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2fvNV(uint index, float* v) => GLPointers._VertexAttrib2fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2sNV(uint index, short x, short y) => GLPointers._VertexAttrib2sNV_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib2svNV(uint index, short* v) => GLPointers._VertexAttrib2svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3dNV(uint index, double x, double y, double z) => GLPointers._VertexAttrib3dNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3dvNV(uint index, double* v) => GLPointers._VertexAttrib3dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3fNV(uint index, float x, float y, float z) => GLPointers._VertexAttrib3fNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3fvNV(uint index, float* v) => GLPointers._VertexAttrib3fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3sNV(uint index, short x, short y, short z) => GLPointers._VertexAttrib3sNV_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib3svNV(uint index, short* v) => GLPointers._VertexAttrib3svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4dNV(uint index, double x, double y, double z, double w) => GLPointers._VertexAttrib4dNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4dvNV(uint index, double* v) => GLPointers._VertexAttrib4dvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4fNV(uint index, float x, float y, float z, float w) => GLPointers._VertexAttrib4fNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4fvNV(uint index, float* v) => GLPointers._VertexAttrib4fvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4sNV(uint index, short x, short y, short z, short w) => GLPointers._VertexAttrib4sNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4svNV(uint index, short* v) => GLPointers._VertexAttrib4svNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4ubNV(uint index, byte x, byte y, byte z, byte w) => GLPointers._VertexAttrib4ubNV_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttrib4ubvNV(uint index, byte* v) => GLPointers._VertexAttrib4ubvNV_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs1dvNV(uint index, int count, double* v) => GLPointers._VertexAttribs1dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs1fvNV(uint index, int count, float* v) => GLPointers._VertexAttribs1fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs1svNV(uint index, int count, short* v) => GLPointers._VertexAttribs1svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs2dvNV(uint index, int count, double* v) => GLPointers._VertexAttribs2dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs2fvNV(uint index, int count, float* v) => GLPointers._VertexAttribs2fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs2svNV(uint index, int count, short* v) => GLPointers._VertexAttribs2svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs3dvNV(uint index, int count, double* v) => GLPointers._VertexAttribs3dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs3fvNV(uint index, int count, float* v) => GLPointers._VertexAttribs3fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs3svNV(uint index, int count, short* v) => GLPointers._VertexAttribs3svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4dvNV(uint index, int count, double* v) => GLPointers._VertexAttribs4dvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4fvNV(uint index, int count, float* v) => GLPointers._VertexAttribs4fvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4svNV(uint index, int count, short* v) => GLPointers._VertexAttribs4svNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_NV_vertex_program]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribs4ubvNV(uint index, int count, byte* v) => GLPointers._VertexAttribs4ubvNV_fnptr(index, count, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1iEXT(uint index, int x) => GLPointers._VertexAttribI1iEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2iEXT(uint index, int x, int y) => GLPointers._VertexAttribI2iEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3iEXT(uint index, int x, int y, int z) => GLPointers._VertexAttribI3iEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => GLPointers._VertexAttribI4iEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1uiEXT(uint index, uint x) => GLPointers._VertexAttribI1uiEXT_fnptr(index, x);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2uiEXT(uint index, uint x, uint y) => GLPointers._VertexAttribI2uiEXT_fnptr(index, x, y);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => GLPointers._VertexAttribI3uiEXT_fnptr(index, x, y, z);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => GLPointers._VertexAttribI4uiEXT_fnptr(index, x, y, z, w);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1ivEXT(uint index, int* v) => GLPointers._VertexAttribI1ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2ivEXT(uint index, int* v) => GLPointers._VertexAttribI2ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3ivEXT(uint index, int* v) => GLPointers._VertexAttribI3ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4ivEXT(uint index, int* v) => GLPointers._VertexAttribI4ivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI1uivEXT(uint index, uint* v) => GLPointers._VertexAttribI1uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI2uivEXT(uint index, uint* v) => GLPointers._VertexAttribI2uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI3uivEXT(uint index, uint* v) => GLPointers._VertexAttribI3uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4uivEXT(uint index, uint* v) => GLPointers._VertexAttribI4uivEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4bvEXT(uint index, sbyte* v) => GLPointers._VertexAttribI4bvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4svEXT(uint index, short* v) => GLPointers._VertexAttribI4svEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4ubvEXT(uint index, byte* v) => GLPointers._VertexAttribI4ubvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribI4usvEXT(uint index, ushort* v) => GLPointers._VertexAttribI4usvEXT_fnptr(index, v);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, void* pointer) => GLPointers._VertexAttribIPointerEXT_fnptr(index, size, (uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, int* parameters) => GLPointers._GetVertexAttribIivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_EXT_gpu_shader4 | GL_NV_vertex_program4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, uint* parameters) => GLPointers._GetVertexAttribIuivEXT_fnptr(index, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginVideoCaptureNV(uint video_capture_slot) => GLPointers._BeginVideoCaptureNV_fnptr(video_capture_slot);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindVideoCaptureStreamBufferNV(uint video_capture_slot, uint stream, All frame_region, IntPtr offset) => GLPointers._BindVideoCaptureStreamBufferNV_fnptr(video_capture_slot, stream, (uint)frame_region, offset);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BindVideoCaptureStreamTextureNV(uint video_capture_slot, uint stream, All frame_region, All target, TextureHandle texture) => GLPointers._BindVideoCaptureStreamTextureNV_fnptr(video_capture_slot, stream, (uint)frame_region, (uint)target, (int)texture);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndVideoCaptureNV(uint video_capture_slot) => GLPointers._EndVideoCaptureNV_fnptr(video_capture_slot);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoCaptureivNV(uint video_capture_slot, All pname, int* parameters) => GLPointers._GetVideoCaptureivNV_fnptr(video_capture_slot, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, All pname, int* parameters) => GLPointers._GetVideoCaptureStreamivNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, All pname, float* parameters) => GLPointers._GetVideoCaptureStreamfvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, All pname, double* parameters) => GLPointers._GetVideoCaptureStreamdvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All VideoCaptureNV(uint video_capture_slot, uint* sequence_num, ulong* capture_time) => (All) GLPointers._VideoCaptureNV_fnptr(video_capture_slot, sequence_num, capture_time);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, All pname, int* parameters) => GLPointers._VideoCaptureStreamParameterivNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, All pname, float* parameters) => GLPointers._VideoCaptureStreamParameterfvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_video_capture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, All pname, double* parameters) => GLPointers._VideoCaptureStreamParameterdvNV_fnptr(video_capture_slot, stream, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_NV_viewport_swizzle]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ViewportSwizzleNV(uint index, All swizzlex, All swizzley, All swizzlez, All swizzlew) => GLPointers._ViewportSwizzleNV_fnptr(index, (uint)swizzlex, (uint)swizzley, (uint)swizzlez, (uint)swizzlew);
            
        }
        public static unsafe partial class GREMEDY
        {
            /// <summary> <b>[requires: GL_GREMEDY_frame_terminator]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FrameTerminatorGREMEDY() => GLPointers._FrameTerminatorGREMEDY_fnptr();
            
            /// <summary> <b>[requires: GL_GREMEDY_string_marker]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StringMarkerGREMEDY(int len, void* str) => GLPointers._StringMarkerGREMEDY_fnptr(len, str);
            
        }
        public static unsafe partial class HP
        {
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImageTransformParameteriHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int param) => GLPointers._ImageTransformParameteriHP_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImageTransformParameterfHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float param) => GLPointers._ImageTransformParameterfHP_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => GLPointers._ImageTransformParameterivHP_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => GLPointers._ImageTransformParameterfvHP_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int* parameters) => GLPointers._GetImageTransformParameterivHP_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_HP_image_transform]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float* parameters) => GLPointers._GetImageTransformParameterfvHP_fnptr((uint)target, (uint)pname, parameters);
            
        }
        public static unsafe partial class IBM
        {
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiModeDrawArraysIBM(PrimitiveType* mode, int* first, int* count, int primcount, int modestride) => GLPointers._MultiModeDrawArraysIBM_fnptr((uint*)mode, first, count, primcount, modestride);
            
            /// <summary> <b>[requires: GL_IBM_multimode_draw_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiModeDrawElementsIBM(PrimitiveType* mode, int* count, DrawElementsType type, void** indices, int primcount, int modestride) => GLPointers._MultiModeDrawElementsIBM_fnptr((uint*)mode, count, (uint)type, indices, primcount, modestride);
            
            /// <summary> <b>[requires: GL_IBM_static_data]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushStaticDataIBM(All target) => GLPointers._FlushStaticDataIBM_fnptr((uint)target);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorPointerListIBM(int size, ColorPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._ColorPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SecondaryColorPointerListIBM(int size, SecondaryColorPointerTypeIBM type, int stride, void** pointer, int ptrstride) => GLPointers._SecondaryColorPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EdgeFlagPointerListIBM(int stride, bool** pointer, int ptrstride) => GLPointers._EdgeFlagPointerListIBM_fnptr(stride, (byte**)pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogCoordPointerListIBM(FogPointerTypeIBM type, int stride, void** pointer, int ptrstride) => GLPointers._FogCoordPointerListIBM_fnptr((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexPointerListIBM(IndexPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._IndexPointerListIBM_fnptr((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalPointerListIBM(NormalPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._NormalPointerListIBM_fnptr((uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordPointerListIBM(int size, TexCoordPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._TexCoordPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
            /// <summary> <b>[requires: GL_IBM_vertex_array_lists]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexPointerListIBM(int size, VertexPointerType type, int stride, void** pointer, int ptrstride) => GLPointers._VertexPointerListIBM_fnptr(size, (uint)type, stride, pointer, ptrstride);
            
        }
        public static unsafe partial class INGR
        {
            /// <summary> <b>[requires: GL_INGR_blend_func_separate]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendFuncSeparateINGR(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => GLPointers._BlendFuncSeparateINGR_fnptr((uint)sfactorRGB, (uint)dfactorRGB, (uint)sfactorAlpha, (uint)dfactorAlpha);
            
        }
        public static unsafe partial class INTEL
        {
            /// <summary> <b>[requires: GL_INTEL_framebuffer_CMAA]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ApplyFramebufferAttachmentCMAAINTEL() => GLPointers._ApplyFramebufferAttachmentCMAAINTEL_fnptr();
            
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SyncTextureINTEL(TextureHandle texture) => GLPointers._SyncTextureINTEL_fnptr((int)texture);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UnmapTexture2DINTEL(TextureHandle texture, int level) => GLPointers._UnmapTexture2DINTEL_fnptr((int)texture, level);
            
            /// <summary> <b>[requires: GL_INTEL_map_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void* MapTexture2DINTEL(TextureHandle texture, int level, All access, int* stride, All* layout) => GLPointers._MapTexture2DINTEL_fnptr((int)texture, level, (uint)access, stride, (uint*)layout);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void VertexPointervINTEL(int size, VertexPointerType type, void** pointer) => GLPointers._VertexPointervINTEL_fnptr(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void NormalPointervINTEL(NormalPointerType type, void** pointer) => GLPointers._NormalPointervINTEL_fnptr((uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorPointervINTEL(int size, VertexPointerType type, void** pointer) => GLPointers._ColorPointervINTEL_fnptr(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_parallel_arrays]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoordPointervINTEL(int size, VertexPointerType type, void** pointer) => GLPointers._TexCoordPointervINTEL_fnptr(size, (uint)type, pointer);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginPerfQueryINTEL(uint queryHandle) => GLPointers._BeginPerfQueryINTEL_fnptr(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CreatePerfQueryINTEL(uint queryId, uint* queryHandle) => GLPointers._CreatePerfQueryINTEL_fnptr(queryId, queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeletePerfQueryINTEL(uint queryHandle) => GLPointers._DeletePerfQueryINTEL_fnptr(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndPerfQueryINTEL(uint queryHandle) => GLPointers._EndPerfQueryINTEL_fnptr(queryHandle);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFirstPerfQueryIdINTEL(uint* queryId) => GLPointers._GetFirstPerfQueryIdINTEL_fnptr(queryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetNextPerfQueryIdINTEL(uint queryId, uint* nextQueryId) => GLPointers._GetNextPerfQueryIdINTEL_fnptr(queryId, nextQueryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, byte* counterName, uint counterDescLength, byte* counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) => GLPointers._GetPerfCounterInfoINTEL_fnptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, void* data, uint* bytesWritten) => GLPointers._GetPerfQueryDataINTEL_fnptr(queryHandle, flags, dataSize, data, bytesWritten);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfQueryIdByNameINTEL(byte* queryName, uint* queryId) => GLPointers._GetPerfQueryIdByNameINTEL_fnptr(queryName, queryId);
            
            /// <summary> <b>[requires: GL_INTEL_performance_query]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, byte* queryName, uint* dataSize, uint* noCounters, uint* noInstances, uint* capsMask) => GLPointers._GetPerfQueryInfoINTEL_fnptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
            
        }
        public static unsafe partial class KHR
        {
            /// <summary> <b>[requires: GL_KHR_blend_equation_advanced]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendBarrierKHR() => GLPointers._BlendBarrierKHR_fnptr();
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Control the reporting of debug messages in a debug context. </summary>
            /// <param name="source"> The source of debug messages to enable or disable. </param>
            /// <param name="type"> The type of debug messages to enable or disable. </param>
            /// <param name="severity"> The severity of debug messages to enable or disable. </param>
            /// <param name="count"> The length of the array ids. </param>
            /// <param name="ids"> The address of an array of unsigned integers contianing the ids of the messages to enable or disable. </param>
            /// <param name="enabled"> A Boolean flag determining whether the selected messages should be enabled or disabled. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml" /></remarks>
            public static void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._DebugMessageControl_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Inject an application-supplied message into the debug message queue. </summary>
            /// <param name="source"> The source of the debug message to insert. </param>
            /// <param name="type"> The type of the debug message insert. </param>
            /// <param name="id"> The user-supplied identifier of the message to insert. </param>
            /// <param name="severity"> The severity of the debug messages to insert. </param>
            /// <param name="length"> The length string contained in the character array whose address is given by message. </param>
            /// <param name="message"> The address of a character array containing the message to insert. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml" /></remarks>
            public static void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._DebugMessageInsert_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Specify a callback to receive debugging messages from the GL. </summary>
            /// <param name="callback"> The address of a callback function that will be called when a debug message is generated. </param>
            /// <param name="userParam"> A user supplied pointer that will be passed on each invocation of callback. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml" /></remarks>
            public static void DebugMessageCallback(IntPtr callback, void* userParam) => GLPointers._DebugMessageCallback_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve messages from the debug message log. </summary>
            /// <param name="count"> The number of debug messages to retrieve from the log. </param>
            /// <param name="bufSize"> The size of the buffer whose address is given by messageLog. </param>
            /// <param name="sources"> The address of an array of variables to receive the sources of the retrieved messages. </param>
            /// <param name="types"> The address of an array of variables to receive the types of the retrieved messages. </param>
            /// <param name="ids"> The address of an array of unsigned integers to receive the ids of the retrieved messages. </param>
            /// <param name="severities"> The address of an array of variables to receive the severites of the retrieved messages. </param>
            /// <param name="lengths"> The address of an array of variables to receive the lengths of the received messages. </param>
            /// <param name="messageLog"> The address of an array of characters that will receive the messages. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml" /></remarks>
            public static uint GetDebugMessageLog(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._GetDebugMessageLog_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Push a named debug group into the command stream. </summary>
            /// <param name="source"> The source of the debug message. </param>
            /// <param name="id"> The identifier of the message. </param>
            /// <param name="length"> The length of the message to be sent to the debug output stream. </param>
            /// <param name="message"> The a string containing the message to be sent to the debug output stream. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml" /></remarks>
            public static void PushDebugGroup(DebugSource source, uint id, int length, byte* message) => GLPointers._PushDebugGroup_fnptr((uint)source, id, length, message);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Pop the active debug group. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml" /></remarks>
            public static void PopDebugGroup() => GLPointers._PopDebugGroup_fnptr();
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Label a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object to label. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml" /></remarks>
            public static void ObjectLabel(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers._ObjectLabel_fnptr((uint)identifier, name, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve the label of a named object identified within a namespace. </summary>
            /// <param name="identifier"> The namespace from which the name of the object is allocated. </param>
            /// <param name="name"> The name of the object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml" /></remarks>
            public static void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label) => GLPointers._GetObjectLabel_fnptr((uint)identifier, name, bufSize, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Label a sync object identified by a pointer. </summary>
            /// <param name="ptr"> A pointer identifying a sync object. </param>
            /// <param name="length"> The length of the label to be used for the object. </param>
            /// <param name="label"> The address of a string containing the label to assign to the object. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml" /></remarks>
            public static void ObjectPtrLabel(void* ptr, int length, byte* label) => GLPointers._ObjectPtrLabel_fnptr(ptr, length, label);
            
            /// <summary> <b>[requires: v4.3 | GL_KHR_debug]</b> Retrieve the label of a sync object identified by a pointer. </summary>
            /// <param name="ptr"> The name of the sync object whose label to retrieve. </param>
            /// <param name="bufSize"> The length of the buffer whose address is in label. </param>
            /// <param name="length"> The address of a variable to receive the length of the object label. </param>
            /// <param name="label"> The address of a string that will receive the object label. </param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml" /></remarks>
            public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) => GLPointers._GetObjectPtrLabel_fnptr(ptr, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageControlKHR(DebugSource source, DebugType type, DebugSeverity severity, int count, uint* ids, bool enabled) => GLPointers._DebugMessageControlKHR_fnptr((uint)source, (uint)type, (uint)severity, count, ids, (byte)(enabled ? 1 : 0));
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageInsertKHR(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, byte* buf) => GLPointers._DebugMessageInsertKHR_fnptr((uint)source, (uint)type, id, (uint)severity, length, buf);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DebugMessageCallbackKHR(IntPtr callback, void* userParam) => GLPointers._DebugMessageCallbackKHR_fnptr(callback, userParam);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GetDebugMessageLogKHR(uint count, int bufSize, DebugSource* sources, DebugType* types, uint* ids, DebugSeverity* severities, int* lengths, byte* messageLog) => GLPointers._GetDebugMessageLogKHR_fnptr(count, bufSize, (uint*)sources, (uint*)types, ids, (uint*)severities, lengths, messageLog);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PushDebugGroupKHR(DebugSource source, uint id, int length, byte* message) => GLPointers._PushDebugGroupKHR_fnptr((uint)source, id, length, message);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PopDebugGroupKHR() => GLPointers._PopDebugGroupKHR_fnptr();
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ObjectLabelKHR(ObjectIdentifier identifier, uint name, int length, byte* label) => GLPointers._ObjectLabelKHR_fnptr((uint)identifier, name, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectLabelKHR(All identifier, uint name, int bufSize, int* length, byte* label) => GLPointers._GetObjectLabelKHR_fnptr((uint)identifier, name, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ObjectPtrLabelKHR(void* ptr, int length, byte* label) => GLPointers._ObjectPtrLabelKHR_fnptr(ptr, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetObjectPtrLabelKHR(void* ptr, int bufSize, int* length, byte* label) => GLPointers._GetObjectPtrLabelKHR_fnptr(ptr, bufSize, length, label);
            
            /// <summary> <b>[requires: GL_KHR_debug]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPointervKHR(All pname, void** parameters) => GLPointers._GetPointervKHR_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Check if the rendering context has not been lost due to software or hardware issues. </summary>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml" /></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatus() => (GraphicsResetStatus) GLPointers._GetGraphicsResetStatus_fnptr();
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Read a block of pixels from the frame buffer. </summary>
            /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
            /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
            /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
            /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
            /// <param name="bufSize">Specifies the size of the buffer data for glReadnPixels function.</param>
            /// <param name="data">Returns the pixel data.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glReadPixels.xhtml" /></remarks>
            public static void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._ReadnPixels_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformfv(ProgramHandle program, int location, int bufSize, float* parameters) => GLPointers._GetnUniformfv_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformiv(ProgramHandle program, int location, int bufSize, int* parameters) => GLPointers._GetnUniformiv_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: v4.5 | GL_KHR_robustness]</b> Returns the value of a uniform variable. </summary>
            /// <param name="program">Specifies the program object to be queried.</param>
            /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
            /// <param name="bufSize">Specifies the size of the buffer params.</param>
            /// <param name="parameters">Returns the value of the specified uniform variable.</param>
            /// <remarks><see href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetUniform.xhtml" /></remarks>
            public static void GetnUniformuiv(ProgramHandle program, int location, int bufSize, uint* parameters) => GLPointers._GetnUniformuiv_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static GraphicsResetStatus GetGraphicsResetStatusKHR() => (GraphicsResetStatus) GLPointers._GetGraphicsResetStatusKHR_fnptr();
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReadnPixelsKHR(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, void* data) => GLPointers._ReadnPixelsKHR_fnptr(x, y, width, height, (uint)format, (uint)type, bufSize, data);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformfvKHR(ProgramHandle program, int location, int bufSize, float* parameters) => GLPointers._GetnUniformfvKHR_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformivKHR(ProgramHandle program, int location, int bufSize, int* parameters) => GLPointers._GetnUniformivKHR_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_robustness]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetnUniformuivKHR(ProgramHandle program, int location, int bufSize, uint* parameters) => GLPointers._GetnUniformuivKHR_fnptr((int)program, location, bufSize, parameters);
            
            /// <summary> <b>[requires: GL_KHR_parallel_shader_compile]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MaxShaderCompilerThreadsKHR(uint count) => GLPointers._MaxShaderCompilerThreadsKHR_fnptr(count);
            
        }
        public static unsafe partial class MESA
        {
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferParameteriMESA(FramebufferTarget target, FramebufferParameterName pname, int param) => GLPointers._FramebufferParameteriMESA_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_MESA_framebuffer_flip_y]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, int* parameters) => GLPointers._GetFramebufferParameterivMESA_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_MESA_resize_buffers]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ResizeBuffersMESA() => GLPointers._ResizeBuffersMESA_fnptr();
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2dMESA(double x, double y) => GLPointers._WindowPos2dMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2dvMESA(double* v) => GLPointers._WindowPos2dvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2fMESA(float x, float y) => GLPointers._WindowPos2fMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2fvMESA(float* v) => GLPointers._WindowPos2fvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2iMESA(int x, int y) => GLPointers._WindowPos2iMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2ivMESA(int* v) => GLPointers._WindowPos2ivMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2sMESA(short x, short y) => GLPointers._WindowPos2sMESA_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos2svMESA(short* v) => GLPointers._WindowPos2svMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3dMESA(double x, double y, double z) => GLPointers._WindowPos3dMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3dvMESA(double* v) => GLPointers._WindowPos3dvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3fMESA(float x, float y, float z) => GLPointers._WindowPos3fMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3fvMESA(float* v) => GLPointers._WindowPos3fvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3iMESA(int x, int y, int z) => GLPointers._WindowPos3iMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3ivMESA(int* v) => GLPointers._WindowPos3ivMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3sMESA(short x, short y, short z) => GLPointers._WindowPos3sMESA_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos3svMESA(short* v) => GLPointers._WindowPos3svMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4dMESA(double x, double y, double z, double w) => GLPointers._WindowPos4dMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4dvMESA(double* v) => GLPointers._WindowPos4dvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4fMESA(float x, float y, float z, float w) => GLPointers._WindowPos4fMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4fvMESA(float* v) => GLPointers._WindowPos4fvMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4iMESA(int x, int y, int z, int w) => GLPointers._WindowPos4iMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4ivMESA(int* v) => GLPointers._WindowPos4ivMESA_fnptr(v);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4sMESA(short x, short y, short z, short w) => GLPointers._WindowPos4sMESA_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_MESA_window_pos]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WindowPos4svMESA(short* v) => GLPointers._WindowPos4svMESA_fnptr(v);
            
        }
        public static unsafe partial class NVX
        {
            /// <summary> <b>[requires: GL_NVX_conditional_render]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BeginConditionalRenderNVX(uint id) => GLPointers._BeginConditionalRenderNVX_fnptr(id);
            
            /// <summary> <b>[requires: GL_NVX_conditional_render]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EndConditionalRenderNVX() => GLPointers._EndConditionalRenderNVX_fnptr();
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LGPUNamedBufferSubDataNVX(All gpuMask, BufferHandle buffer, IntPtr offset, nint size, void* data) => GLPointers._LGPUNamedBufferSubDataNVX_fnptr((uint)gpuMask, (int)buffer, offset, size, data);
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LGPUCopyImageSubDataNVX(uint sourceGpu, All destinationGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => GLPointers._LGPUCopyImageSubDataNVX_fnptr(sourceGpu, (uint)destinationGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srxY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
            
            /// <summary> <b>[requires: GL_NVX_linked_gpu_multicast]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LGPUInterlockNVX() => GLPointers._LGPUInterlockNVX_fnptr();
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void UploadGpuMaskNVX(All mask) => GLPointers._UploadGpuMaskNVX_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastViewportArrayvNVX(uint gpu, uint first, int count, float* v) => GLPointers._MulticastViewportArrayvNVX_fnptr(gpu, first, count, v);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastViewportPositionWScaleNVX(uint gpu, uint index, float xcoeff, float ycoeff) => GLPointers._MulticastViewportPositionWScaleNVX_fnptr(gpu, index, xcoeff, ycoeff);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MulticastScissorArrayvNVX(uint gpu, uint first, int count, int* v) => GLPointers._MulticastScissorArrayvNVX_fnptr(gpu, first, count, v);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, All writeGpuMask, BufferHandle readBuffer, BufferHandle writeBuffer, IntPtr readOffset, IntPtr writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => GLPointers._AsyncCopyBufferSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, (uint)writeGpuMask, (int)readBuffer, (int)writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            
            /// <summary> <b>[requires: GL_NVX_gpu_multicast2]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, All dstGpuMask, uint srcName, All srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, All dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray) => GLPointers._AsyncCopyImageSubDataNVX_fnptr(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, (uint)dstGpuMask, srcName, (uint)srcTarget, srcLevel, srcX, srcY, srcZ, dstName, (uint)dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint CreateProgressFenceNVX() => GLPointers._CreateProgressFenceNVX_fnptr();
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers._SignalSemaphoreui64NVX_fnptr(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers._WaitSemaphoreui64NVX_fnptr(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
            
            /// <summary> <b>[requires: GL_NVX_progress_fence]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClientWaitSemaphoreui64NVX(int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray) => GLPointers._ClientWaitSemaphoreui64NVX_fnptr(fenceObjectCount, semaphoreArray, fenceValueArray);
            
        }
        public static unsafe partial class OES
        {
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1bOES(TextureUnit texture, sbyte s) => GLPointers._MultiTexCoord1bOES_fnptr((uint)texture, s);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1bvOES(TextureUnit texture, sbyte* coords) => GLPointers._MultiTexCoord1bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2bOES(TextureUnit texture, sbyte s, sbyte t) => GLPointers._MultiTexCoord2bOES_fnptr((uint)texture, s, t);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2bvOES(TextureUnit texture, sbyte* coords) => GLPointers._MultiTexCoord2bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r) => GLPointers._MultiTexCoord3bOES_fnptr((uint)texture, s, t, r);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3bvOES(TextureUnit texture, sbyte* coords) => GLPointers._MultiTexCoord3bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r, sbyte q) => GLPointers._MultiTexCoord4bOES_fnptr((uint)texture, s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4bvOES(TextureUnit texture, sbyte* coords) => GLPointers._MultiTexCoord4bvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1bOES(sbyte s) => GLPointers._TexCoord1bOES_fnptr(s);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1bvOES(sbyte* coords) => GLPointers._TexCoord1bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2bOES(sbyte s, sbyte t) => GLPointers._TexCoord2bOES_fnptr(s, t);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2bvOES(sbyte* coords) => GLPointers._TexCoord2bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3bOES(sbyte s, sbyte t, sbyte r) => GLPointers._TexCoord3bOES_fnptr(s, t, r);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3bvOES(sbyte* coords) => GLPointers._TexCoord3bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4bOES(sbyte s, sbyte t, sbyte r, sbyte q) => GLPointers._TexCoord4bOES_fnptr(s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4bvOES(sbyte* coords) => GLPointers._TexCoord4bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2bOES(sbyte x, sbyte y) => GLPointers._Vertex2bOES_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2bvOES(sbyte* coords) => GLPointers._Vertex2bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3bOES(sbyte x, sbyte y, sbyte z) => GLPointers._Vertex3bOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3bvOES(sbyte* coords) => GLPointers._Vertex3bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4bOES(sbyte x, sbyte y, sbyte z, sbyte w) => GLPointers._Vertex4bOES_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_OES_byte_coordinates]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4bvOES(sbyte* coords) => GLPointers._Vertex4bvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AlphaFuncxOES(AlphaFunction func, int reference) => GLPointers._AlphaFuncxOES_fnptr((uint)func, reference);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearColorxOES(int red, int green, int blue, int alpha) => GLPointers._ClearColorxOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearDepthxOES(int depth) => GLPointers._ClearDepthxOES_fnptr(depth);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClipPlanexOES(ClipPlaneName plane, int* equation) => GLPointers._ClipPlanexOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4xOES(int red, int green, int blue, int alpha) => GLPointers._Color4xOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangexOES(int n, int f) => GLPointers._DepthRangexOES_fnptr(n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogxOES(FogPName pname, int param) => GLPointers._FogxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogxvOES(FogPName pname, int* param) => GLPointers._FogxvOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FrustumxOES(int l, int r, int b, int t, int n, int f) => GLPointers._FrustumxOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetClipPlanexOES(ClipPlaneName plane, int* equation) => GLPointers._GetClipPlanexOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFixedvOES(GetPName pname, int* parameters) => GLPointers._GetFixedvOES_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._GetTexEnvxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._GetTexParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightModelxOES(LightModelParameter pname, int param) => GLPointers._LightModelxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightModelxvOES(LightModelParameter pname, int* param) => GLPointers._LightModelxvOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightxOES(LightName light, LightParameter pname, int param) => GLPointers._LightxOES_fnptr((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightxvOES(LightName light, LightParameter pname, int* parameters) => GLPointers._LightxvOES_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LineWidthxOES(int width) => GLPointers._LineWidthxOES_fnptr(width);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadMatrixxOES(int* m) => GLPointers._LoadMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MaterialxOES(MaterialFace face, MaterialParameter pname, int param) => GLPointers._MaterialxOES_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MaterialxvOES(MaterialFace face, MaterialParameter pname, int* param) => GLPointers._MaterialxvOES_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultMatrixxOES(int* m) => GLPointers._MultMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4xOES(TextureUnit texture, int s, int t, int r, int q) => GLPointers._MultiTexCoord4xOES_fnptr((uint)texture, s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3xOES(int nx, int ny, int nz) => GLPointers._Normal3xOES_fnptr(nx, ny, nz);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void OrthoxOES(int l, int r, int b, int t, int n, int f) => GLPointers._OrthoxOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterxvOES(PointParameterNameARB pname, int* parameters) => GLPointers._PointParameterxvOES_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointSizexOES(int size) => GLPointers._PointSizexOES_fnptr(size);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PolygonOffsetxOES(int factor, int units) => GLPointers._PolygonOffsetxOES_fnptr(factor, units);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RotatexOES(int angle, int x, int y, int z) => GLPointers._RotatexOES_fnptr(angle, x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ScalexOES(int x, int y, int z) => GLPointers._ScalexOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexEnvxOES(TextureEnvTarget target, TextureEnvParameter pname, int param) => GLPointers._TexEnvxOES_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, int* parameters) => GLPointers._TexEnvxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexParameterxOES(TextureTarget target, GetTextureParameter pname, int param) => GLPointers._TexParameterxOES_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, int* parameters) => GLPointers._TexParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TranslatexOES(int x, int y, int z) => GLPointers._TranslatexOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLightxvOES(LightName light, LightParameter pname, int* parameters) => GLPointers._GetLightxvOES_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMaterialxvOES(MaterialFace face, MaterialParameter pname, int* parameters) => GLPointers._GetMaterialxvOES_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterxOES(PointParameterNameARB pname, int param) => GLPointers._PointParameterxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleCoveragexOES(int value, bool invert) => GLPointers._SampleCoveragexOES_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AccumxOES(All op, int value) => GLPointers._AccumxOES_fnptr((uint)op, value);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, byte* bitmap) => GLPointers._BitmapxOES_fnptr(width, height, xorig, yorig, xmove, ymove, bitmap);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void BlendColorxOES(int red, int green, int blue, int alpha) => GLPointers._BlendColorxOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearAccumxOES(int red, int green, int blue, int alpha) => GLPointers._ClearAccumxOES_fnptr(red, green, blue, alpha);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3xOES(int red, int green, int blue) => GLPointers._Color3xOES_fnptr(red, green, blue);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3xvOES(int* components) => GLPointers._Color3xvOES_fnptr(components);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4xvOES(int* components) => GLPointers._Color4xvOES_fnptr(components);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterxOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int param) => GLPointers._ConvolutionParameterxOES_fnptr((uint)target, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int* parameters) => GLPointers._ConvolutionParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalCoord1xOES(int u) => GLPointers._EvalCoord1xOES_fnptr(u);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalCoord1xvOES(int* coords) => GLPointers._EvalCoord1xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalCoord2xOES(int u, int v) => GLPointers._EvalCoord2xOES_fnptr(u, v);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void EvalCoord2xvOES(int* coords) => GLPointers._EvalCoord2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FeedbackBufferxOES(int n, All type, int* buffer) => GLPointers._FeedbackBufferxOES_fnptr(n, (uint)type, buffer);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetConvolutionParameterxvOES(All target, All pname, int* parameters) => GLPointers._GetConvolutionParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int* parameters) => GLPointers._GetHistogramParameterxvOES_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetLightxOES(LightName light, LightParameter pname, int* parameters) => GLPointers._GetLightxOES_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMapxvOES(MapTarget target, GetMapQuery query, int* v) => GLPointers._GetMapxvOES_fnptr((uint)target, (uint)query, v);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetMaterialxOES(MaterialFace face, MaterialParameter pname, int param) => GLPointers._GetMaterialxOES_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelMapxv(PixelMap map, int size, int* values) => GLPointers._GetPixelMapxv_fnptr((uint)map, size, values);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._GetTexGenxvOES_fnptr((uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, int* parameters) => GLPointers._GetTexLevelParameterxvOES_fnptr((uint)target, level, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexxOES(int component) => GLPointers._IndexxOES_fnptr(component);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IndexxvOES(int* component) => GLPointers._IndexxvOES_fnptr(component);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadTransposeMatrixxOES(int* m) => GLPointers._LoadTransposeMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Map1xOES(MapTarget target, int u1, int u2, int stride, int order, int points) => GLPointers._Map1xOES_fnptr((uint)target, u1, u2, stride, order, points);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Map2xOES(MapTarget target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points) => GLPointers._Map2xOES_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapGrid1xOES(int n, int u1, int u2) => GLPointers._MapGrid1xOES_fnptr(n, u1, u2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MapGrid2xOES(int n, int u1, int u2, int v1, int v2) => GLPointers._MapGrid2xOES_fnptr(n, u1, u2, v1, v2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultTransposeMatrixxOES(int* m) => GLPointers._MultTransposeMatrixxOES_fnptr(m);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1xOES(TextureUnit texture, int s) => GLPointers._MultiTexCoord1xOES_fnptr((uint)texture, s);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord1xvOES(TextureUnit texture, int* coords) => GLPointers._MultiTexCoord1xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2xOES(TextureUnit texture, int s, int t) => GLPointers._MultiTexCoord2xOES_fnptr((uint)texture, s, t);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord2xvOES(TextureUnit texture, int* coords) => GLPointers._MultiTexCoord2xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3xOES(TextureUnit texture, int s, int t, int r) => GLPointers._MultiTexCoord3xOES_fnptr((uint)texture, s, t, r);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord3xvOES(TextureUnit texture, int* coords) => GLPointers._MultiTexCoord3xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void MultiTexCoord4xvOES(TextureUnit texture, int* coords) => GLPointers._MultiTexCoord4xvOES_fnptr((uint)texture, coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3xvOES(int* coords) => GLPointers._Normal3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PassThroughxOES(int token) => GLPointers._PassThroughxOES_fnptr(token);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelMapx(PixelMap map, int size, int* values) => GLPointers._PixelMapx_fnptr((uint)map, size, values);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelStorex(PixelStoreParameter pname, int param) => GLPointers._PixelStorex_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTransferxOES(PixelTransferParameter pname, int param) => GLPointers._PixelTransferxOES_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelZoomxOES(int xfactor, int yfactor) => GLPointers._PixelZoomxOES_fnptr(xfactor, yfactor);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PrioritizeTexturesxOES(int n, TextureHandle* textures, int* priorities) => GLPointers._PrioritizeTexturesxOES_fnptr(n, (int*)textures, priorities);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos2xOES(int x, int y) => GLPointers._RasterPos2xOES_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos2xvOES(int* coords) => GLPointers._RasterPos2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos3xOES(int x, int y, int z) => GLPointers._RasterPos3xOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos3xvOES(int* coords) => GLPointers._RasterPos3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos4xOES(int x, int y, int z, int w) => GLPointers._RasterPos4xOES_fnptr(x, y, z, w);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RasterPos4xvOES(int* coords) => GLPointers._RasterPos4xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RectxOES(int x1, int y1, int x2, int y2) => GLPointers._RectxOES_fnptr(x1, y1, x2, y2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void RectxvOES(int* v1, int* v2) => GLPointers._RectxvOES_fnptr(v1, v2);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1xOES(int s) => GLPointers._TexCoord1xOES_fnptr(s);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord1xvOES(int* coords) => GLPointers._TexCoord1xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2xOES(int s, int t) => GLPointers._TexCoord2xOES_fnptr(s, t);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2xvOES(int* coords) => GLPointers._TexCoord2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3xOES(int s, int t, int r) => GLPointers._TexCoord3xOES_fnptr(s, t, r);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord3xvOES(int* coords) => GLPointers._TexCoord3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4xOES(int s, int t, int r, int q) => GLPointers._TexCoord4xOES_fnptr(s, t, r, q);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4xvOES(int* coords) => GLPointers._TexCoord4xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexGenxOES(TextureCoordName coord, TextureGenParameter pname, int param) => GLPointers._TexGenxOES_fnptr((uint)coord, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, int* parameters) => GLPointers._TexGenxvOES_fnptr((uint)coord, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2xOES(int x) => GLPointers._Vertex2xOES_fnptr(x);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex2xvOES(int* coords) => GLPointers._Vertex2xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3xOES(int x, int y) => GLPointers._Vertex3xOES_fnptr(x, y);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex3xvOES(int* coords) => GLPointers._Vertex3xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4xOES(int x, int y, int z) => GLPointers._Vertex4xOES_fnptr(x, y, z);
            
            /// <summary> <b>[requires: GL_OES_fixed_point]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Vertex4xvOES(int* coords) => GLPointers._Vertex4xvOES_fnptr(coords);
            
            /// <summary> <b>[requires: GL_OES_query_matrix]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static All QueryMatrixxOES(int* mantissa, int* exponent) => (All) GLPointers._QueryMatrixxOES_fnptr(mantissa, exponent);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClearDepthfOES(float depth) => GLPointers._ClearDepthfOES_fnptr(depth);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ClipPlanefOES(ClipPlaneName plane, float* equation) => GLPointers._ClipPlanefOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DepthRangefOES(float n, float f) => GLPointers._DepthRangefOES_fnptr(n, f);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FrustumfOES(float l, float r, float b, float t, float n, float f) => GLPointers._FrustumfOES_fnptr(l, r, b, t, n, f);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetClipPlanefOES(ClipPlaneName plane, float* equation) => GLPointers._GetClipPlanefOES_fnptr((uint)plane, equation);
            
            /// <summary> <b>[requires: GL_OES_single_precision]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void OrthofOES(float l, float r, float b, float t, float n, float f) => GLPointers._OrthofOES_fnptr(l, r, b, t, n, f);
            
        }
        public static unsafe partial class OVR
        {
            /// <summary> <b>[requires: GL_OVR_multiview]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FramebufferTextureMultiviewOVR(FramebufferTarget target, FramebufferAttachment attachment, TextureHandle texture, int level, int baseViewIndex, int numViews) => GLPointers._FramebufferTextureMultiviewOVR_fnptr((uint)target, (uint)attachment, (int)texture, level, baseViewIndex, numViews);
            
        }
        public static unsafe partial class PGI
        {
            /// <summary> <b>[requires: GL_PGI_misc_hints]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void HintPGI(HintTargetPGI target, int mode) => GLPointers._HintPGI_fnptr((uint)target, mode);
            
        }
        public static unsafe partial class SGIS
        {
            /// <summary> <b>[requires: GL_SGIS_detail_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DetailTexFuncSGIS(TextureTarget target, int n, float* points) => GLPointers._DetailTexFuncSGIS_fnptr((uint)target, n, points);
            
            /// <summary> <b>[requires: GL_SGIS_detail_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetDetailTexFuncSGIS(TextureTarget target, float* points) => GLPointers._GetDetailTexFuncSGIS_fnptr((uint)target, points);
            
            /// <summary> <b>[requires: GL_SGIS_fog_function]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FogFuncSGIS(int n, float* points) => GLPointers._FogFuncSGIS_fnptr(n, points);
            
            /// <summary> <b>[requires: GL_SGIS_fog_function]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFogFuncSGIS(float* points) => GLPointers._GetFogFuncSGIS_fnptr(points);
            
            /// <summary> <b>[requires: GL_SGIS_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SampleMaskSGIS(float value, bool invert) => GLPointers._SampleMaskSGIS_fnptr(value, (byte)(invert ? 1 : 0));
            
            /// <summary> <b>[requires: GL_SGIS_multisample]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SamplePatternSGIS(SamplePatternSGIS pattern) => GLPointers._SamplePatternSGIS_fnptr((uint)pattern);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenParameteriSGIS(PixelTexGenParameterNameSGIS pname, int param) => GLPointers._PixelTexGenParameteriSGIS_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int* parameters) => GLPointers._PixelTexGenParameterivSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenParameterfSGIS(PixelTexGenParameterNameSGIS pname, float param) => GLPointers._PixelTexGenParameterfSGIS_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float* parameters) => GLPointers._PixelTexGenParameterfvSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int* parameters) => GLPointers._GetPixelTexGenParameterivSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float* parameters) => GLPointers._GetPixelTexGenParameterfvSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfSGIS(PointParameterNameARB pname, float param) => GLPointers._PointParameterfSGIS_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIS_point_parameters]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PointParameterfvSGIS(PointParameterNameARB pname, float* parameters) => GLPointers._PointParameterfvSGIS_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SharpenTexFuncSGIS(TextureTarget target, int n, float* points) => GLPointers._SharpenTexFuncSGIS_fnptr((uint)target, n, points);
            
            /// <summary> <b>[requires: GL_SGIS_sharpen_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetSharpenTexFuncSGIS(TextureTarget target, float* points) => GLPointers._GetSharpenTexFuncSGIS_fnptr((uint)target, points);
            
            /// <summary> <b>[requires: GL_SGIS_texture4D]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexImage4DSGIS(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexImage4DSGIS_fnptr((uint)target, level, (uint)internalformat, width, height, depth, size4d, border, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_SGIS_texture4D]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexSubImage4DSGIS(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, void* pixels) => GLPointers._TexSubImage4DSGIS_fnptr((uint)target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, (uint)format, (uint)type, pixels);
            
            /// <summary> <b>[requires: GL_SGIS_texture_color_mask]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TextureColorMaskSGIS(bool red, bool green, bool blue, bool alpha) => GLPointers._TextureColorMaskSGIS_fnptr((byte)(red ? 1 : 0), (byte)(green ? 1 : 0), (byte)(blue ? 1 : 0), (byte)(alpha ? 1 : 0));
            
            /// <summary> <b>[requires: GL_SGIS_texture_filter4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, float* weights) => GLPointers._GetTexFilterFuncSGIS_fnptr((uint)target, (uint)filter, weights);
            
            /// <summary> <b>[requires: GL_SGIS_texture_filter4]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, int n, float* weights) => GLPointers._TexFilterFuncSGIS_fnptr((uint)target, (uint)filter, n, weights);
            
        }
        public static unsafe partial class SGIX
        {
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void AsyncMarkerSGIX(uint marker) => GLPointers._AsyncMarkerSGIX_fnptr(marker);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int FinishAsyncSGIX(uint* markerp) => GLPointers._FinishAsyncSGIX_fnptr(markerp);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int PollAsyncSGIX(uint* markerp) => GLPointers._PollAsyncSGIX_fnptr(markerp);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static uint GenAsyncMarkersSGIX(int range) => GLPointers._GenAsyncMarkersSGIX_fnptr(range);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeleteAsyncMarkersSGIX(uint marker, int range) => GLPointers._DeleteAsyncMarkersSGIX_fnptr(marker, range);
            
            /// <summary> <b>[requires: GL_SGIX_async]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static bool IsAsyncMarkerSGIX(uint marker) => GLPointers._IsAsyncMarkerSGIX_fnptr(marker) != 0;
            
            /// <summary> <b>[requires: GL_SGIX_flush_raster]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FlushRasterSGIX() => GLPointers._FlushRasterSGIX_fnptr();
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentColorMaterialSGIX(MaterialFace face, MaterialParameter mode) => GLPointers._FragmentColorMaterialSGIX_fnptr((uint)face, (uint)mode);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightfSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float param) => GLPointers._FragmentLightfSGIX_fnptr((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => GLPointers._FragmentLightfvSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightiSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int param) => GLPointers._FragmentLightiSGIX_fnptr((uint)light, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => GLPointers._FragmentLightivSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightModelfSGIX(FragmentLightModelParameterSGIX pname, float param) => GLPointers._FragmentLightModelfSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, float* parameters) => GLPointers._FragmentLightModelfvSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightModeliSGIX(FragmentLightModelParameterSGIX pname, int param) => GLPointers._FragmentLightModeliSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, int* parameters) => GLPointers._FragmentLightModelivSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentMaterialfSGIX(MaterialFace face, MaterialParameter pname, float param) => GLPointers._FragmentMaterialfSGIX_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, float* parameters) => GLPointers._FragmentMaterialfvSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentMaterialiSGIX(MaterialFace face, MaterialParameter pname, int param) => GLPointers._FragmentMaterialiSGIX_fnptr((uint)face, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, int* parameters) => GLPointers._FragmentMaterialivSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float* parameters) => GLPointers._GetFragmentLightfvSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int* parameters) => GLPointers._GetFragmentLightivSGIX_fnptr((uint)light, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, float* parameters) => GLPointers._GetFragmentMaterialfvSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetFragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, int* parameters) => GLPointers._GetFragmentMaterialivSGIX_fnptr((uint)face, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_fragment_lighting]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LightEnviSGIX(LightEnvParameterSGIX pname, int param) => GLPointers._LightEnviSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_framezoom]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FrameZoomSGIX(int factor) => GLPointers._FrameZoomSGIX_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SGIX_igloo_interface]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void IglooInterfaceSGIX(All pname, void* parameters) => GLPointers._IglooInterfaceSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int GetInstrumentsSGIX() => GLPointers._GetInstrumentsSGIX_fnptr();
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void InstrumentsBufferSGIX(int size, int* buffer) => GLPointers._InstrumentsBufferSGIX_fnptr(size, buffer);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static int PollInstrumentsSGIX(int* marker_p) => GLPointers._PollInstrumentsSGIX_fnptr(marker_p);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReadInstrumentsSGIX(int marker) => GLPointers._ReadInstrumentsSGIX_fnptr(marker);
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StartInstrumentsSGIX() => GLPointers._StartInstrumentsSGIX_fnptr();
            
            /// <summary> <b>[requires: GL_SGIX_instruments]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void StopInstrumentsSGIX(int marker) => GLPointers._StopInstrumentsSGIX_fnptr(marker);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetListParameterfvSGIX(uint list, ListParameterName pname, float* parameters) => GLPointers._GetListParameterfvSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetListParameterivSGIX(uint list, ListParameterName pname, int* parameters) => GLPointers._GetListParameterivSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListParameterfSGIX(uint list, ListParameterName pname, float param) => GLPointers._ListParameterfSGIX_fnptr(list, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListParameterfvSGIX(uint list, ListParameterName pname, float* parameters) => GLPointers._ListParameterfvSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListParameteriSGIX(uint list, ListParameterName pname, int param) => GLPointers._ListParameteriSGIX_fnptr(list, (uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_list_priority]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ListParameterivSGIX(uint list, ListParameterName pname, int* parameters) => GLPointers._ListParameterivSGIX_fnptr(list, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_pixel_texture]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void PixelTexGenSGIX(PixelTexGenModeSGIX mode) => GLPointers._PixelTexGenSGIX_fnptr((uint)mode);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double* points) => GLPointers._DeformationMap3dSGIX_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float* points) => GLPointers._DeformationMap3fSGIX_fnptr((uint)target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DeformSGIX(FfdMaskSGIX mask) => GLPointers._DeformSGIX_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_SGIX_polynomial_ffd]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void LoadIdentityDeformationMapSGIX(FfdMaskSGIX mask) => GLPointers._LoadIdentityDeformationMapSGIX_fnptr((uint)mask);
            
            /// <summary> <b>[requires: GL_SGIX_reference_plane]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReferencePlaneSGIX(double* equation) => GLPointers._ReferencePlaneSGIX_fnptr(equation);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpriteParameterfSGIX(SpriteParameterNameSGIX pname, float param) => GLPointers._SpriteParameterfSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, float* parameters) => GLPointers._SpriteParameterfvSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpriteParameteriSGIX(SpriteParameterNameSGIX pname, int param) => GLPointers._SpriteParameteriSGIX_fnptr((uint)pname, param);
            
            /// <summary> <b>[requires: GL_SGIX_sprite]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, int* parameters) => GLPointers._SpriteParameterivSGIX_fnptr((uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGIX_tag_sample_buffer]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TagSampleBufferSGIX() => GLPointers._TagSampleBufferSGIX_fnptr();
            
        }
        public static unsafe partial class SGI
        {
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, void* table) => GLPointers._ColorTableSGI_fnptr((uint)target, (uint)internalformat, width, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, float* parameters) => GLPointers._ColorTableParameterfvSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, int* parameters) => GLPointers._ColorTableParameterivSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void CopyColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int x, int y, int width) => GLPointers._CopyColorTableSGI_fnptr((uint)target, (uint)internalformat, x, y, width);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableSGI(ColorTableTargetSGI target, PixelFormat format, PixelType type, void* table) => GLPointers._GetColorTableSGI_fnptr((uint)target, (uint)format, (uint)type, table);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableParameterfvSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, float* parameters) => GLPointers._GetColorTableParameterfvSGI_fnptr((uint)target, (uint)pname, parameters);
            
            /// <summary> <b>[requires: GL_SGI_color_table]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GetColorTableParameterivSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, int* parameters) => GLPointers._GetColorTableParameterivSGI_fnptr((uint)target, (uint)pname, parameters);
            
        }
        public static unsafe partial class SUNX
        {
            /// <summary> <b>[requires: GL_SUNX_constant_data]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void FinishTextureSUNX() => GLPointers._FinishTextureSUNX_fnptr();
            
        }
        public static unsafe partial class SUN
        {
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorbSUN(sbyte factor) => GLPointers._GlobalAlphaFactorbSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorsSUN(short factor) => GLPointers._GlobalAlphaFactorsSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactoriSUN(int factor) => GLPointers._GlobalAlphaFactoriSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorfSUN(float factor) => GLPointers._GlobalAlphaFactorfSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactordSUN(double factor) => GLPointers._GlobalAlphaFactordSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorubSUN(byte factor) => GLPointers._GlobalAlphaFactorubSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactorusSUN(ushort factor) => GLPointers._GlobalAlphaFactorusSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_global_alpha]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void GlobalAlphaFactoruiSUN(uint factor) => GLPointers._GlobalAlphaFactoruiSUN_fnptr(factor);
            
            /// <summary> <b>[requires: GL_SUN_mesh_array]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void DrawMeshArraysSUN(PrimitiveType mode, int first, int count, int width) => GLPointers._DrawMeshArraysSUN_fnptr((uint)mode, first, count, width);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiSUN(uint code) => GLPointers._ReplacementCodeuiSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeusSUN(ushort code) => GLPointers._ReplacementCodeusSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeubSUN(byte code) => GLPointers._ReplacementCodeubSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuivSUN(uint* code) => GLPointers._ReplacementCodeuivSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeusvSUN(ushort* code) => GLPointers._ReplacementCodeusvSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeubvSUN(byte* code) => GLPointers._ReplacementCodeubvSUN_fnptr(code);
            
            /// <summary> <b>[requires: GL_SUN_triangle_list]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodePointerSUN(ReplacementCodeTypeSUN type, int stride, void** pointer) => GLPointers._ReplacementCodePointerSUN_fnptr((uint)type, stride, pointer);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4ubVertex2fSUN(byte r, byte g, byte b, byte a, float x, float y) => GLPointers._Color4ubVertex2fSUN_fnptr(r, g, b, a, x, y);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4ubVertex2fvSUN(byte* c, float* v) => GLPointers._Color4ubVertex2fvSUN_fnptr(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4ubVertex3fSUN(byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers._Color4ubVertex3fSUN_fnptr(r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4ubVertex3fvSUN(byte* c, float* v) => GLPointers._Color4ubVertex3fvSUN_fnptr(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3fVertex3fSUN(float r, float g, float b, float x, float y, float z) => GLPointers._Color3fVertex3fSUN_fnptr(r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color3fVertex3fvSUN(float* c, float* v) => GLPointers._Color3fVertex3fvSUN_fnptr(c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3fVertex3fSUN(float nx, float ny, float nz, float x, float y, float z) => GLPointers._Normal3fVertex3fSUN_fnptr(nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Normal3fVertex3fvSUN(float* n, float* v) => GLPointers._Normal3fVertex3fvSUN_fnptr(n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4fNormal3fVertex3fSUN(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._Color4fNormal3fVertex3fSUN_fnptr(r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void Color4fNormal3fVertex3fvSUN(float* c, float* n, float* v) => GLPointers._Color4fNormal3fVertex3fvSUN_fnptr(c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fVertex3fSUN(float s, float t, float x, float y, float z) => GLPointers._TexCoord2fVertex3fSUN_fnptr(s, t, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fVertex3fvSUN(float* tc, float* v) => GLPointers._TexCoord2fVertex3fvSUN_fnptr(tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4fVertex4fSUN(float s, float t, float p, float q, float x, float y, float z, float w) => GLPointers._TexCoord4fVertex4fSUN_fnptr(s, t, p, q, x, y, z, w);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4fVertex4fvSUN(float* tc, float* v) => GLPointers._TexCoord4fVertex4fvSUN_fnptr(tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor4ubVertex3fSUN(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers._TexCoord2fColor4ubVertex3fSUN_fnptr(s, t, r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor4ubVertex3fvSUN(float* tc, byte* c, float* v) => GLPointers._TexCoord2fColor4ubVertex3fvSUN_fnptr(tc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor3fVertex3fSUN(float s, float t, float r, float g, float b, float x, float y, float z) => GLPointers._TexCoord2fColor3fVertex3fSUN_fnptr(s, t, r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor3fVertex3fvSUN(float* tc, float* c, float* v) => GLPointers._TexCoord2fColor3fVertex3fvSUN_fnptr(tc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fNormal3fVertex3fSUN(float s, float t, float nx, float ny, float nz, float x, float y, float z) => GLPointers._TexCoord2fNormal3fVertex3fSUN_fnptr(s, t, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fNormal3fVertex3fvSUN(float* tc, float* n, float* v) => GLPointers._TexCoord2fNormal3fVertex3fvSUN_fnptr(tc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor4fNormal3fVertex3fSUN(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._TexCoord2fColor4fNormal3fVertex3fSUN_fnptr(s, t, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float* c, float* n, float* v) => GLPointers._TexCoord2fColor4fNormal3fVertex3fvSUN_fnptr(tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4fColor4fNormal3fVertex4fSUN(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w) => GLPointers._TexCoord4fColor4fNormal3fVertex4fSUN_fnptr(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void TexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float* c, float* n, float* v) => GLPointers._TexCoord4fColor4fNormal3fVertex4fvSUN_fnptr(tc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiVertex3fSUN(uint rc, float x, float y, float z) => GLPointers._ReplacementCodeuiVertex3fSUN_fnptr(rc, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiVertex3fvSUN(uint* rc, float* v) => GLPointers._ReplacementCodeuiVertex3fvSUN_fnptr(rc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor4ubVertex3fSUN(uint rc, byte r, byte g, byte b, byte a, float x, float y, float z) => GLPointers._ReplacementCodeuiColor4ubVertex3fSUN_fnptr(rc, r, g, b, a, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor4ubVertex3fvSUN(uint* rc, byte* c, float* v) => GLPointers._ReplacementCodeuiColor4ubVertex3fvSUN_fnptr(rc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor3fVertex3fSUN(uint rc, float r, float g, float b, float x, float y, float z) => GLPointers._ReplacementCodeuiColor3fVertex3fSUN_fnptr(rc, r, g, b, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor3fVertex3fvSUN(uint* rc, float* c, float* v) => GLPointers._ReplacementCodeuiColor3fVertex3fvSUN_fnptr(rc, c, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiNormal3fVertex3fSUN(uint rc, float nx, float ny, float nz, float x, float y, float z) => GLPointers._ReplacementCodeuiNormal3fVertex3fSUN_fnptr(rc, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiNormal3fVertex3fvSUN(uint* rc, float* n, float* v) => GLPointers._ReplacementCodeuiNormal3fVertex3fvSUN_fnptr(rc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor4fNormal3fVertex3fSUN(uint rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._ReplacementCodeuiColor4fNormal3fVertex3fSUN_fnptr(rc, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float* c, float* n, float* v) => GLPointers._ReplacementCodeuiColor4fNormal3fVertex3fvSUN_fnptr(rc, c, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fVertex3fSUN(uint rc, float s, float t, float x, float y, float z) => GLPointers._ReplacementCodeuiTexCoord2fVertex3fSUN_fnptr(rc, s, t, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fVertex3fvSUN(uint* rc, float* tc, float* v) => GLPointers._ReplacementCodeuiTexCoord2fVertex3fvSUN_fnptr(rc, tc, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(uint rc, float s, float t, float nx, float ny, float nz, float x, float y, float z) => GLPointers._ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_fnptr(rc, s, t, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float* tc, float* n, float* v) => GLPointers._ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_fnptr(rc, tc, n, v);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(uint rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => GLPointers._ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_fnptr(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
            
            /// <summary> <b>[requires: GL_SUN_vertex]</b>  </summary>
            /// <remarks><see href="" /></remarks>
            public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float* c, float* n, float* v) => GLPointers._ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_fnptr(rc, tc, c, n, v);
            
        }
    }
}
